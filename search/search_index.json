{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geonate","text":"<p>Python package synthesizes conventional tools and codes for image processing</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://canng.github.io/geonate</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <p>New Features:</p>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geonate.common.array2raster","title":"<code>array2raster(array, meta)</code>","text":"<p>Convert a numpy array and metadata to a rasterio object stored in memory.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>The input data array.</p> required <code>meta</code> <code>Dict</code> <p>The metadata dictionary.</p> required <p>Returns:</p> Type Description <code>rasterio.io.DatasetReader</code> <p>The rasterio object stored in memory.</p> Source code in <code>geonate/common.py</code> <pre><code>def array2raster(array, meta: Dict):\n    \"\"\"\n    Convert a numpy array and metadata to a rasterio object stored in memory.\n\n    Args:\n        array (np.ndarray): The input data array.\n        meta (Dict): The metadata dictionary.\n\n    Returns:\n        rasterio.io.DatasetReader: The rasterio object stored in memory.\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    from rasterio.io import MemoryFile\n\n    # Update metadata with the correct dtype and count\n    meta.update({\n        'dtype': array.dtype,\n        'count': array.shape[0] if array.ndim == 3 else 1\n    })\n\n    with MemoryFile() as memfile:\n        with memfile.open(**meta) as dataset:\n            dataset.write(array, 1 if array.ndim == 2 else None)\n        return memfile.open()\n</code></pre>"},{"location":"common/#geonate.common.cellSize","title":"<code>cellSize(input, unit='km', meta=None, output=None)</code>","text":"<p>Calculate pixel size (area), the input has to be in the projection of 'EPSG:4326'. If not, it can be reprojected by \"project\" function</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>unit</code> <code>AnyStr</code> <p>Unit of original input. Defaults to 'km'.</p> <code>'km'</code> <code>meta</code> <code>AnyStr</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/common.py</code> <pre><code>def cellSize(input, unit: AnyStr='km', meta: Optional[AnyStr]=None, output: Optional[AnyStr]=None):\n    \"\"\"Calculate pixel size (area), the input has to be in the projection of 'EPSG:4326'. If not, it can be reprojected by \"project\" function\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        unit (AnyStr, optional): Unit of original input. Defaults to 'km'.\n        meta (AnyStr, optional): Metadata in case input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import pandas as pd\n    import raster\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        if len(input.shape) == 2:\n            dataset = input.read()\n            meta = input.meta\n        else:\n            dataset = input.read(1)\n            meta = input.meta\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Please provide input metadata')\n        else:\n            if len(input) &gt; 2:\n                dataset = input[0, :, : ]\n            else:\n                dataset = input\n            meta = meta\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Read metadata\n    transform = meta['transform']\n    pix_width = transform[0]\n    upper_X = transform[2]\n    upper_Y = transform[5]\n    rows = meta['height']\n    cols = meta['width']\n    lower_X = upper_X + transform[0] * cols\n    lower_Y = upper_Y + transform[4] * rows\n\n    lats = np.linspace(upper_Y, lower_Y, rows + 1)\n\n    a = 6378137.0  # Equatorial radius\n    b = 6356752.3142  # Polar radius\n\n    # Degrees to radians\n    lats = lats * np.pi/180\n\n    # Intermediate vars\n    e = np.sqrt(1-(b/a)**2)\n    sinlats = np.sin(lats)\n    zm = 1 - e * sinlats\n    zp = 1 + e * sinlats\n\n    # Distance between meridians\n    q = pix_width/360\n\n    # Compute areas for each latitude in square km\n    areas_to_equator = np.pi * b**2 * ((2*np.arctanh(e*sinlats) / (2*e) + sinlats / (zp*zm))) / 10**6\n    areas_between_lats = np.diff(areas_to_equator)\n    areas_cells = np.abs(areas_between_lats) * q\n\n    # Create empty array to store output\n    cellArea = np.zeros_like(dataset, dtype=np.float32)\n\n    # Assign estimated cell area to every pixel\n    if len(cellArea.shape) == 2:\n        for i in range(0, cellArea.shape[1]):\n            cellArea[:, i] = areas_cells.flatten()\n    else:\n        for i in range(0, cellArea.shape[2]):\n            cellArea[:, :, i] = areas_cells.flatten()\n\n    ### Update metadata\n    meta.update({'dtype': np.float32, 'count': 1})\n\n    ### Convert unit (if applicable)\n    if (unit.lower() == 'km') or (unit.lower() == 'kilometer'):\n        outArea = cellArea\n    elif (unit.lower() == 'm') or (unit.lower() == 'meter'):\n        outArea = cellArea * 1_000_000\n    elif (unit.lower() == 'ha') or (unit.lower() == 'hectare'):\n        outArea = cellArea * 10_000\n\n    # Write output\n    if output is not None:\n        raster.writeRaster(outArea, output, meta)\n    else:\n        return outArea, meta\n</code></pre>"},{"location":"common/#geonate.common.empty_dataframe","title":"<code>empty_dataframe(nrows, ncols, value='NA', name=None)</code>","text":"<p>Create an empty dataframe</p> <p>Parameters:</p> Name Type Description Default <code>nrows</code> <code>numeric</code> <p>Numbers of rows</p> required <code>ncols</code> <code>numeric</code> <p>Number of columns</p> required <code>value</code> <code>str | numeric</code> <p>Input value in all cells. Defaults to 'NA'.</p> <code>'NA'</code> <code>name</code> <code>list</code> <p>Names of columns, if not given, it will return default as number of column. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>pandas dataframe</code> <p>An empty filled with NA or user-defined number (e.g., 0)</p> Source code in <code>geonate/common.py</code> <pre><code>def empty_dataframe(nrows, ncols, value='NA', name=None):\n    \"\"\"Create an empty dataframe\n\n    Args:\n        nrows (numeric): Numbers of rows\n        ncols (numeric): Number of columns\n        value (str | numeric, optional): Input value in all cells. Defaults to 'NA'.\n        name (list, optional): Names of columns, if not given, it will return default as number of column. Defaults to None.\n\n    Returns:\n        pandas dataframe: An empty filled with NA or user-defined number (e.g., 0)\n\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    # Check validity of column name\n    if name is None:\n        column_names = [f'Col_{i+1}' for i in range(ncols)]\n    elif len(name) == ncols:\n        column_names = name\n    else:\n        raise ValueError(\"Length of column names vector must match numbers of columns\")\n\n    # check input value\n    try: \n        if isinstance(value, int):\n            val = value\n        elif isinstance(value, float):\n            val = value\n        else:\n            val = np.nan\n    except ValueError:\n        val = np.nan\n\n    # Create data and parse it into dataframe \n    data = [[val] * ncols for _ in range(nrows)]\n    dataframe = pd.DataFrame(data, columns= column_names)\n\n    return dataframe\n</code></pre>"},{"location":"common/#geonate.common.extent","title":"<code>extent(input, poly=True)</code>","text":"<p>Get spatial extent of geotif image from a list or local variable</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>An input as a list of geotif files or local image/shapefile</p> required <code>poly</code> <code>bool</code> <p>Whether returns the extent polygon as geopandas object. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>extent</code> <p>Bounding box in form of BoundingBox(left, bottom, right, top) polygon: Geospatial shapefile polygon of the outside extent</p> Source code in <code>geonate/common.py</code> <pre><code>def extent(input: AnyStr, poly: bool= True):\n    \"\"\"Get spatial extent of geotif image from a list or local variable\n\n    Args:\n        input (list): An input as a list of geotif files or local image/shapefile\n        poly (bool, optional): Whether returns the extent polygon as geopandas object. Defaults to True.\n\n    Returns:\n        extent: Bounding box in form of BoundingBox(left, bottom, right, top)\n        polygon: Geospatial shapefile polygon of the outside extent\n\n    \"\"\"\n    import rasterio\n    import geopandas as gpd\n    from shapely.geometry import Polygon\n\n    general_extent = None\n\n    # get extent for raster files store in folder\n    if (isinstance(input, list)) or (isinstance(input, str)):\n        for file in input:\n            with rasterio.open(file) as src:\n                ext = src.bounds\n                crs = src.crs\n\n                if general_extent is None:\n                    general_extent = ext\n                else:\n                    general_extent =  (\n                        min(general_extent[0], ext[0]),\n                        min(general_extent[1], ext[1]),\n                        max(general_extent[2], ext[2]),\n                        max(general_extent[3], ext[3])\n                        )\n\n    # get extent for local read shapefile    \n    elif isinstance(input, gpd.GeoDataFrame):\n        ext = input.bounds\n        crs = input.crs\n        general_extent = (ext['minx'], ext['miny'],\n                                        ext['maxx'], ext['maxy'])\n\n    # get extent for local read geotif \n    else:\n        general_extent = input.bounds\n        crs = input.crs\n\n    # return rectangle of extennt\n    if poly is True:\n        poly_geom = Polygon([\n            (general_extent[0], general_extent[1]), \n            (general_extent[2], general_extent[1]), \n            (general_extent[2], general_extent[3]), \n            (general_extent[0], general_extent[3])\n            ])\n        poly = gpd.GeoDataFrame(index=[0], geometry=[poly_geom])\n        poly.crs = {'init': crs}\n    else: \n        poly = None\n\n    return general_extent, poly\n</code></pre>"},{"location":"common/#geonate.common.listFiles","title":"<code>listFiles(path, pattern, search_type='pattern', full_name=True)</code>","text":"<p>List all files with specific pattern within a folder path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>AnyStr</code> <p>Folder path where files stored</p> required <code>pattern</code> <code>AnyStr</code> <p>Search pattern of files (e.g., '*.tif')</p> required <code>search_type</code> <code>AnyStr</code> <p>Search type whether by \"extension\" or name \"pattern\". Defaults to 'pattern'.</p> <code>'pattern'</code> <code>full_name</code> <code>bool</code> <p>Whether returning full name with path detail or only file name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of file paths</p> Source code in <code>geonate/common.py</code> <pre><code>def listFiles(path: AnyStr, pattern: AnyStr, search_type: AnyStr = 'pattern', full_name: bool=True):\n    \"\"\"List all files with specific pattern within a folder path\n\n    Args:\n        path (AnyStr): Folder path where files stored\n        pattern (AnyStr): Search pattern of files (e.g., '*.tif')\n        search_type (AnyStr, optional): Search type whether by \"extension\" or name \"pattern\". Defaults to 'pattern'.\n        full_name (bool, optional): Whether returning full name with path detail or only file name. Defaults to True.\n\n    Returns:\n        list: A list of file paths\n\n    \"\"\"\n    import os\n    import fnmatch\n\n    # Create empty list to store list of files\n    files_list = []\n\n    # Check search type\n    if (search_type.upper() == 'EXTENSION') or (search_type.upper() == 'E'):\n        if '*' in pattern:\n            raise ValueError(\"Do not use '*' in the pattern of extension search\")\n        else:\n            for root, dirs, files in os.walk(path):\n                for file in files:\n                    if file.lower().endswith(pattern):\n                        if full_name is True:\n                            files_list.append(os.path.join(root, file))\n                        else:\n                            files_list.append(file)    \n\n    elif (search_type.upper() == 'PATTERN') or (search_type.upper() == 'P'):\n        if '*' not in pattern:\n            raise ValueError(\"Pattern search requires '*' in pattern\")\n        else:\n            for root, dirs, files in os.walk(path):\n                for file in fnmatch.filter(files, pattern):\n                    if full_name is True:\n                        files_list.append(os.path.join(root, file))\n                    else:\n                        files_list.append(file)\n\n    else:\n        raise ValueError('Search pattern must be one of these types (pattern, p, extension, e)')\n\n    return files_list\n</code></pre>"},{"location":"common/#geonate.common.meter2degree","title":"<code>meter2degree(input, latitude=None)</code>","text":"<p>Convert image resolution from meter to acr-degree depending on location of latitude</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>numeric</code> <p>Input resolution of distance</p> required <code>latitude</code> <code>numeric</code> <p>Latitude presents location. If latitude is None, the location is assumed near Equator. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>numeric</code> <p>Degree corresponding to the distance length</p> Source code in <code>geonate/common.py</code> <pre><code>def meter2degree(input, latitude=None):\n    \"\"\"Convert image resolution from meter to acr-degree depending on location of latitude\n\n    Args:\n        input (numeric): Input resolution of distance\n        latitude (numeric, optional): Latitude presents location. If latitude is None, the location is assumed near Equator. Defaults to None.\n\n    Returns:\n        numeric: Degree corresponding to the distance length\n\n    \"\"\"\n    import numpy as np\n\n    if latitude is None:\n        # Equator location\n        degree = input / (111320 * np.cos(np.radians(0.0)))\n    else:\n        degree = input / (111320 * np.cos(np.radians(latitude)))\n\n    return degree\n</code></pre>"},{"location":"common/#geonate.common.mimax","title":"<code>mimax(input, digit=3)</code>","text":"<p>Calculate maximum and minimum values of raster or array</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>digit</code> <code>int</code> <p>Precise digit number. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>numeric</code> <p>Return 2 numbers of minvalue and maxvalue</p> Source code in <code>geonate/common.py</code> <pre><code>def mimax(input, digit=3):\n    \"\"\"Calculate maximum and minimum values of raster or array\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        digit (int, optional): Precise digit number. Defaults to 3.\n\n    Returns:\n        numeric: Return 2 numbers of minvalue and maxvalue\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Calculate min and max values\n    minValue = round(np.nanmin(dataset), digit)\n    maxValue = round(np.nanmax(dataset), digit)\n\n    # Convert min and max to string for print\n    min_round = str(round(minValue, digit))\n    max_round = str(round(maxValue, digit))\n\n    print(f\"Min: {min_round} \\nMax: {max_round}\")\n\n    return minValue, maxValue\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/canng/geonate/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geonate could always use more documentation, whether as part of the official geonate docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/canng/geonate/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geonate for local development.</p> <ol> <li> <p>Fork the geonate repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geonate.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geonate\n$ cd geonate/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geonate tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/canng/geonate/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geonate/","title":"geonate module","text":"<p>Main module.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geonate, run this command in your terminal:</p> <pre><code>pip install geonate\n</code></pre> <p>This is the preferred method to install geonate, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geonate from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/canng/geonate\n</code></pre>"},{"location":"plot/","title":"plot module","text":"<p>The visualization module</p>"},{"location":"plot/#geonate.plot.colormaps","title":"<code>colormaps()</code>","text":"<p>Display all available colormaps in Matplotlib.</p> <p>This function generates a plot that shows all the colormaps available in Matplotlib. Each colormap is displayed as a horizontal gradient bar.</p> Source code in <code>geonate/plot.py</code> <pre><code>def colormaps():   \n    \"\"\"\n    Display all available colormaps in Matplotlib.\n\n    This function generates a plot that shows all the colormaps available in Matplotlib.\n    Each colormap is displayed as a horizontal gradient bar.\n\n    \"\"\" \n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # Get all colormaps available in Matplotlib\n    colormaps = plt.colormaps()\n\n    # Generate a gradient to display colormaps\n    gradient = np.linspace(0, 1, 256).reshape(1, -1)\n\n    # Set figure size\n    fig, ax = plt.subplots(figsize=(10, len(colormaps) * 0.25))\n\n    # Loop through colormaps and display them\n    for i, cmap in enumerate(colormaps):\n        ax.imshow(np.vstack([gradient] * 5), aspect='auto', cmap=cmap, extent=[0, 10, i, i + 1])\n\n    # Formatting\n    ax.set_yticks(np.arange(len(colormaps)) + 0.5)\n    ax.set_yticklabels(colormaps)\n    ax.set_xticks([])\n    ax.set_title(\"Matplotlib Colormaps\", fontsize=12, fontweight=\"bold\")\n    ax.set_ylim(0, len(colormaps))\n\n    plt.show()\n</code></pre>"},{"location":"plot/#geonate.plot.plot","title":"<code>plot(input, cmap='Greys_r', **kwargs)</code>","text":"<p>Plot a raster image or data array using earthpy.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>cmap</code> <code>str</code> <p>Colormap for the plot. Defaults to 'Greys_r'.</p> <code>'Greys_r'</code> <code>**kwargs</code> <code>AnyStr</code> <p>All optional parameters taken from earthpy.plot.plot_bands(), such as cmap='Spectral' for color shade</p> <code>{}</code> Source code in <code>geonate/plot.py</code> <pre><code>def plot(input, cmap='Greys_r', **kwargs):\n    \"\"\"Plot a raster image or data array using earthpy.\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        cmap (str, optional): Colormap for the plot. Defaults to 'Greys_r'.\n        **kwargs (AnyStr, optional): All optional parameters taken from earthpy.plot.plot_bands(), such as cmap='Spectral' for color shade\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    import earthpy.plot as ep\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Visualize the input dataset\n    ep.plot_bands(dataset, cmap=cmap, **kwargs)\n</code></pre>"},{"location":"plot/#geonate.plot.plotRGB","title":"<code>plotRGB(input, rgb=(0, 1, 2), stretch=True, **kwargs)</code>","text":"<p>Plot a 3-band RGB image using earthpy.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>rasterio.DatasetReader | np.ndarray</code> <p>Rasterio image or data array.</p> required <code>rgb</code> <code>tuple</code> <p>Indices of the RGB bands. Defaults to (0, 1, 2).</p> <code>(0, 1, 2)</code> <code>stretch</code> <code>bool</code> <p>Apply contrast stretching. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional optional parameters for earthpy.plot.plot_rgb(), such as stretch=True for contrast stretching.</p> <code>{}</code> Source code in <code>geonate/plot.py</code> <pre><code>def plotRGB(input, rgb=(0, 1, 2), stretch=True, **kwargs):\n    \"\"\"\n    Plot a 3-band RGB image using earthpy.\n\n    Args:\n        input (rasterio.DatasetReader | np.ndarray): Rasterio image or data array.\n        rgb (tuple, optional): Indices of the RGB bands. Defaults to (0, 1, 2).\n        stretch (bool, optional): Apply contrast stretching. Defaults to True.\n        **kwargs: Additional optional parameters for earthpy.plot.plot_rgb(), such as stretch=True for contrast stretching.\n\n    \"\"\"    \n    import numpy as np\n    import rasterio\n    import earthpy.plot as ep\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Check data dimension to make sure it is a multiple band image\n    if len(dataset) &lt;= 2:\n        raise ValueError('Image has only one band, please provide at least 3-band image')\n\n    # Visualize the input dataset\n    ep.plot_rgb(dataset, rgb= rgb, stretch=stretch, **kwargs)\n</code></pre>"},{"location":"raster/","title":"raster module","text":"<p>The raster module</p>"},{"location":"raster/#geonate.raster.crop","title":"<code>crop(input, reference, input_meta=None, reference_meta=None, invert=False, nodata=None, output=None)</code>","text":"<p>Crop raster opened by rasterio by shapefile vector or another image</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader</code> <p>Image or data array input that need to crop</p> required <code>reference</code> <code>DatasetReader | GeoDataFrame | np.ndarray</code> <p>Region of interest, Shapefile opened by geopandas or Another image or Data array to crop</p> required <code>input_meta</code> <code>Dict</code> <p>Metadata when input is data array. Defaults to None.</p> <code>None</code> <code>reference_meta</code> <code>Dict</code> <p>Metadata when reference is data array. Defaults to None.</p> <code>None</code> <code>invert</code> <code>bool</code> <p>If True, pixels inside shapefile will be masked. Defaults to False.</p> <code>False</code> <code>nodata</code> <code>Any</code> <p>None or any number to fill nodata pixels. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image </p> Source code in <code>geonate/raster.py</code> <pre><code>def crop(input, reference, input_meta: Optional[Dict]=None, reference_meta: Optional[Dict]=None, invert=False, nodata=None, output: Optional[AnyStr]=None):\n    \"\"\"Crop raster opened by rasterio by shapefile vector or another image\n\n    Args:\n        input (DatasetReader): Image or data array input that need to crop\n        reference (DatasetReader | GeoDataFrame | np.ndarray): Region of interest, Shapefile opened by geopandas or Another image or Data array to crop\n        input_meta (Dict, optional): Metadata when input is data array. Defaults to None.\n        reference_meta (Dict, optional): Metadata when reference is data array. Defaults to None.\n        invert (bool, optional): If True, pixels inside shapefile will be masked. Defaults to False.\n        nodata (Any, optional): None or any number to fill nodata pixels. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image \n\n    \"\"\"\n    import rasterio\n    from rasterio.transform import Affine\n    from shapely.geometry import mapping\n    from shapely.geometry import box\n    import geopandas as gpd\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            if not os.path.exists('./tmp/'):\n                os.makedirs('./tmp/')\n            writeRaster(input, './tmp/tmp.tif', input_meta)\n            input_image = rast('./tmp/tmp.tif')\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Define boundary\n    # Reference is shapefile\n    if isinstance(reference, gpd.GeoDataFrame):\n        minx, miny, maxx, maxy = reference.total_bounds\n        # define box\n        bbox = box(minx, miny, maxx, maxy)\n        poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs=reference.crs)\n    # Reference is raster\n    elif isinstance(reference, rasterio.DatasetReader):\n        minx, miny, maxx, maxy = reference.bounds\n        # define box\n        bbox = box(minx, miny, maxx, maxy)\n        poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs=reference.crs)\n    # Reference is array\n    elif isinstance(reference, np.ndarray):\n        if reference_meta is None:\n            raise ValueError('It requires metadata of reference')\n        else:\n            minx, miny = reference_meta['transform'] * (0, 0)\n            maxx, maxy = reference_meta['transform']* (reference_meta['width'], reference_meta['height'])\n            # define box\n            bbox = box(minx, miny, maxx, maxy)\n            poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs= reference_meta['crs'])\n    else:\n        raise ValueError('Reference data is not supported')   \n\n    ### Define nodata\n    if nodata is None:\n        dataType = input_image.meta['dtype']\n        if dataType.lower() == 'int8':\n            nodata_value = 127\n        elif dataType.lower() == 'uint8':\n            nodata_value = 255\n        elif dataType.lower() == 'int16':\n            nodata_value = 32767\n        elif dataType.lower() == 'uint16':\n            nodata_value = 65535\n        elif dataType.lower() == 'int32':\n            nodata_value = 2147483647\n        elif dataType.lower() == 'uint32':\n            nodata_value == 4294967295\n        elif dataType.lower() == 'float16':\n            nodata_value = 65500\n        elif dataType.lower() == 'float32':\n            nodata_value == 999999\n        else:\n            nodata_value == 0\n    else:\n        nodata_value = nodata    \n\n    ### Invert crop\n    if invert is True:\n        clipped, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), crop=True, invert=True, nodata=-999999)\n    else:\n        clipped, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), crop=True, nodata=-999999)\n\n    # Define metadata\n    meta  = input_image.meta\n    meta.update({\n        'height': clipped.shape[1],\n        'width': clipped.shape[2],\n        'transform': geotranform,\n        'dtype': np.float32,\n        'nodata': nodata_value})\n\n    # Write output\n    if output is not None:\n        writeRaster(clipped, output, meta)\n    else:\n        return clipped, meta\n</code></pre>"},{"location":"raster/#geonate.raster.extractValues","title":"<code>extractValues(input, roi, field=None, meta=None, dataframe=True, names=None, na_rm=True, nodata=None, prefix=None, tail=True)</code>","text":"<p>Extract pixel values in GCP for both point and polygon </p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>roi</code> <code>AnyStr</code> <p>Shapefile where GCP points located, read by geopandas </p> required <code>field</code> <code>AnyStr</code> <p>Sstring, but the value of this field must be number, the field name in shapefile GCP to extract label values, e.g., 'class'. Defaults to None.</p> <code>None</code> <code>meta</code> <code>AnyStr</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>dataframe</code> <code>bool</code> <p>Whether to return dataframe or separate X, y arrays. Defaults to True.</p> <code>True</code> <code>names</code> <code>list</code> <p>Given expected names for each column in dataframe. Defaults to None.</p> <code>None</code> <code>na_rm</code> <code>bool</code> <p>Remove NA value from the output or not. Defaults to True.</p> <code>True</code> <code>nodata</code> <code>AnyStr</code> <p>Fill in value for NA data. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>AnyStr</code> <p>Given character before each band name. Defaults to None.</p> <code>None</code> <code>tail</code> <code>bool</code> <p>To place the class value at the end or front of the dataframe. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dataframe</code> <p>dataframe if dataframe = True ndarray: X, y Data arrays for training model</p> Source code in <code>geonate/raster.py</code> <pre><code>def extractValues(input: AnyStr, roi: AnyStr, field: Optional[AnyStr]=None, meta: Optional[AnyStr]=None, dataframe: Optional[bool]=True, names: Optional[list]=None, na_rm: bool=True, nodata=None, prefix: Optional[AnyStr]=None, tail=True):\n    \"\"\"Extract pixel values in GCP for both point and polygon \n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        roi (AnyStr): Shapefile where GCP points located, read by geopandas \n        field (AnyStr, optional): Sstring, but the value of this field must be number, the field name in shapefile GCP to extract label values, e.g., 'class'. Defaults to None.\n        meta (AnyStr, optional): Metadata in case input is data array. Defaults to None.\n        dataframe (bool, optional): Whether to return dataframe or separate X, y arrays. Defaults to True.\n        names (list, optional): Given expected names for each column in dataframe. Defaults to None.\n        na_rm (bool, optional): Remove NA value from the output or not. Defaults to True.\n        nodata (AnyStr, optional): Fill in value for NA data. Defaults to None.\n        prefix (AnyStr, optional): Given character before each band name. Defaults to None.\n        tail (bool, optional): To place the class value at the end or front of the dataframe. Defaults to True.\n\n    Returns:\n        dataframe: dataframe if dataframe = True\n        ndarray: X, y Data arrays for training model\n\n    \"\"\"\n    import os\n    import rasterio\n    from rasterio.plot import reshape_as_image\n    import numpy as np\n    from shapely.geometry import mapping\n    from rasterio import mask\n    import pandas as pd\n\n    if field is None:\n        raise ValueError('Please provide field name')\n    else:\n        ### Define input image\n        # input is raster\n        if isinstance(input, rasterio.DatasetReader):\n            input_image = input\n        # input is array\n        elif isinstance(input, np.ndarray):\n            if meta is None:\n                raise ValueError('It requires metadata of input')\n            else:\n                if not os.path.exists('./tmp/'):\n                    os.makedirs('./tmp/')\n                writeRaster(input, './tmp/tmp.tif', meta)\n                input_image = rast('./tmp/tmp.tif')\n        # Other input\n        else:\n            raise ValueError('Input data is not supported')\n\n        ########\n\n        ### Define nodata\n        if nodata is None:\n            dataType = input_image.meta['dtype']\n            if dataType.lower() == 'int8':\n                nodata_value = 127\n            elif dataType.lower() == 'uint8':\n                nodata_value = 255\n            elif dataType.lower() == 'int16':\n                nodata_value = 32767\n            elif dataType.lower() == 'uint16':\n                nodata_value = 65535\n            elif dataType.lower() == 'int32':\n                nodata_value = 2147483647\n            elif dataType.lower() == 'uint32':\n                nodata_value = 4294967295\n            elif dataType.lower() == 'float16':\n                nodata_value = 65500\n            elif dataType.lower() == 'float32':\n                nodata_value = 999999\n            else:\n                nodata_value = 0\n        else:\n            nodata_value = nodata   \n\n        # Convert shapefile to shapely geometry\n        geoms = roi.geometry.values\n\n        # Extract some metadata information\n        nbands = input_image.count\n        dtype_X = np.float32()\n        dtype_y = np.float32()\n\n        # Create empty array to contain X and y arrays\n        X = np.array([], dtype= dtype_X).reshape(0, nbands)\n        y = np.array([], dtype= dtype_y)\n\n        # Run loop over each features in shapefile to extract pixel values\n        for index, geom in enumerate(geoms):\n            poly = [mapping(geom)]\n\n            # Crop image based on feature\n            cropped, transform = mask.mask(input_image, poly, crop=True, nodata=nodata_value)\n\n            # Reshape dataset in form of (values, bands)\n            cropped_reshape = reshape_as_image(cropped)\n            reshapped = cropped_reshape.reshape(-1, nbands)\n\n            # Append 1D array y\n            y = np.append(y, [roi[field][index]] * reshapped.shape[0])\n\n            # vertical stack 2D array X\n            X = np.vstack((X, reshapped))\n\n        # Remove NAN value or not\n        if na_rm is True: \n            data = np.hstack((X, y.reshape(y.shape[0], 1)))\n            data_na = data[~np.isnan(data).any(axis=1)]\n            data_nodata = data_na[~(data_na == nodata_value).any(axis=1)]\n\n            X_na = data_nodata[ :, 0:nbands]\n            y_na = data_nodata[ : , nbands]\n\n            # return dataframe\n            if dataframe is True:\n                y_na_reshape = y_na.reshape(-1,1)\n\n                # class tail\n                if tail is True:\n                    arr = np.hstack([X_na, y_na_reshape])\n                else:\n                    arr = np.hstack([y_na_reshape, X_na])\n\n                # Name is not given\n                if names is None:\n                    if prefix is None:\n                        names_band = [f'B{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    else:\n                        names_band = [f'{prefix}{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n                # Name is given\n                else:\n                    if len(names) != (nbands + 1):\n                        raise ValueError('Length of name should be equal to number of bands plus 1')\n                    else:\n                        if prefix is None:\n                            names_list = names\n                        else:\n                            names_list = [f'{prefix}{name_i}' for name_i in names]\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n            # Do not return dataframe\n            else:\n                return X_na, y_na\n\n        # Do not remove NAN values\n        else: \n            # return dataframe\n            if dataframe is True:\n                y_reshape = y.reshape(-1,1)\n                arr = np.hstack([X, y_reshape])\n\n                # Name is not given\n                if names is None:\n                    if prefix is None:\n                        names_band = [f'B{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    else:\n                        names_band = [f'{prefix}{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n                # Name is given\n                else:\n                    if len(names) != (nbands + 1):\n                        raise ValueError('Length of name should be equal to number of bands plus 1')\n                    else:\n                        if prefix is None:\n                            names_list = names\n                        else:\n                            names_list = [f'{prefix}{name_i}' for name_i in names]\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n            else:\n                return X, y\n</code></pre>"},{"location":"raster/#geonate.raster.getBounds","title":"<code>getBounds(input, meta=None)</code>","text":"<p>Return boundary location (left, bottom, right, top) of raster image for cropping image in number list</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AnyStr</code> <p>Image or data array input </p> required <code>meta</code> <code>Dict</code> <p>Metadata is needed when input is data array. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>numeric</code> <p>A list of number show locations of left, bottom, right, top of the boundary</p> <p>Examples:</p> <p>img = raster.rast('./Sample_data/landsat_multi/Scene/landsat_img_00.tif') meta = img.meta ds = img.read() left, bottom, right, top = raster.getBounds(ds, meta)</p> Source code in <code>geonate/raster.py</code> <pre><code>def getBounds(input: AnyStr, meta: Optional[Dict]=None):\n    \"\"\"Return boundary location (left, bottom, right, top) of raster image for cropping image in number list\n\n    Args:\n        input (AnyStr): Image or data array input \n        meta (Dict, optional): Metadata is needed when input is data array. Defaults to None.\n\n    Returns:\n        numeric: A list of number show locations of left, bottom, right, top of the boundary\n\n    Example:\n        img = raster.rast('./Sample_data/landsat_multi/Scene/landsat_img_00.tif')\n        meta = img.meta\n        ds = img.read()\n        left, bottom, right, top = raster.getBounds(ds, meta)\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n\n    # Check input \n    if isinstance(input, rasterio.DatasetReader):\n        left, bottom, right, top = input.bounds\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            transform = meta['transform']\n            width = meta['width']\n            height = meta['height']\n            left, top = transform * (0, 0)\n            right, bottom = transform * (width, height)\n\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    return left, bottom, right, top\n</code></pre>"},{"location":"raster/#geonate.raster.layerstack","title":"<code>layerstack(input, output=None)</code>","text":"<p>Stack layers for different geotif images with the same extent and each image may have more than 1 band</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>List of input geotif files</p> required <code>output</code> <code>AnyStr</code> <p>Whether to write the stacked image or not. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.ndarray, metadata</code> <p>The function returns two variables of data array and corresponding metadata</p> Source code in <code>geonate/raster.py</code> <pre><code>def layerstack(input, output: Optional[AnyStr]=None):\n    \"\"\"Stack layers for different geotif images with the same extent and each image may have more than 1 band\n\n    Args:\n        input (list): List of input geotif files\n        output (AnyStr, optional): Whether to write the stacked image or not. Defaults to None.\n\n    Returns:\n        np.ndarray, metadata: The function returns two variables of data array and corresponding metadata\n\n    \"\"\"\n    import rasterio\n    from rasterio.plot import reshape_as_raster\n    import numpy as np\n\n    files2stack = []\n    stacked_array = []\n    nbands = len(input)\n\n    for file in input:\n        with rasterio.open(file) as src:\n            data = src.read(1)\n            meta = src.meta\n            files2stack.append(data)\n\n    stacked_array = np.stack(files2stack, axis=-1)\n    stacked = reshape_as_raster(stacked_array)\n    meta.update({'count': nbands,\n                            'driver': 'GTiff',\n                            'compress': 'lzw'})\n\n    # write out result \n    if output is not None:\n        writeRaster(stacked, output, meta)\n    else:\n        return stacked, meta\n</code></pre>"},{"location":"raster/#geonate.raster.mask","title":"<code>mask(input, reference, input_meta=None, reference_meta=None, invert=False, nodata=0, output=None)</code>","text":"<p>Mask raster opened by rasterio by shapefile vector or another image</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Image or data array input that need to crop</p> required <code>reference</code> <code>DatasetReader | GeoDataFrame | np.ndarray</code> <p>Region of interest, shapefile opened by geopandas or another image or data array to crop</p> required <code>input_meta</code> <code>Dict</code> <p>Metadata when input is data array. Defaults to None.</p> <code>None</code> <code>reference_meta</code> <code>Dict</code> <p>Metadata when reference is data array. Defaults to None.</p> <code>None</code> <code>invert</code> <code>bool</code> <p>If True, pixels inside shapefile will be masked. Defaults to False.</p> <code>False</code> <code>nodata</code> <code>int</code> <p>Any number to fill nodata pixels outside the ROI. Defaults to 0.</p> <code>0</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image </p> Source code in <code>geonate/raster.py</code> <pre><code>def mask(input, reference, input_meta: Optional[Dict]=None, reference_meta: Optional[Dict]=None, invert=False, nodata=0, output: Optional[AnyStr]=None):\n    \"\"\"Mask raster opened by rasterio by shapefile vector or another image\n\n    Args:\n        input (DatasetReader | np.ndarray): Image or data array input that need to crop\n        reference (DatasetReader | GeoDataFrame | np.ndarray): Region of interest, shapefile opened by geopandas or another image or data array to crop\n        input_meta (Dict, optional): Metadata when input is data array. Defaults to None.\n        reference_meta (Dict, optional): Metadata when reference is data array. Defaults to None.\n        invert (bool, optional): If True, pixels inside shapefile will be masked. Defaults to False.\n        nodata (int, optional): Any number to fill nodata pixels outside the ROI. Defaults to 0.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image \n\n    \"\"\"\n    import os\n    import rasterio\n    import shapely\n    from shapely.geometry import mapping\n    import geopandas as gpd\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            if not os.path.exists('./tmp/'):\n                os.makedirs('./tmp/')\n            writeRaster(input, './tmp/tmp.tif', input_meta)\n            input_image = raster.rast('./tmp/tmp.tif')\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Define boundary\n    if (isinstance(reference, gpd.GeoDataFrame)):\n        poly = reference\n        transform_poly = reference.transform\n        crs_poly = reference.crs\n    else:\n        if isinstance(reference, rasterio.DatasetReader):\n            ds_reference = reference.read(1)\n            transform_poly = reference.meta['transform']\n            crs_poly = reference.meta['crs']\n        elif isinstance(reference, np.ndarray):\n            ds_reference = reference[1, : , : ]\n            transform_poly = reference_meta['transform']\n            crs_poly = reference_meta['crs']\n        else:\n            raise ValueError('Data is not supported')\n\n        masked = np.where(np.isnan(ds_reference), np.nan, 1)\n        masked_convert = masked.astype(np.float32)\n\n        shp = rasterio.features.shapes(masked_convert, mask= ~np.isnan(masked_convert), transform= transform_poly)\n        poly = []\n        values = []\n\n        for shape, value in shp:\n            if value == 1:\n                poly.append(shapely.geometry.shape(shape))\n                values.append(value)\n\n        poly = gpd.GeoDataFrame({'geometry': poly, 'value': values})\n        poly.set_crs(crs_poly.to_string(), inplace=True)\n\n    ### Define nodata\n    if nodata is None:\n        dataType = input_image.meta['dtype']\n        if dataType.lower() == 'int8':\n            nodata_value = 127\n        elif dataType.lower() == 'uint8':\n            nodata_value = 255\n        elif dataType.lower() == 'int16':\n            nodata_value = 32767\n        elif dataType.lower() == 'uint16':\n            nodata_value = 65535\n        elif dataType.lower() == 'int32':\n            nodata_value = 2147483647\n        elif dataType.lower() == 'uint32':\n            nodata_value == 4294967295\n        elif dataType.lower() == 'float16':\n            nodata_value = 65500\n        elif dataType.lower() == 'float32':\n            nodata_value == 999999\n        else:\n            nodata_value == 0\n    else:\n        nodata_value = nodata        \n\n    ### Invert mask\n    if invert is True:\n        masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, invert=True, nodata=nodata_value)\n    else:\n        masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, nodata= nodata_value)\n\n    meta  = input_image.meta\n    meta.update({\n        'height': masked_img.shape[1],\n        'width': masked_img.shape[2],\n        'transform': geotranform,\n        'dtype': np.float32,\n        'nodata': nodata_value})\n\n    # Write output\n    if output is not None:\n        writeRaster(masked_img, output, meta)\n    else:\n        return masked_img, meta\n</code></pre>"},{"location":"raster/#geonate.raster.match","title":"<code>match(input, reference, method='near', input_meta=None, reference_meta=None)</code>","text":"<p>Match input image to the reference image in terms of projection, resolution, and bound extent. It returns image within the bigger boundary.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio objective or data array needs to match </p> required <code>reference</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio object or data array taken as reference to match the input image</p> required <code>method</code> <code>AnyStr</code> <p>String defines resampling method (if applicable) to resample if having different resolution (Method similar to resample). Defaults to 'near'.</p> <code>'near'</code> <code>input_meta</code> <code>Dict</code> <p>Metadata of input required when input is data array. Defaults to None.</p> <code>None</code> <code>reference_meta</code> <code>Dict</code> <p>Metadata of reference required when reference is data array. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def match(input, reference, method: AnyStr='near', input_meta: Optional[Dict]=None, reference_meta: Optional[Dict]=None):\n    \"\"\"Match input image to the reference image in terms of projection, resolution, and bound extent. It returns image within the bigger boundary.\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio objective or data array needs to match \n        reference (DatasetReader | np.ndarray): Rasterio object or data array taken as reference to match the input image\n        method (AnyStr, optional): String defines resampling method (if applicable) to resample if having different resolution (Method similar to resample). Defaults to 'near'.\n        input_meta (Dict, optional): Metadata of input required when input is data array. Defaults to None.\n        reference_meta (Dict, optional): Metadata of reference required when reference is data array. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    from rasterio.transform import from_bounds\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            input_image = input\n            meta = input_meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Define reference image\n    if isinstance(reference, rasterio.DatasetReader):\n        reference_image = reference.read()\n        meta_reference = reference.meta\n    # input is array\n    elif isinstance(reference, np.ndarray):\n        if reference_meta is None:\n            raise ValueError('It requires metadata of reference')\n        else:\n            reference_image = reference\n            meta_reference = reference_meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Check some conditions\n    if meta[\"crs\"] != meta_reference['crs']:\n        print('Input and reference images have different Projection')\n        print('Output projection will take the reference projection')\n    if meta['transform'][0] != meta_reference['transform'][0]:\n        print('Input and reference images have different resolution')\n        print('Ouput resolution will take the reference resolution')     \n\n    # get general extent from two images\n    ext_input = getBounds(input_image, meta)\n    ext_reference = getBounds(reference_image, meta_reference)\n\n    ext = ext_input\n    ext = (\n        min(ext[0], ext_reference[0]),\n        min(ext[1], ext_reference[1]),\n        max(ext[2], ext_reference[2]),\n        max(ext[3], ext_reference[3])\n        )\n\n    # calculate new height and width\n    resolution = meta_reference['transform'][0]    \n    width_new = int((ext[2]  - ext[0]) / resolution)\n    height_new = int((ext[3] - ext[1]) / resolution)\n\n    # calculate new transform\n    transform_new = from_bounds(ext[0], ext[1], ext[2], ext[3], width_new, height_new)\n\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # Reproject to match\n    if len(input_image.shape) &gt; 2:\n        nbands = input_image.shape[0]\n    else:\n        nbands = 1\n\n    matched = np.empty((nbands, height_new, width_new), dtype=np.float32)\n    for band in range(0, nbands):\n        if nbands &lt;= 1:\n            ds = input_image\n        else:\n            ds = input_image[band, : , : ]\n        warp.reproject(source=ds, destination=matched[band, :, :], src_transform= meta['transform'], dst_transform= transform_new, src_crs=meta['crs'], dst_crs=meta_reference['crs'], resampling= resampleAlg)\n\n    # match out other values\n    match_masked = np.where(matched == 0, np.nan, matched)\n    match_masked = match_masked.astype(np.float32)\n\n    # update metadata\n    meta_update = meta.copy()\n    meta_update.update({\n        'crs': meta_reference['crs'],\n        'transform': transform_new,\n        'width': width_new,\n        'height': height_new,\n        'dtype': np.float32\n    })\n\n    return match_masked, meta_update\n</code></pre>"},{"location":"raster/#geonate.raster.merge","title":"<code>merge(input, output=None, compress='lzw')</code>","text":"<p>Merge multiple geotif file using Rasterio (pixels at overlapping areas receive average values)</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>List</code> <p>List of input geotif files</p> required <code>output</code> <code>AnyStr</code> <p>Path of output geotif file to write out the merged image. If image is not written out, it will be assigned to local variables. Defaults to None.</p> <code>None</code> <code>compress</code> <code>AnyStr</code> <p>Compress options ['deflate', 'lzw']. Defaults to 'lzw'.</p> <code>'lzw'</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>ndarray contains image values dict: dict contains metadata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def merge(input: AnyStr, output: Optional[AnyStr]=None, compress: Optional[AnyStr]='lzw'):\n    \"\"\"Merge multiple geotif file using Rasterio (pixels at overlapping areas receive average values)\n\n    Args:\n        input (List): List of input geotif files\n        output (AnyStr, optional): Path of output geotif file to write out the merged image. If image is not written out, it will be assigned to local variables. Defaults to None.\n        compress (AnyStr, optional): Compress options ['deflate', 'lzw']. Defaults to 'lzw'.\n\n    Returns:\n        np.ndarray: ndarray contains image values\n        dict: dict contains metadata of the image\n\n    \"\"\"\n    import rasterio\n    from rasterio import merge \n\n    src_files = []\n    for file in input:\n        ds = rasterio.open(file)\n        src_files.append(ds)\n\n    fun_sum = merge.copy_sum\n    fun_count = merge.copy_count\n\n    # calculate average values\n    mosaic_sum, out_trans = merge.merge(src_files, method=fun_sum)\n    mosaic_count, out_trans = merge.merge(src_files, method=fun_count)\n    mosaic_avg = mosaic_sum / mosaic_count\n\n    meta = src_files[0].meta.copy()\n    meta.update({\"driver\": \"GTiff\",\n                            \"height\": mosaic_avg.shape[1],\n                            \"width\": mosaic_avg.shape[2],\n                            \"transform\": out_trans,\n                            \"compress\": compress})\n\n    # write out result \n    if output is not None:\n        with rasterio.open(output, \"w\", **meta) as dest:\n            dest.write(mosaic_avg)\n        print(f\"Finished merge raster files, the output is at {output}\")\n    # keep local\n    else:\n        return mosaic_avg, meta      \n</code></pre>"},{"location":"raster/#geonate.raster.mergeVRT","title":"<code>mergeVRT(input, output, compress=True, silent=True)</code>","text":"<p>Merge multiple geotif files using gdal VRT for better performance speed</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>List of input geotif files</p> required <code>output</code> <code>AnyStr</code> <p>Path of output tif file</p> required <code>compress</code> <code>bool</code> <p>Whether compress the output data or not. Defaults to True.</p> <code>True</code> <code>silent</code> <code>bool</code> <p>Show or do not show file processing log. Defaults to True.</p> <code>True</code> Source code in <code>geonate/raster.py</code> <pre><code>def mergeVRT(input: AnyStr, output: AnyStr, compress: bool=True, silent=True):\n    \"\"\"Merge multiple geotif files using gdal VRT for better performance speed\n\n    Args:\n        input (list): List of input geotif files\n        output (AnyStr): Path of output tif file\n        compress (bool, optional): Whether compress the output data or not. Defaults to True.\n        silent (bool, optional): Show or do not show file processing log. Defaults to True.\n\n    \"\"\"\n    import os\n    from osgeo import gdal\n    #  Create a temp vrt file\n    vrt_file = 'merged.vrt'\n\n    if compress is True:\n        vrt_options = gdal.BuildVRTOptions()\n        gdal.BuildVRT(vrt_file, input, options=vrt_options)\n        gdal.Translate(output, vrt_file, format='GTiff', creationOptions=['COMPRESS=LZW'])\n\n    else:\n        gdal.BuildVRT(vrt_file, input)\n        gdal.Translate(output, vrt_file)\n\n    os.remove(vrt_file)\n    if silent is True:\n        pass\n    else:\n        print(f\"Finished merge raster files, the output is at {output}\")\n</code></pre>"},{"location":"raster/#geonate.raster.normalized","title":"<code>normalized(input, meta=None, output=None)</code>","text":"<p>Normalize raster data to rearrange raster values from 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>meta</code> <code>AnyStr</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def normalized(input, meta: Optional[AnyStr]=None, output: Optional[AnyStr]=None):\n    \"\"\"Normalize raster data to rearrange raster values from 0 to 1\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        meta (AnyStr, optional): Metadata in case input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Please provide input metadata')\n        else:\n            dataset = input\n            meta = meta\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Find max min values\n    maxValue = np.nanmax(dataset)\n    minValue = np.nanmin(dataset)\n\n    ### Create empty data array to store output\n    normalized = np.zeros_like(dataset, dtype=np.float32)\n\n    ### Run normalization\n    for i in range(0, dataset.shape[0]):\n        band = dataset[i, : , : ]\n        band_norm = (band.astype(float)  - minValue) / (maxValue  - minValue)\n        normalized[i, : , : ] = band_norm\n        band_norm = None\n\n    ### update meta\n    meta.update({'dtype': np.float32})\n\n    ### return result \n    # Write output\n    if output is not None:\n        writeRaster(normalized, output, meta)\n    else:\n        return normalized, meta\n</code></pre>"},{"location":"raster/#geonate.raster.normalizedDifference","title":"<code>normalizedDifference(input, band1, band2, meta=None, output=None)</code>","text":"<p>Calculate normalized difference index</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio object or data array, input with multiple bands.</p> required <code>band1</code> <code>numeric</code> <p>Order of the first band in the input.</p> required <code>band2</code> <code>numeric</code> <p>Order of the second band in the input.</p> required <code>meta</code> <code>Dict</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def normalizedDifference(input, band1, band2, meta: Optional[Dict]=None, output: Optional[AnyStr]=None):\n    \"\"\"Calculate normalized difference index\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio object or data array, input with multiple bands.\n        band1 (numeric): Order of the first band in the input.\n        band2 (numeric): Order of the second band in the input.\n        meta (Dict, optional): Metadata in case input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            dataset = input\n            meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Extract data\n    ds_band1 = dataset[band1+1, : , : ]\n    ds_band2 = dataset[band2+1, : , : ]\n\n    # calculate index\n    normalized_index  = (ds_band1.astype(float) - ds_band2.astype(float)) / (ds_band1 + ds_band2)\n    normalized_index = normalized_index.astype(np.float32)\n    # remove outliers\n    normalized_index[(normalized_index &lt; -1) | (normalized_index &gt; 1)] = np.nan\n\n    meta.update({'dtype': np.float32})\n\n    # Write output\n    if output is not None:\n        writeRaster(normalized_index, output, meta)\n    else:\n        return normalized_index, meta\n</code></pre>"},{"location":"raster/#geonate.raster.rast","title":"<code>rast(input, show_meta=False, **kwargs)</code>","text":"<p>Open a single geotif raster file using Rasterio</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AnyStr</code> <p>The file path indicates location of geotif file</p> required <code>show_meta</code> <code>bool</code> <p>Whether to show the image metadata. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>optional</code> <p>All parameters in rasterio.open()</p> <code>{}</code> <p>Returns:</p> Type Description <code>Object</code> <p>Rasterio RasterReader object</p> Source code in <code>geonate/raster.py</code> <pre><code>def rast(input: AnyStr, show_meta: Optional[bool]=False, **kwargs):\n    \"\"\"Open a single geotif raster file using Rasterio\n\n    Args:\n        input (AnyStr): The file path indicates location of geotif file\n        show_meta (bool, optional): Whether to show the image metadata. Defaults to False.\n        **kwargs (optional): All parameters in rasterio.open()\n\n    Returns:\n        Object: Rasterio RasterReader object\n\n    \"\"\"    \n    import rasterio\n    import os\n\n    img = rasterio.open(input, **kwargs)\n    basename = os.path.basename(input)\n\n    # show meta \n    if show_meta is True:\n        meta = img.meta\n        print(f\"Opening: {basename}\\n{meta}\")\n\n    return img    \n</code></pre>"},{"location":"raster/#geonate.raster.reclassify","title":"<code>reclassify(input, breakpoints, classes, meta=None, output=None)</code>","text":"<p>Reclassify image with discrete or continuous values</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Raster or data array input</p> required <code>breakpoints</code> <code>list</code> <p>Number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]</p> required <code>classes</code> <code>list</code> <p>Number list, define classes, number of classes equal number of breakpoints minus 1</p> required <code>meta</code> <code>Dict</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def reclassify(input, breakpoints, classes, meta: Optional[Dict]=None, output: Optional[AnyStr]=None):\n    \"\"\"Reclassify image with discrete or continuous values\n\n    Args:\n        input (DatasetReader | np.ndarray): Raster or data array input\n        breakpoints (list): Number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]\n        classes (list): Number list, define classes, number of classes equal number of breakpoints minus 1\n        meta (Dict, optional): Metadata in case input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n\n    ### Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        if len(input.shape) == 2:\n            dataset = input.read()\n            meta = input.meta\n        elif len(input.shape) == 3:\n            if  input.shape[0] &gt; 1:\n                raise ValueError('Input data has more than one band')\n            else:\n                dataset = input.read(1)\n                meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            if (len(input.shape)) &gt; 2 and (input.shape[0] &gt; 1):\n                raise ValueError('Input data has more than one band')\n            else:\n                dataset = input\n                meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ####\n    # Create unique values and empty data array to store reclassified result \n    uniques = np.unique(dataset)\n    reclassified = np.zeros_like(dataset)\n\n    ####\n    # If image has discrete values\n    if len(uniques) == len(classes): \n        if len(breakpoints) == len(classes):\n            for i in range(len(classes)):\n                reclassified[dataset == breakpoints[i]] = classes[i]\n        elif len(breakpoints) == (len(classes)-1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n    # If image has continuous values\n    else:\n        if len(breakpoints) == (len(classes)+1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n\n    # Write output\n    if output is not None:\n        writeRaster(reclassified, output, meta)\n    else:\n        return reclassified, meta\n</code></pre>"},{"location":"raster/#geonate.raster.reproject","title":"<code>reproject(input, reference=None, method='near', input_meta=None, res=None, output=None)</code>","text":"<p>Reproject raster data to a new projection and resample (if required)</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Input rasterio image or data array</p> required <code>reference</code> <code>AnyStr</code> <p>Reference data of even another image or 'crs' string, e.g., 'EPSG:4326'. Defaults to None.</p> <code>None</code> <code>method</code> <code>AnyStr</code> <p>Resampling method (if changing resolution), optional, default method is 'nearest neighbor', other methods are at rasterio.Resampling. (e.g., nearest, cubic, bilinear, average). Defaults to 'near'.</p> <code>'near'</code> <code>input_meta</code> <code>Dict</code> <p>Required when input is data array. Defaults to None.</p> <code>None</code> <code>res</code> <code>float</code> <p>Resolution of the output in degree or meters depends on the output crs. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image </p> Source code in <code>geonate/raster.py</code> <pre><code>def reproject(input, reference:Optional[AnyStr]=None, method: Optional[AnyStr]='near', input_meta: Optional[Dict]=None, res: Optional[float]=None, output: Optional[AnyStr]=None):\n    \"\"\"Reproject raster data to a new projection and resample (if required)\n\n    Args:\n        input (DatasetReader | np.ndarray): Input rasterio image or data array\n        reference (AnyStr, optional): Reference data of even another image or 'crs' string, e.g., 'EPSG:4326'. Defaults to None.\n        method (AnyStr, optional): Resampling method (if changing resolution), optional, default method is 'nearest neighbor', other methods are at rasterio.Resampling. (e.g., nearest, cubic, bilinear, average). Defaults to 'near'.\n        input_meta (Dict, optional): Required when input is data array. Defaults to None.\n        res (float, optional): Resolution of the output in degree or meters depends on the output crs. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image \n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input.read()\n        meta = input.meta\n        # define boundary of input image\n        left, bottom, right, top = input.bounds\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            input_image = input\n            meta = input_meta\n            left, bottom = meta['transform'] * (0, 0)\n            # define boundary of input image\n            right, top = meta['transform']* (meta['width'], meta['height'])\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # If reference is not given, it will take the CRS from input\n    # the function now used for resampling\n    if reference is None:\n        dst_crs = meta['crs']\n        if res is None:\n            xsize, ysize = xsize, ysize = meta['transform'][0], meta['transform'][0]\n        else:\n            xsize, ysize = res, res\n        transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n\n    else:\n        # string of EPSG\n        if isinstance(reference, str):\n            dst_crs = reference\n            if res is None:\n                raise ValueError('Please provide output resolution')\n            else:\n                xsize, ysize = res, res\n            transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n\n        # Take all paras from reference image\n        elif isinstance(reference, rasterio.DatasetReader):\n            dst_crs = reference.crs\n            if res is None:\n                xsize, ysize = reference.res\n            else:\n                xsize, ysize = res, res\n            transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n        else:\n            raise ValueError('Please define correct reference, it is CRS string or an image')\n\n    # Update metadata\n    meta_update = meta.copy()\n    meta_update.update({\n        'crs': dst_crs,\n        'transform': transform,\n        'width': width,\n        'height': height,\n    })\n\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # Running project \n    projected = np.empty((input_image.shape[0], height, width), dtype= meta['dtype'])\n    for band in range(0, input_image.shape[0]):\n        ds = input_image[band, : , : ]\n        warp.reproject(source=ds, destination=projected[(band), :, :], src_transform= meta['transform'], dst_transform=transform, src_crs=meta['crs'], dst_crs=dst_crs, resampling= resampleAlg)\n\n    # Write output\n    if output is not None:\n        writeRaster(projected, output, meta_update)\n    else:\n        return projected, meta_update\n</code></pre>"},{"location":"raster/#geonate.raster.resample","title":"<code>resample(input, factor, resample, method='near', meta=None, output=None)</code>","text":"<p>Resample raster image based on factor (not the target resolution)</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Input rasterio image or data array</p> required <code>factor</code> <code>numeric</code> <p>Resampling factor compare to origin image (e.g., 2, 4, 6)</p> required <code>resample</code> <code>AnyStr</code> <p>Resample method [\"aggregate\", \"disaggregate\"]</p> required <code>method</code> <code>str</code> <p>Resampling method (if changing resolution), optional, default method is 'nearest neighbor', other methods are at rasterio.Resampling. (e.g., nearest, cubic, bilinear, average). Defaults to 'near'.</p> <code>'near'</code> <code>meta</code> <code>Dict</code> <p>Required metadata when input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def resample(input, factor, resample: AnyStr, method='near', meta: Optional[Dict]=None, output: Optional[AnyStr]=None):\n    \"\"\"Resample raster image based on factor (not the target resolution)\n\n    Args:\n        input (DatasetReader | np.ndarray): Input rasterio image or data array\n        factor (numeric): Resampling factor compare to origin image (e.g., 2, 4, 6)\n        resample (AnyStr): Resample method [\"aggregate\", \"disaggregate\"]\n        method (str, optional): Resampling method (if changing resolution), optional, default method is 'nearest neighbor', other methods are at rasterio.Resampling. (e.g., nearest, cubic, bilinear, average). Defaults to 'near'.\n        meta (Dict, optional): Required metadata when input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n        left, bottom, right, top = input.bounds\n        nbands = input.count\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            dataset = input\n            meta = meta\n            left, bottom, right, top = getBounds(dataset, meta)\n            if len(dataset.shape) &gt; 2:\n                nbands = dataset.shape[0]\n            else:\n                nbands = 1\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    #### Calculate new rows and columns\n    if (resample.lower() == 'aggregate') or (resample.lower() == 'agg') or (resample.lower() == 'a'):\n        new_height = meta['height'] // factor\n        new_width = meta['width'] // factor\n    elif (resample.lower() == 'disaggregate') or (resample.lower() == 'disagg') or (resample.lower() == 'd'):\n        new_height = meta['height'] * factor\n        new_width = meta['width'] * factor\n    else:\n        raise ValueError('Resample method is not supported [\"aggregate\", \"disaggregate\"]')\n\n    transform_new, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=meta['crs'], width=new_width, height=new_height, left=left, bottom=bottom, right=right, top=top)\n\n# Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # Define the metadata for the destination raster\n    metadata = meta.copy()\n    metadata.update({\n        'transform': transform_new,\n        'width': new_width,\n        'height': new_height, \n        'dtype': np.float32\n    })\n\n    resampled = np.empty((nbands, new_height, new_width), dtype=np.float32)\n    for band in range(0, nbands):\n        if nbands &lt;= 1:\n            ds = dataset\n        else:\n            ds = dataset[band, : , : ]\n        warp.reproject(source=ds, destination=resampled[band, :, :], src_transform= meta['transform'], dst_transform= transform_new, src_crs=meta['crs'], dst_crs=input.crs, resampling= resampleAlg)\n\n    # Write output\n    if output is not None:\n        writeRaster(resampled, output, metadata)\n    else:\n        return resampled, metadata\n</code></pre>"},{"location":"raster/#geonate.raster.values","title":"<code>values(input, meta=None, na_rm=True, names=None, prefix=None)</code>","text":"<p>Extract all pixel values of image and create dataframe from them, each band is a column</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array.</p> required <code>meta</code> <code>AnyStr</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>na_rm</code> <code>bool</code> <p>Remove or do not remove NA value from output dataframe. Defaults to True.</p> <code>True</code> <code>names</code> <code>list</code> <p>Given expected names for each column in the dataframe, if not, default name will be assigned. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>AnyStr</code> <p>Given character before each band name. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe stores all pixel values across all image bands.</p> Source code in <code>geonate/raster.py</code> <pre><code>def values(input, meta: Optional[AnyStr]=None, na_rm: Optional[bool]=True, names: Optional[list]=None, prefix: Optional[AnyStr]=None):\n    \"\"\"Extract all pixel values of image and create dataframe from them, each band is a column\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array.\n        meta (AnyStr, optional): Metadata in case input is data array. Defaults to None.\n        na_rm (bool, optional): Remove or do not remove NA value from output dataframe. Defaults to True.\n        names (list, optional): Given expected names for each column in the dataframe, if not, default name will be assigned. Defaults to None.\n        prefix (AnyStr, optional): Given character before each band name. Defaults to None.\n\n    Returns:\n        DataFrame: Dataframe stores all pixel values across all image bands.\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            dataset = input\n            meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ########\n    nbands = dataset.shape[0]\n    bands_array = [dataset[band, : , : ].flatten() for band in range(0, nbands)]\n\n    if names is not None:\n        if len(names) != nbands:\n            raise ValueError('Length of name should be equal to number of bands')\n        else:\n            if prefix is None:\n                data = pd.DataFrame(np.array(bands_array).T, columns=names)\n            else:\n                names_new = [f'{prefix}{name}' for name in names]\n                data = pd.DataFrame(np.array(bands_array).T, columns=names_new)\n    else:\n        if prefix is None:\n            data = pd.DataFrame(np.array(bands_array).T, columns=[f'B{i}' for i in range(1,nbands +1)])\n        else:\n            data = pd.DataFrame(np.array(bands_array).T, columns=[f'{prefix}{i}' for i in range(1, nbands +1)])\n\n    ####### \n    # Remove NA values or not\n    if na_rm is True: \n        data_out = data.dropna().reset_index(drop=True)\n    else:\n        data_out = data\n\n    return data_out\n</code></pre>"},{"location":"raster/#geonate.raster.vect","title":"<code>vect(input, show_meta=False, **kwargs)</code>","text":"<p>Read shapefile vector file using Geopandas </p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AnyStr</code> <p>The file path indicates location of shapefile </p> required <code>show_meta</code> <code>bool</code> <p>Whether to show the image metadata. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>optional</code> <p>All parameters in gpd.read_file()</p> <code>{}</code> <p>Returns:</p> Type Description <code>geodataframe</code> <p>Geodataframe of shapefile with attributes from geopandas object</p> Source code in <code>geonate/raster.py</code> <pre><code>def vect(input: AnyStr, show_meta: Optional[bool]=False, **kwargs):\n    \"\"\"Read shapefile vector file using Geopandas \n\n    Args:\n        input (AnyStr): The file path indicates location of shapefile \n        show_meta (bool, optional): Whether to show the image metadata. Defaults to False.\n        **kwargs (optional): All parameters in gpd.read_file()\n\n    Returns:\n        geodataframe: Geodataframe of shapefile with attributes from geopandas object\n\n    \"\"\"\n    import geopandas as gpd\n    import os\n\n    vect = gpd.read_file(input, **kwargs)\n\n    # show meta \n    if show_meta is True:\n        basename = os.path.basename(input)\n        crs = vect.crs\n        datashape = vect.shape\n        print(f\"Opening: {basename}\\n Projection (crs): {crs}\\n Data shape: {datashape}\")\n\n    return vect\n</code></pre>"},{"location":"raster/#geonate.raster.writeRaster","title":"<code>writeRaster(input, output, meta=None, compress='lzw')</code>","text":"<p>Write raster Geotif from data Array using Rasterio</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>rasterio.DatasetReader | np.ndarray</code> <p>Data array in form of [band, height, width]</p> required <code>output</code> <code>AnyStr</code> <p>Output file path</p> required <code>meta</code> <code>Dict</code> <p>Rasterio profile settings needed when input is dataArray. Defaults to None.</p> <code>None</code> <code>compress</code> <code>AnyStr</code> <p>Compression algorithm ['lzw', 'deflate']. Defaults to 'lzw'.</p> <code>'lzw'</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any local variable. It writes raster file to local drive.</p> Source code in <code>geonate/raster.py</code> <pre><code>def writeRaster(input, output, meta: Optional[Dict]=None, compress: Optional[AnyStr] = 'lzw'):\n    \"\"\"Write raster Geotif from data Array using Rasterio\n\n    Args:\n        input (rasterio.DatasetReader | np.ndarray): Data array in form of [band, height, width]\n        output (AnyStr): Output file path\n        meta (Dict, optional): Rasterio profile settings needed when input is dataArray. Defaults to None.\n        compress (AnyStr, optional): Compression algorithm ['lzw', 'deflate']. Defaults to 'lzw'.\n\n    Returns:\n        None: The function does not return any local variable. It writes raster file to local drive.\n\n    \"\"\"   \n    import rasterio\n    import numpy as np\n\n    class RasterWriteError(Exception):\n        pass\n\n    # Input is rasterio image\n    if isinstance(input, rasterio.DatasetReader):\n        meta_out = input.meta\n        data_array = input.read()\n\n        # compress data or not\n        if compress is None:\n            meta_out = meta_out\n        else:\n            if compress.lower() == 'deflate':\n                meta_out.update({'compress': 'deflate'})\n            elif compress.lower() == 'lzw':\n                meta_out.update({'compress': 'lzw'})\n            else:\n                raise ValueError('Compress method is not supported')\n\n        # output has single band\n        if len(data_array.shape) == 2:\n            meta_out['count'] = int(1)\n            with rasterio.open(output, 'w', **meta_out) as dst:\n                for band in range(0, 1):\n                    data = data_array\n                    dst.write(data, band + 1)\n        # output has multi bands\n        else:\n            meta_out['count'] = int(data_array.shape[0])\n            with rasterio.open(output, 'w', **meta_out) as dst:\n                for band in range(0, int(data_array.shape[0])):\n                    data = data_array[band, : , : ]\n                    dst.write(data, band + 1)\n\n    # input is data array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Input is dataArray, please give metadata profile')\n        else:        \n        # compress data or not\n            if compress is None:\n                meta = meta\n            else:\n                if compress.lower() == 'deflate':\n                    meta.update({'compress': 'deflate'})\n                elif compress.lower() == 'lzw':\n                    meta.update({'compress': 'lzw'})\n                else:\n                    raise ValueError('Compress method is not supported')\n\n            # output has single band\n            if len(input.shape) == 2:\n                meta['count'] = int(1)\n                with rasterio.open(output, 'w', **meta) as dst:\n                    for band in range(0, 1):\n                        data = input\n                        dst.write(data, band + 1)\n            # output has multi bands\n            else:\n                meta['count'] = int(input.shape[0])\n                with rasterio.open(output, 'w', **meta) as dst:\n                    for band in range(0, int(input.shape[0])):\n                        data = input[band, : , : ]\n                        dst.write(data, band + 1)\n    else:\n        raise ValueError('Input data is not supported')    \n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geonate in a project:</p> <pre><code>import geonate\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>from geonate import common, raster\n</pre> from geonate import common, raster"}]}