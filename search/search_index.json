{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geonate","text":"<p>Python package synthesizes conventional tools and codes for image processing</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://canng.github.io/geonate</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <p>New Features:</p>"},{"location":"classification/","title":"classification module","text":"<p>Main module.</p>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geonate.common.array2raster","title":"<code>array2raster(array, meta)</code>","text":"<p>Convert a numpy array and metadata to a rasterio object stored in memory.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>array</code> <p>The input data array.</p> required <code>meta</code> <code>Dict</code> <p>The metadata dictionary.</p> required <p>Returns:</p> Type Description <code>Local raster file (raster)</code> <p>The rasterio object stored in memory.</p> Source code in <code>geonate/common.py</code> <pre><code>def array2raster(array, meta: Dict):\n    \"\"\"\n    Convert a numpy array and metadata to a rasterio object stored in memory.\n\n    Args:\n        array (array): The input data array.\n        meta (Dict): The metadata dictionary.\n\n    Returns:\n        Local raster file (raster): The rasterio object stored in memory.\n\n    \"\"\"\n    from rasterio.io import MemoryFile\n\n     # Determine number of bands\n    if len(array.shape) == 3:\n        nbands = array.shape[0]\n    else:\n        nbands = 1\n\n    # Update metadata with the correct dtype and count\n    meta.update({\n        'dtype': array.dtype,\n        'count': nbands\n    })\n\n    # Write image in memory file and read it back\n    with MemoryFile() as memfile:\n        with memfile.open(**meta) as dataset:\n            dataset.write(array, 1 if array.ndim == 2 else None)\n        return memfile.open()\n</code></pre>"},{"location":"common/#geonate.common.center_scene","title":"<code>center_scene(input)</code>","text":"<p>Computes the center latitude and longitude of a given geospatial input.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | shapefile</code> <p>A geospatial object with a 'bounds' attribute that defines the spatial extent.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - center_lat (float): The center latitude of the input.     - center_lon (float): The center longitude of the input.</p> Source code in <code>geonate/common.py</code> <pre><code>def center_scene(input):\n    \"\"\"\n    Computes the center latitude and longitude of a given geospatial input.\n\n    Args:\n        input (raster | shapefile): A geospatial object with a 'bounds' attribute that defines the spatial extent.\n\n    Returns:\n        tuple: A tuple containing:\n            - center_lat (float): The center latitude of the input.\n            - center_lon (float): The center longitude of the input.\n\n    \"\"\"\n    import rasterio\n    import geopandas\n\n    # Define boundary \n    bounds, _ = get_extent_local(input)\n    min_lon, min_lat, max_lon, max_lat = bounds[0], bounds[1], bounds[2], bounds[3]\n\n    # Compute center latitude and longitude\n    center_lat = (min_lat + max_lat) / 2\n    center_lon = (min_lon + max_lon) / 2\n\n    return center_lat, center_lon\n</code></pre>"},{"location":"common/#geonate.common.check_crs_consistency","title":"<code>check_crs_consistency(input)</code>","text":"<p>Checks if all elements in the input list have the same Coordinate Reference System (CRS).</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>A list of file paths or local variables (rasterio.io.DatasetReader or geopandas.geodataframe.GeoDataFrame).</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - bool: True if all elements have the same CRS, False otherwise.     - str or None: The CRS of the elements if all elements have the same CRS, otherwise None.</p> Source code in <code>geonate/common.py</code> <pre><code>def check_crs_consistency(input):\n    \"\"\"\n    Checks if all elements in the input list have the same Coordinate Reference System (CRS).\n\n    Args:\n        input (list): A list of file paths or local variables (rasterio.io.DatasetReader or geopandas.geodataframe.GeoDataFrame).\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if all elements have the same CRS, False otherwise.\n            - str or None: The CRS of the elements if all elements have the same CRS, otherwise None.\n\n    \"\"\"\n    import numpy\n    from .raster import rast, vect\n\n    if not isinstance(input, list):\n        raise ValueError('Input must be a list of local variables or file paths')\n\n    else:\n        _, inputType = check_datatype_consistency(input)\n\n        if str(inputType) == \"&lt;class 'str'&gt;\":\n            file_extensions  = [x.split(\".\")[-1] for x in input]\n            file_extension = numpy.unique(file_extensions)\n            extension_len = len(file_extension)\n\n            if extension_len &gt; 1:\n                raise ValueError('Input must have consistent data format')\n\n            else:\n                if str(file_extension[0]) == 'tif':\n                    files = [rast(file) for file in input]\n                    crs_list = [x.crs.to_string() for x in files]\n\n                    if len(numpy.unique(crs_list)) == 1:\n                        crs = numpy.unique(crs_list)\n                        consistency = True\n                        print(f\"Input is Raster with consistent crs of {crs}\")\n                        return consistency, crs[0]\n\n                    else:\n                        consistency = False\n                        print(f\"Input is Raster with different crs\")\n                        return consistency, None\n\n                elif str(file_extension[0]) == 'shp':\n                    files = [vect(file) for file in input]\n                    crs_list = [file.crs.to_string() for file in files]\n                    if len(numpy.unique(crs_list)) == 1:\n                        crs = numpy.unique(crs_list)\n                        consistency = True\n                        print(f\"Input is Shapefile with consistent crs of {crs}\")\n                        return consistency, crs[0]\n\n                    else:\n                        consistency = False\n                        print(f\"Input is Raster with different crs\")\n                        return consistency, None\n\n                else:\n                    raise ValueError('This function only supports raster (.tif) and shapefile (.shp)')\n\n        elif str(inputType) == \"&lt;class 'rasterio.io.DatasetReader'&gt;\" or str(inputType) == \"&lt;class 'geopandas.geodataframe.GeoDataFrame'&gt;\":\n            crs_list = [x.crs.to_string() for x in input]\n            crs = numpy.unique(crs_list)\n            consistency = True\n            print(f\"Input is Shapefile with consistent crs of {crs}\")\n            return consistency, crs[0]\n\n        else:\n            raise ValueError(f\"Input must have the same data format of raster (.tif) and shapefile (.shp)\")\n</code></pre>"},{"location":"common/#geonate.common.check_datatype_consistency","title":"<code>check_datatype_consistency(input)</code>","text":"<p>Checks if all elements in the input list have the same data type.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>A list of elements to check.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - bool: True if all elements have the same type, False otherwise.     - type or None: The data type of the elements if all elements have the same type, otherwise None.</p> Source code in <code>geonate/common.py</code> <pre><code>def check_datatype_consistency(input):\n    \"\"\"\n    Checks if all elements in the input list have the same data type.\n\n    Args:\n        input (list): A list of elements to check.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if all elements have the same type, False otherwise.\n            - type or None: The data type of the elements if all elements have the same type, otherwise None.\n\n    \"\"\"\n    if not isinstance(input, list):\n        raise ValueError(\"Input must be a list\")\n    else:\n        first_element = type(input[0])\n        if all(isinstance(item, first_element) for item in input):\n            datatype = first_element\n            consistency = True\n            print(f\"Input have data types of {datatype}\")\n        else:\n            datatype = None\n            consistency = False\n            print(f\"Input have different data types\")\n\n        return consistency, str(datatype)\n</code></pre>"},{"location":"common/#geonate.common.check_extension_consistency","title":"<code>check_extension_consistency(input)</code>","text":"<p>Checks if all elements in the input list have the same file extension.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>A list of file paths as strings.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - bool: True if all elements have the same file extension, False otherwise.     - str or None: The file extension if all elements have the same extension, otherwise None.</p> Source code in <code>geonate/common.py</code> <pre><code>def check_extension_consistency(input):\n    \"\"\"\n    Checks if all elements in the input list have the same file extension.\n\n    Args:\n        input (list): A list of file paths as strings.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if all elements have the same file extension, False otherwise.\n            - str or None: The file extension if all elements have the same extension, otherwise None.\n\n    \"\"\"\n    import numpy\n\n    # Check whether a list or not\n    if not isinstance(input, list):\n        raise ValueError(\"Input must be a list of file paths\")\n\n    else:\n        # Check whether all are string\n        if not all(isinstance(x, str) for x in input):\n            raise ValueError('Input must contain only string of file paths')\n        else:\n            # \n            extensions = [e.split(\".\")[-1] for e in input]\n            no_extension = len(numpy.unique(extensions))\n            if no_extension == 1:\n                consistency = True\n                extension = str(extensions[0])\n            else:\n                consistency = False\n                extension = None\n\n            return consistency, extension          \n</code></pre>"},{"location":"common/#geonate.common.degree2meter","title":"<code>degree2meter(input, latitude=None)</code>","text":"<p>Convert distance from degrees to meters depending on latitude</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>numeric</code> <p>Input resolution in degrees</p> required <code>latitude</code> <code>numeric</code> <p>Latitude of the location. If latitude is None, the location is assumed near the Equator. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Distance length (numeric | float)</code> <p>Distance in meters corresponding to the input degree</p> Source code in <code>geonate/common.py</code> <pre><code>def degree2meter(input, latitude=None):\n    \"\"\"Convert distance from degrees to meters depending on latitude\n\n    Args:\n        input (numeric): Input resolution in degrees\n        latitude (numeric, optional): Latitude of the location. If latitude is None, the location is assumed near the Equator. Defaults to None.\n\n    Returns:\n        Distance length (numeric | float): Distance in meters corresponding to the input degree\n\n    \"\"\"\n    import numpy as np\n\n    if latitude is None:\n        # Equator location\n        meters = input * (111320 * np.cos(np.radians(0.0)))\n    else:\n        meters = input * (111320 * np.cos(np.radians(latitude)))\n\n    return meters\n</code></pre>"},{"location":"common/#geonate.common.empty_dataframe","title":"<code>empty_dataframe(nrows, ncols, value='NA', name=None)</code>","text":"<p>Create an empty dataframe</p> <p>Parameters:</p> Name Type Description Default <code>nrows</code> <code>numeric</code> <p>Numbers of rows</p> required <code>ncols</code> <code>numeric</code> <p>Number of columns</p> required <code>value</code> <code>str | numeric</code> <p>Input value in all cells. Defaults to 'NA'.</p> <code>'NA'</code> <code>name</code> <code>list</code> <p>Names of columns, if not given, it will return default as number of column. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataframe (pandas datafram)</code> <p>An empty filled with NA or user-defined number (e.g., 0)</p> Source code in <code>geonate/common.py</code> <pre><code>def empty_dataframe(nrows, ncols, value='NA', name=None):\n    \"\"\"Create an empty dataframe\n\n    Args:\n        nrows (numeric): Numbers of rows\n        ncols (numeric): Number of columns\n        value (str | numeric, optional): Input value in all cells. Defaults to 'NA'.\n        name (list, optional): Names of columns, if not given, it will return default as number of column. Defaults to None.\n\n    Returns:\n        Dataframe (pandas datafram): An empty filled with NA or user-defined number (e.g., 0)\n\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    # Check validity of column name\n    if name is None:\n        column_names = [f'Col_{i+1}' for i in range(ncols)]\n    elif len(name) == ncols:\n        column_names = name\n    else:\n        raise ValueError(\"Length of column names vector must match numbers of columns\")\n\n    # check input value\n    try: \n        if isinstance(value, int):\n            val = value\n        elif isinstance(value, float):\n            val = value\n        else:\n            val = np.nan\n    except ValueError:\n        val = np.nan\n\n    # Create data and parse it into dataframe \n    data = [[val] * ncols for _ in range(nrows)]\n    dataframe = pd.DataFrame(data, columns= column_names)\n\n    return dataframe\n</code></pre>"},{"location":"common/#geonate.common.get_extent_external","title":"<code>get_extent_external(input)</code>","text":"<p>Computes the spatial extent of geospatial files and returns the bounding box and a GeoDataFrame of the bounding polygon.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str or list</code> <p>A single file path or a list of file paths. Supported file types are GeoTIFF raster (tif) and shapefile (shp).</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - general_extent (tuple): The bounding box of the input files in the format (minx, miny, maxx, maxy).     - bound_poly (geopandas.GeoDataFrame): A GeoDataFrame containing the bounding polygon.</p> Source code in <code>geonate/common.py</code> <pre><code>def get_extent_external(input):\n    \"\"\"\n    Computes the spatial extent of geospatial files and returns the bounding box and a GeoDataFrame of the bounding polygon.\n\n    Args:\n        input (str or list): A single file path or a list of file paths. Supported file types are GeoTIFF raster (tif) and shapefile (shp).\n\n    Returns:\n        tuple: A tuple containing:\n            - general_extent (tuple): The bounding box of the input files in the format (minx, miny, maxx, maxy).\n            - bound_poly (geopandas.GeoDataFrame): A GeoDataFrame containing the bounding polygon.\n\n    \"\"\"\n\n    import rasterio\n    import geopandas\n    from shapely.geometry import Polygon\n    from .raster import rast, vect\n\n    #### Single path\n    if (not isinstance(input, list)) or ((isinstance(input, list) and (len(input)==1))):\n        # Check whether single list or string\n        if len(input) == 1:\n            input = input[0]\n        else:\n            input = input\n\n        # Extract file extension\n        extension = input.split(\".\")[-1]\n\n        # Raster files\n        if extension == 'tif':\n            tmp = rast(input)\n            general_extent = tmp.bounds\n            crs = tmp.crs\n            # Create bound polygon\n            poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n            bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n            bound_poly.crs = {'init': crs}\n\n            return general_extent, bound_poly\n\n        # Vector Shapefile \n        elif extension == 'shp':\n            tmp = vect(input)\n            ext = tmp.bounds\n            crs = tmp.crs\n            no_poly = ext.shape[0]\n\n            # Determine general bound in case single polygon or multiple polygons\n            if no_poly == 1:\n                general_extent = tuple(ext.loc[0, :])\n            elif no_poly &gt;= 2:\n                general_extent = (ext.iloc[:, 0].min(), ext.iloc[:, 1].min(), ext.iloc[:, 2].max(),ext.iloc[:, 3].max())\n\n            # Create bound polygon\n            poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n            bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n            bound_poly.crs = {'init': crs}\n\n            return general_extent, bound_poly\n\n        # Other data types\n        else:\n            raise ValueError('It only supports geotif raster (tif) and shapefile (shp)')\n\n    #### List of multiple paths    \n    else:\n        consistency, extension = check_extension_consistency(input)\n\n        # Check extension consistency\n        if consistency is True:\n            # Raster files\n            if extension == 'tif':\n                files = [rast(file) for file in input]\n                general_extent = None \n\n                # read each file\n                for file in files:\n                    ext = file.bounds\n                    crs = file.crs                \n\n                    # determine general extent\n                    if general_extent is None:\n                        general_extent = ext\n                    else:\n                        general_extent =  (\n                            min(general_extent[0], ext[0]),\n                            min(general_extent[1], ext[1]),\n                            max(general_extent[2], ext[2]),\n                            max(general_extent[3], ext[3])\n                            )\n\n                    # Create bound polygon\n                    poly_geom = Polygon([\n                        (general_extent[0], general_extent[1]), \n                        (general_extent[2], general_extent[1]), \n                        (general_extent[2], general_extent[3]), \n                        (general_extent[0], general_extent[3])\n                        ])\n                    bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n                    bound_poly.crs = {'init': crs} \n\n                    return general_extent, bound_poly\n\n            # Shapefile data\n            elif extension == 'shp':\n                files = [vect(file) for file in input]\n                general_extent = None                        \n\n                # read each file\n                for file in files:\n                    ext = file.bounds\n                    crs = file.crs\n                    no_poly = ext.shape[0]\n\n                    # Determine general bound in case single polygon or multiple polygons\n                    if no_poly == 1:\n                        ext = tuple(ext.loc[0, :])\n                    elif no_poly &gt;= 2:\n                        ext = (ext.iloc[:, 0].min(), ext.iloc[:, 1].min(), ext.iloc[:, 2].max(),ext.iloc[:, 3].max())\n\n                    # determine general extent\n                    if general_extent is None:\n                        general_extent = ext\n                    else:\n                        general_extent =  (\n                            min(general_extent[0], ext[0]),\n                            min(general_extent[1], ext[1]),\n                            max(general_extent[2], ext[2]),\n                            max(general_extent[3], ext[3])\n                            )\n\n                    # Create bound polygon\n                    poly_geom = Polygon([\n                        (general_extent[0], general_extent[1]), \n                        (general_extent[2], general_extent[1]), \n                        (general_extent[2], general_extent[3]), \n                        (general_extent[0], general_extent[3])\n                        ])\n                    bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n                    bound_poly.crs = {'init': crs} \n\n                    return general_extent, bound_poly\n\n            # Other data types\n            else:\n                raise ValueError('Input only supports geotif (tif) and shapefile (shp)')\n\n        # Other cases\n        else:\n            raise ValueError('Input have different data extensions')\n</code></pre>"},{"location":"common/#geonate.common.get_extent_local","title":"<code>get_extent_local(input)</code>","text":"<p>Computes the spatial extent of a single or multiple geospatial files (GeoTIFF raster or shapefile).</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list or object</code> <p>A single rasterio.io.DatasetReader object, a single geopandas.geodataframe.GeoDataFrame object, or a list of such objects.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - general_extent (tuple): The bounding box of the input(s) in the format (min_x, min_y, max_x, max_y).     - bound_poly (geopandas.GeoDataFrame): A GeoDataFrame containing a single polygon representing the bounding box.</p> Source code in <code>geonate/common.py</code> <pre><code>def get_extent_local(input):\n    \"\"\"\n    Computes the spatial extent of a single or multiple geospatial files (GeoTIFF raster or shapefile).\n\n    Args:\n        input (list or object): A single rasterio.io.DatasetReader object, a single geopandas.geodataframe.GeoDataFrame object, or a list of such objects.\n\n    Returns:\n        tuple: A tuple containing:\n            - general_extent (tuple): The bounding box of the input(s) in the format (min_x, min_y, max_x, max_y).\n            - bound_poly (geopandas.GeoDataFrame): A GeoDataFrame containing a single polygon representing the bounding box.\n\n    \"\"\"\n    import rasterio\n    import geopandas\n    from shapely.geometry import Polygon\n\n    #### Single file\n    if (not isinstance(input, list)) or len(input)==1:\n        if (isinstance(input, rasterio.io.DatasetReader)):\n            general_extent = input.bounds\n            crs = input.crs\n\n            poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n            bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n            bound_poly.crs = {'init': crs}\n\n            return general_extent, bound_poly\n\n        elif (isinstance(input, geopandas.geodataframe.GeoDataFrame)):\n            ext = input.bounds\n            crs = input.crs\n            no_poly = ext.shape[0]\n\n            # Determine general bound in case single polygon or multiple polygons\n            if no_poly == 1:\n                general_extent = tuple(ext.loc[0, :])\n            elif no_poly &gt;= 2:\n                general_extent = (ext.iloc[:, 0].min(), ext.iloc[:, 1].min(), ext.iloc[:, 2].max(),ext.iloc[:, 3].max())\n\n            poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n            bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n            bound_poly.crs = {'init': crs}\n\n            return general_extent, bound_poly\n\n        else:\n            raise ValueError('It only supports geotif raster and shapefile')\n\n    #### Multiple files\n    elif (isinstance(input, list)) or len(input) &gt; 1:\n        consistency, datatype = check_datatype_consistency(input)\n\n        # Input are Raster files\n        if (consistency is True) and (datatype == \"&lt;class 'rasterio.io.DatasetReader'&gt;\"):\n            general_extent = None        \n            # read each file\n            for file in input:\n                ext = file.bounds\n                crs = file.crs                \n\n                # determine general extent\n                if general_extent is None:\n                    general_extent = ext\n                else:\n                    general_extent =  (\n                        min(general_extent[0], ext[0]),\n                        min(general_extent[1], ext[1]),\n                        max(general_extent[2], ext[2]),\n                        max(general_extent[3], ext[3])\n                        )\n\n                # Create bound polygon\n                poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n                bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n                bound_poly.crs = {'init': crs} \n\n                return general_extent, bound_poly\n\n        # Input are Shapefile files\n        elif (consistency is True) and (datatype == \"&lt;class 'geopandas.geodataframe.GeoDataFrame'&gt;\"):\n            general_extent = None                        \n            # read each file\n            for file in input:\n                ext = file.bounds\n                crs = file.crs\n                no_poly = ext.shape[0]\n\n                # Determine general bound in case single polygon or multiple polygons\n                if no_poly == 1:\n                    ext = tuple(ext.loc[0, :])\n                elif no_poly &gt;= 2:\n                    ext = (ext.iloc[:, 0].min(), ext.iloc[:, 1].min(), ext.iloc[:, 2].max(),ext.iloc[:, 3].max())\n\n                # determine general extent\n                if general_extent is None:\n                    general_extent = ext\n                else:\n                    general_extent =  (\n                        min(general_extent[0], ext[0]),\n                        min(general_extent[1], ext[1]),\n                        max(general_extent[2], ext[2]),\n                        max(general_extent[3], ext[3])\n                        )\n\n                # Create bound polygon\n                poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n                bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n                bound_poly.crs = {'init': crs} \n\n                return general_extent, bound_poly\n\n        # Other data types\n        else:\n            raise ValueError('Input have different data types') \n\n    #### Other cases\n    else:\n        raise ValueError('It only supports geotif raster and shapefile')\n</code></pre>"},{"location":"common/#geonate.common.listFiles","title":"<code>listFiles(path, pattern, search_type='pattern', full_name=True)</code>","text":"<p>List all files with specific pattern within a folder path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>AnyStr</code> <p>Folder path where files stored</p> required <code>pattern</code> <code>AnyStr</code> <p>Search pattern of files (e.g., '*.tif')</p> required <code>search_type</code> <code>AnyStr</code> <p>Search type whether by \"extension\" or name \"pattern\". Defaults to 'pattern'.</p> <code>'pattern'</code> <code>full_name</code> <code>bool</code> <p>Whether returning full name with path detail or only file name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>A string list (list)</code> <p>A list of file paths</p> Source code in <code>geonate/common.py</code> <pre><code>def listFiles(path: AnyStr, pattern: AnyStr, search_type: AnyStr = 'pattern', full_name: bool=True):\n    \"\"\"List all files with specific pattern within a folder path\n\n    Args:\n        path (AnyStr): Folder path where files stored\n        pattern (AnyStr): Search pattern of files (e.g., '*.tif')\n        search_type (AnyStr, optional): Search type whether by \"extension\" or name \"pattern\". Defaults to 'pattern'.\n        full_name (bool, optional): Whether returning full name with path detail or only file name. Defaults to True.\n\n    Returns:\n        A string list (list): A list of file paths\n\n    \"\"\"\n    import os\n    import fnmatch\n\n    # Create empty list to store list of files\n    files_list = []\n\n    # Check search type\n    if (search_type.upper() == 'EXTENSION') or (search_type.upper() == 'E'):\n        if '*' in pattern:\n            raise ValueError(\"Do not use '*' in the pattern of extension search\")\n        else:\n            for root, dirs, files in os.walk(path):\n                for file in files:\n                    if file.lower().endswith(pattern):\n                        if full_name is True:\n                            files_list.append(os.path.join(root, file))\n                        else:\n                            files_list.append(file)    \n\n    elif (search_type.upper() == 'PATTERN') or (search_type.upper() == 'P'):\n        if '*' not in pattern:\n            raise ValueError(\"Pattern search requires '*' in pattern\")\n        else:\n            for root, dirs, files in os.walk(path):\n                for file in fnmatch.filter(files, pattern):\n                    if full_name is True:\n                        files_list.append(os.path.join(root, file))\n                    else:\n                        files_list.append(file)\n\n    else:\n        raise ValueError('Search pattern must be one of these types (pattern, p, extension, e)')\n\n    return files_list\n</code></pre>"},{"location":"common/#geonate.common.meter2degree","title":"<code>meter2degree(input, latitude=None)</code>","text":"<p>Convert image resolution from meter to acr-degree depending on location of latitude</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>numeric</code> <p>Input resolution of distance</p> required <code>latitude</code> <code>numeric</code> <p>Latitude presents location. If latitude is None, the location is assumed near Equator. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Degree (float)</code> <p>Degree corresponding to the distance length</p> Source code in <code>geonate/common.py</code> <pre><code>def meter2degree(input, latitude=None):\n    \"\"\"Convert image resolution from meter to acr-degree depending on location of latitude\n\n    Args:\n        input (numeric): Input resolution of distance\n        latitude (numeric, optional): Latitude presents location. If latitude is None, the location is assumed near Equator. Defaults to None.\n\n    Returns:\n        Degree (float): Degree corresponding to the distance length\n\n    \"\"\"\n    import numpy as np\n\n    if latitude is None:\n        # Equator location\n        degree = input / (111320 * np.cos(np.radians(0.0)))\n    else:\n        degree = input / (111320 * np.cos(np.radians(latitude)))\n\n    return degree\n</code></pre>"},{"location":"common/#geonate.common.mimax","title":"<code>mimax(input, digit=3)</code>","text":"<p>Calculate maximum and minimum values of raster or array</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | array</code> <p>Raster image or data array</p> required <code>digit</code> <code>int</code> <p>Precise digit number. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>Min and Max values (numeric)</code> <p>Return 2 numbers of minvalue and maxvalue</p> Source code in <code>geonate/common.py</code> <pre><code>def mimax(input, digit=3):\n    \"\"\"Calculate maximum and minimum values of raster or array\n\n    Args:\n        input (raster | array): Raster image or data array\n        digit (int, optional): Precise digit number. Defaults to 3.\n\n    Returns:\n        Min and Max values (numeric): Return 2 numbers of minvalue and maxvalue\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Calculate min and max values\n    minValue = round(np.nanmin(dataset), digit)\n    maxValue = round(np.nanmax(dataset), digit)\n\n    # Convert min and max to string for print\n    min_round = str(round(minValue, digit))\n    max_round = str(round(maxValue, digit))\n\n    print(f\"[Min: {min_round}  | Max: {max_round}]\")\n\n    return minValue, maxValue\n</code></pre>"},{"location":"common/#geonate.common.reshape_raster","title":"<code>reshape_raster(inputArray, mode='image')</code>","text":"<p>Reshapes a 3-dimensional numpy array between 'image' and 'raster' formats.</p> <p>Parameters:</p> Name Type Description Default <code>inputArray</code> <code>array</code> <p>The input 3-dimensional array to be reshaped.</p> required <code>mode</code> <code>str</code> <p>The mode to reshape the array to. 'image' or 'img' reshapes to (height, width, bands), 'raster' or 'r' reshapes to (bands, height, width). Default is 'image'.</p> <code>'image'</code> <p>Returns:</p> Type Description <code>Reshape array (array)</code> <p>The reshaped array.</p> Source code in <code>geonate/common.py</code> <pre><code>def  reshape_raster(inputArray, mode:str=\"image\"):\n    \"\"\"\n    Reshapes a 3-dimensional numpy array between 'image' and 'raster' formats.\n\n    Parameters:\n        inputArray (array): The input 3-dimensional array to be reshaped.\n        mode (str): The mode to reshape the array to. 'image' or 'img' reshapes to (height, width, bands), 'raster' or 'r' reshapes to (bands, height, width). Default is 'image'.\n\n    Returns:\n        Reshape array (array): The reshaped array.\n\n    \"\"\"\n    import numpy as np\n\n    # Check whether input are 3-dim data array\n    if len(inputArray) == 3:\n        # Convert to image\n        if mode.lower() == 'image' or mode.lower() == 'img':\n            output = np.transpose(inputArray, (1,2,0))\n        # Convert to raster\n        elif mode.lower() == 'raster' or mode.lower() == 'r':\n            output = np.transpose(inputArray, (2,0,1))\n\n        return output \n\n    #Other cases\n    else:\n        raise ValueError('Input data array must have 3 dimensions')\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/canng/geonate/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geonate could always use more documentation, whether as part of the official geonate docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/canng/geonate/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geonate for local development.</p> <ol> <li> <p>Fork the geonate repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geonate.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geonate\n$ cd geonate/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geonate tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/canng/geonate/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geonate/","title":"geonate module","text":"<p>Main module.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geonate, run this command in your terminal:</p> <pre><code>pip install geonate\n</code></pre> <p>This is the preferred method to install geonate, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geonate from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/canng/geonate\n</code></pre>"},{"location":"plot/","title":"plot module","text":"<p>The visualization module</p>"},{"location":"plot/#geonate.plot.colormaps","title":"<code>colormaps()</code>","text":"<p>Display all available colormaps in Matplotlib.</p> <p>This function generates a plot that shows all the colormaps available in Matplotlib. Each colormap is displayed as a horizontal gradient bar.</p> Source code in <code>geonate/plot.py</code> <pre><code>def colormaps():   \n    \"\"\"\n    Display all available colormaps in Matplotlib.\n\n    This function generates a plot that shows all the colormaps available in Matplotlib.\n    Each colormap is displayed as a horizontal gradient bar.\n\n    \"\"\" \n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # Get all colormaps available in Matplotlib\n    colormaps = plt.colormaps()\n\n    # Generate a gradient to display colormaps\n    gradient = np.linspace(0, 1, 256).reshape(1, -1)\n\n    # Set figure size\n    fig, ax = plt.subplots(figsize=(10, len(colormaps) * 0.25))\n\n    # Loop through colormaps and display them\n    for i, cmap in enumerate(colormaps):\n        ax.imshow(np.vstack([gradient] * 5), aspect='auto', cmap=cmap, extent=[0, 10, i, i + 1])\n\n    # Formatting\n    ax.set_yticks(np.arange(len(colormaps)) + 0.5)\n    ax.set_yticklabels(colormaps)\n    ax.set_xticks([])\n    ax.set_title(\"Matplotlib Colormaps\", fontsize=12, fontweight=\"bold\")\n    ax.set_ylim(0, len(colormaps))\n\n    plt.show()\n</code></pre>"},{"location":"plot/#geonate.plot.plotRGB","title":"<code>plotRGB(input, rgb=(0, 1, 2), stretch=True, **kwargs)</code>","text":"<p>Plot a 3-band RGB image using earthpy.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>rasterio.DatasetReader | np.ndarray</code> <p>Rasterio image or data array.</p> required <code>rgb</code> <code>tuple</code> <p>Indices of the RGB bands. Defaults to (0, 1, 2).</p> <code>(0, 1, 2)</code> <code>stretch</code> <code>bool</code> <p>Apply contrast stretching. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional optional parameters for earthpy.plot.plot_rgb(), such as stretch=True for contrast stretching.</p> <code>{}</code> Source code in <code>geonate/plot.py</code> <pre><code>def plotRGB(input, rgb=(0, 1, 2), stretch=True, **kwargs):\n    \"\"\"\n    Plot a 3-band RGB image using earthpy.\n\n    Args:\n        input (rasterio.DatasetReader | np.ndarray): Rasterio image or data array.\n        rgb (tuple, optional): Indices of the RGB bands. Defaults to (0, 1, 2).\n        stretch (bool, optional): Apply contrast stretching. Defaults to True.\n        **kwargs: Additional optional parameters for earthpy.plot.plot_rgb(), such as stretch=True for contrast stretching.\n\n    \"\"\"    \n    import numpy as np\n    import rasterio\n    import earthpy.plot as ep\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Check data dimension to make sure it is a multiple band image\n    if len(dataset) &lt;= 2:\n        raise ValueError('Image has only one band, please provide at least 3-band image')\n\n    # Visualize the input dataset\n    ep.plot_rgb(dataset, rgb= rgb, stretch=stretch, **kwargs)\n\n    from typing import AnyStr, Dict, Optional\n</code></pre>"},{"location":"plot/#geonate.plot.plot_bands","title":"<code>plot_bands(input, cmap='Greys_r', **kwargs)</code>","text":"<p>Plot a raster image or data array using earthpy.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>cmap</code> <code>str</code> <p>Colormap for the plot. Defaults to 'Greys_r'.</p> <code>'Greys_r'</code> <code>**kwargs</code> <code>AnyStr</code> <p>All optional parameters taken from earthpy.plot.plot_bands(), such as cmap='Spectral' for color shade</p> <code>{}</code> Source code in <code>geonate/plot.py</code> <pre><code>def plot_bands(input, cmap='Greys_r', **kwargs):\n    \"\"\"Plot a raster image or data array using earthpy.\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        cmap (str, optional): Colormap for the plot. Defaults to 'Greys_r'.\n        **kwargs (AnyStr, optional): All optional parameters taken from earthpy.plot.plot_bands(), such as cmap='Spectral' for color shade\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    import earthpy.plot as ep\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Visualize the input dataset\n    ep.plot_bands(dataset, cmap=cmap, **kwargs)\n</code></pre>"},{"location":"plot/#geonate.plot.plot_raster","title":"<code>plot_raster(input, layername=None, rgb=None, stretch='linear', brightness=None, contrast=None, opacity=1, zoom=5, basemap='OSM', output=None)</code>","text":"<p>Plots a basemap with an overlay of raster data.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader</code> <p>The input raster dataset.</p> required <code>layername</code> <code>Anstr</code> <p>Layer name of image.</p> <code>None</code> <code>rgb</code> <code>list</code> <p>List of RGB bands to visualize. Defaults to None.</p> <code>None</code> <code>stretch</code> <code>AnyStr</code> <p>Stretch method for the image ('linear', 'hist', 'custom'). Defaults to 'linear'.</p> <code>'linear'</code> <code>brightness</code> <code>float</code> <p>Brightness value for custom stretch. Defaults to None.</p> <code>None</code> <code>contrast</code> <code>float</code> <p>Contrast value for custom stretch. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Opacity of the image overlay. Defaults to 1.</p> <code>1</code> <code>zoom</code> <code>float</code> <p>Initial zoom level of the map. Defaults to 5.</p> <code>5</code> <code>basemap</code> <code>AnyStr</code> <p>Basemap type ('OSM', 'CartoDB Positron', 'CartoDB Dark Matter', 'OpenTopoMap', 'Esri Satellite', 'Esri Street Map', 'Esri Topo', 'Esri Canvas'). Defaults to 'OSM'.</p> <code>'OSM'</code> <code>output</code> <code>AnyStr</code> <p>File path to write out html file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>folium.Map</code> <p>A folium map object with the raster data overlay.</p> Source code in <code>geonate/plot.py</code> <pre><code>def plot_raster(input, layername: Optional[AnyStr]=None, rgb: Optional[list]=None, stretch: Optional[AnyStr]='linear', brightness: Optional[float]=None, contrast: Optional[float]=None, opacity: Optional[float]=1, zoom: Optional[float]=5, basemap: Optional[AnyStr]='OSM', output: Optional[AnyStr]= None):\n    \"\"\"\n    Plots a basemap with an overlay of raster data.\n\n    Args:\n        input (DatasetReader): The input raster dataset.\n        layername (Anstr, optional): Layer name of image.\n        rgb (list, optional): List of RGB bands to visualize. Defaults to None.\n        stretch (AnyStr, optional): Stretch method for the image ('linear', 'hist', 'custom'). Defaults to 'linear'.\n        brightness (float, optional): Brightness value for custom stretch. Defaults to None.\n        contrast (float, optional): Contrast value for custom stretch. Defaults to None.\n        opacity (float, optional): Opacity of the image overlay. Defaults to 1.\n        zoom (float, optional): Initial zoom level of the map. Defaults to 5.\n        basemap (AnyStr, optional): Basemap type ('OSM', 'CartoDB Positron', 'CartoDB Dark Matter', 'OpenTopoMap', 'Esri Satellite', 'Esri Street Map', 'Esri Topo', 'Esri Canvas'). Defaults to 'OSM'.\n        output (AnyStr, optional): File path to write out html file to local directory. Defaults to None.\n\n    Returns:\n        folium.Map: A folium map object with the raster data overlay.\n\n    \"\"\"\n    import folium\n    from folium.raster_layers import ImageOverlay\n    import rasterio\n    import numpy as np\n    from .common import meter2degree, get_extent_local\n    from .raster import reproject\n\n\n    ### Check input data is raster or not and extract information\n    if isinstance(input, rasterio.DatasetReader):\n        # Convert image to lat/long if input is not in lat/long system\n        crs = input.crs.to_string()\n        if crs == \"EPSG:4326\":\n            input_converted = input\n        else:\n            resolution_degree = meter2degree(input.res[0])\n            input_converted = reproject(input, reference='EPSG:4326', res=resolution_degree)\n\n        # Extract data from image to visualize\n        if (input.count &lt;= 2):\n            print('Input image/data has less than 2 bands, it will load the first band only')\n            dataset = input.read(1)\n            imgData = dataset[:, :, np.newaxis]\n        elif (input.count &gt;= 3):\n            if rgb is None: \n                raise ValueError('Input is multiple band image, please provide rgb bands to visualize [3,2,1]')\n            else:\n                dataset = input.read(rgb)\n                imgData = np.transpose(dataset, (1, 2, 0)) # Transpose from raster dims (bands, width, height) to image dims (width, height, bands)\n    else:\n        raise ValueError(\"Input data is not supported. It must be raster image\")\n\n    # Check stretch method\n    if stretch is None:\n        data = imgData\n\n    elif stretch.lower() == 'linear':\n        data = np.clip((imgData  - imgData.min()) / (imgData.max() - imgData.min()) * 255, 0, 255).astype(np.uint8) # linear stretching based on min max values\n\n    elif stretch.lower() == 'hist' or stretch.lower() == 'histogram':\n        from skimage import exposure\n        data = exposure.equalize_hist(imgData)  # This returns a floating point image with values between 0 and 1\n        data = (data * 255).astype(np.uint8)  # Convert back to 8-bit image for display\n\n    elif stretch.lower() == 'custom':\n        if (contrast is None) or (brightness is None):\n            raise ValueError(\"contrast and brightness must be given for custom stretching method\")\n        else:\n            data = np.clip((imgData * contrast + brightness), 0, 255).astype(np.uint8)\n\n    else: \n        raise ValueError(\"Stretch method is not supported ('linear', 'hist', 'custom')\")\n\n    # Get Bounds values\n    left, bottom, right, top = get_extent_local(input_converted)[0]\n    lat_center = (top + bottom) / 2\n    lon_center = (left + right)/ 2\n    bounds = [[bottom, left], [top, right]]\n\n    # Create overlay image\n    if layername is not None:\n        image_overlay = ImageOverlay(image= data, bounds= bounds, opacity= opacity, name=layername)\n    else:\n        image_overlay = ImageOverlay(image= data, bounds= bounds, opacity= opacity, name='Layer')\n\n    # Add the image overlay to the map\n\n    # Take basemap\n    if basemap.lower() == 'openstreetmap' or basemap.lower() == 'osm' or basemap.lower() == 'open street map':\n        basemap_name = 'OpenStreetMap'\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom, tiles=basemap_name)\n\n    elif basemap.lower() == 'cartodbpositron' or basemap.lower() == 'cartodb positron' or basemap.lower() == 'light' :\n        basemap_name = 'Cartodb Positron'\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom, tiles=basemap_name)\n\n    elif basemap.lower() == 'cartodbdarkmatter' or basemap.lower() == 'cartodb dark matter' or basemap.lower() == 'cartodb dark' or basemap.lower() == 'dark':\n        basemap_name = 'Cartodb dark_matter'\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom, tiles=basemap_name)\n\n    elif basemap.lower() == 'opentopomap' or basemap.lower() == 'opentopo' or basemap.lower() == 'topo':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles='https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',\n            attr='&amp;copy; Topo Map',\n            name='Open Topo Map'\n        ).add_to(m)\n\n    elif basemap.lower() == 'esri satellite' or basemap.lower() == 'esrisatellite' or basemap.lower() == 'satellite':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles= 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n            attr='&amp;copy; Esri',\n            name='Esri Satellite'\n        ).add_to(m)\n\n    elif basemap.lower() == 'esri street' or basemap.lower() == 'esristreet' or basemap.lower() == 'streetmap' or basemap.lower() == 'street map':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles= 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',\n            attr='&amp;copy; Esri',\n            name='Esri Street Map'\n        ).add_to(m)\n\n    elif basemap.lower() == 'esri topo' or basemap.lower() == 'esritopo':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles= 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',\n            attr='&amp;copy; Esri',\n            name='Esri Topo Map'\n        ).add_to(m)\n\n    elif basemap.lower() == 'esri canvas' or basemap.lower() == 'esricanvas' or basemap.lower() == 'canvas':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles= 'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',\n            attr='&amp;copy; Esri',\n            name='Esri Canvas Gray'\n        ).add_to(m)\n\n    else:\n        raise ValueError(\"Basemap is not supported, please select one of these maps ('OSM', 'CartoDB Positron', 'CartoDB Dark Matter', 'OpenTopoMap', 'Esri Satellite', 'Esri Street Map', 'Esri Topo', 'Esri Canvas')\")\n\n    # Add image to basemap    \n    image_overlay.add_to(m)\n    folium.LayerControl().add_to(m)\n\n    # Save map\n    if output is not None:\n        m.save(output)\n    else:\n        pass\n\n    return m  \n</code></pre>"},{"location":"raster/","title":"raster module","text":"<p>The raster module</p>"},{"location":"raster/#geonate.raster.crop","title":"<code>crop(input, reference, invert=False)</code>","text":"<p>Crops a raster file based on a reference shapefile or raster file. Optionally inverts the crop.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster</code> <p>The input raster file.</p> required <code>reference</code> <code>shapefile | raster</code> <p>The reference shapefile (GeoDataFrame) or raster file (DatasetReader) to define the crop boundary.</p> required <code>invert</code> <code>bool</code> <p>If True, inverts the crop to mask out the area within the boundary. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>A clipped raster (raster)</code> <p>The cropped raster file.</p> Source code in <code>geonate/raster.py</code> <pre><code>def crop(input, reference, invert=False):\n    \"\"\"\n    Crops a raster file based on a reference shapefile or raster file. Optionally inverts the crop.\n\n    Args:\n        input (raster): The input raster file.\n        reference (shapefile | raster): The reference shapefile (GeoDataFrame) or raster file (DatasetReader) to define the crop boundary.\n        invert (bool): If True, inverts the crop to mask out the area within the boundary. Defaults to False.\n\n    Returns:\n        A clipped raster (raster): The cropped raster file.\n\n    \"\"\"\n    import rasterio\n    import geopandas as gpd\n    import numpy as np\n    from rasterio import mask\n    from rasterio.transform import Affine\n    from shapely.geometry import mapping\n    from shapely.geometry import box\n    from .common import array2raster\n\n    # Convert datatype of input to float32 to store NA value\n    arr = input.read().astype(np.float32)\n    meta = input.meta\n    meta.update({'dtype': np.float32})\n    input_image = array2raster(arr, meta)\n\n    ### Define boundary\n    # Reference is shapefile\n    if isinstance(reference, gpd.GeoDataFrame):\n        minx, miny, maxx, maxy = reference.total_bounds\n        # define box\n        bbox = box(minx, miny, maxx, maxy)\n        poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs=reference.crs)\n\n    # Reference is raster\n    elif isinstance(reference, rasterio.DatasetReader):\n        minx, miny, maxx, maxy = reference.bounds\n        # define box\n        bbox = box(minx, miny, maxx, maxy)\n        poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs=reference.crs)\n\n    # Others\n    else:\n        raise ValueError('Reference data is not supported')   \n\n    ### Invert crop\n    if invert is True:\n        clipped, geotranform = mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), invert=True, nodata= np.nan)\n    else:\n        clipped, geotranform = mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), crop=True, invert=False, nodata= np.nan)\n\n    # Update metadata\n    meta  = input.meta\n    meta.update({\n        'height': clipped.shape[1],\n        'width': clipped.shape[2],\n        'transform': geotranform,\n        'dtype': np.float32,\n        'nodata': np.nan\n        })\n\n    # Convert array to raster\n    clipped_raster = array2raster(clipped, meta)\n\n    return clipped_raster\n</code></pre>"},{"location":"raster/#geonate.raster.extractValues","title":"<code>extractValues(input, roi, field=None, meta=None, dataframe=True, names=None, na_rm=True, nodata=None, prefix=None, tail=True)</code>","text":"<p>Extract pixel values in GCP for both point and polygon </p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>roi</code> <code>AnyStr</code> <p>Shapefile where GCP points located, read by geopandas </p> required <code>field</code> <code>AnyStr</code> <p>Sstring, but the value of this field must be number, the field name in shapefile GCP to extract label values, e.g., 'class'. Defaults to None.</p> <code>None</code> <code>meta</code> <code>AnyStr</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>dataframe</code> <code>bool</code> <p>Whether to return dataframe or separate X, y arrays. Defaults to True.</p> <code>True</code> <code>names</code> <code>list</code> <p>Given expected names for each column in dataframe. Defaults to None.</p> <code>None</code> <code>na_rm</code> <code>bool</code> <p>Remove NA value from the output or not. Defaults to True.</p> <code>True</code> <code>nodata</code> <code>AnyStr</code> <p>Fill in value for NA data. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>AnyStr</code> <p>Given character before each band name. Defaults to None.</p> <code>None</code> <code>tail</code> <code>bool</code> <p>To place the class value at the end or front of the dataframe. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dataframe</code> <p>dataframe if dataframe = True ndarray: X, y Data arrays for training model</p> Source code in <code>geonate/raster.py</code> <pre><code>def extractValues(input: AnyStr, roi: AnyStr, field: Optional[AnyStr]=None, meta: Optional[AnyStr]=None, dataframe: Optional[bool]=True, names: Optional[list]=None, na_rm: bool=True, nodata=None, prefix: Optional[AnyStr]=None, tail=True):\n    \"\"\"Extract pixel values in GCP for both point and polygon \n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        roi (AnyStr): Shapefile where GCP points located, read by geopandas \n        field (AnyStr, optional): Sstring, but the value of this field must be number, the field name in shapefile GCP to extract label values, e.g., 'class'. Defaults to None.\n        meta (AnyStr, optional): Metadata in case input is data array. Defaults to None.\n        dataframe (bool, optional): Whether to return dataframe or separate X, y arrays. Defaults to True.\n        names (list, optional): Given expected names for each column in dataframe. Defaults to None.\n        na_rm (bool, optional): Remove NA value from the output or not. Defaults to True.\n        nodata (AnyStr, optional): Fill in value for NA data. Defaults to None.\n        prefix (AnyStr, optional): Given character before each band name. Defaults to None.\n        tail (bool, optional): To place the class value at the end or front of the dataframe. Defaults to True.\n\n    Returns:\n        dataframe: dataframe if dataframe = True\n        ndarray: X, y Data arrays for training model\n\n    \"\"\"\n    import os\n    import rasterio\n    from rasterio.plot import reshape_as_image\n    import numpy as np\n    from shapely.geometry import mapping\n    from rasterio import mask\n    import pandas as pd\n\n    if field is None:\n        raise ValueError('Please provide field name')\n    else:\n        ### Define input image\n        # input is raster\n        if isinstance(input, rasterio.DatasetReader):\n            input_image = input\n        # input is array\n        elif isinstance(input, np.ndarray):\n            if meta is None:\n                raise ValueError('It requires metadata of input')\n            else:\n                if not os.path.exists('./tmp/'):\n                    os.makedirs('./tmp/')\n                writeRaster(input, './tmp/tmp.tif', meta)\n                input_image = rast('./tmp/tmp.tif')\n        # Other input\n        else:\n            raise ValueError('Input data is not supported')\n\n        ########\n\n        ### Define nodata\n        if nodata is None:\n            dataType = input_image.meta['dtype']\n            if dataType.lower() == 'int8':\n                nodata_value = 127\n            elif dataType.lower() == 'uint8':\n                nodata_value = 255\n            elif dataType.lower() == 'int16':\n                nodata_value = 32767\n            elif dataType.lower() == 'uint16':\n                nodata_value = 65535\n            elif dataType.lower() == 'int32':\n                nodata_value = 2147483647\n            elif dataType.lower() == 'uint32':\n                nodata_value = 4294967295\n            elif dataType.lower() == 'float16':\n                nodata_value = 65500\n            elif dataType.lower() == 'float32':\n                nodata_value = 999999\n            else:\n                nodata_value = 0\n        else:\n            nodata_value = nodata   \n\n        # Convert shapefile to shapely geometry\n        geoms = roi.geometry.values\n\n        # Extract some metadata information\n        nbands = input_image.count\n        dtype_X = np.float32()\n        dtype_y = np.float32()\n\n        # Create empty array to contain X and y arrays\n        X = np.array([], dtype= dtype_X).reshape(0, nbands)\n        y = np.array([], dtype= dtype_y)\n\n        # Run loop over each features in shapefile to extract pixel values\n        for index, geom in enumerate(geoms):\n            poly = [mapping(geom)]\n\n            # Crop image based on feature\n            cropped, transform = mask.mask(input_image, poly, crop=True, nodata=nodata_value)\n\n            # Reshape dataset in form of (values, bands)\n            cropped_reshape = reshape_as_image(cropped)\n            reshapped = cropped_reshape.reshape(-1, nbands)\n\n            # Append 1D array y\n            y = np.append(y, [roi[field][index]] * reshapped.shape[0])\n\n            # vertical stack 2D array X\n            X = np.vstack((X, reshapped))\n\n        # Remove NAN value or not\n        if na_rm is True: \n            data = np.hstack((X, y.reshape(y.shape[0], 1)))\n            data_na = data[~np.isnan(data).any(axis=1)]\n            data_nodata = data_na[~(data_na == nodata_value).any(axis=1)]\n\n            X_na = data_nodata[ :, 0:nbands]\n            y_na = data_nodata[ : , nbands]\n\n            # return dataframe\n            if dataframe is True:\n                y_na_reshape = y_na.reshape(-1,1)\n\n                # class tail\n                if tail is True:\n                    arr = np.hstack([X_na, y_na_reshape])\n                else:\n                    arr = np.hstack([y_na_reshape, X_na])\n\n                # Name is not given\n                if names is None:\n                    if prefix is None:\n                        names_band = [f'B{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    else:\n                        names_band = [f'{prefix}{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n                # Name is given\n                else:\n                    if len(names) != (nbands + 1):\n                        raise ValueError('Length of name should be equal to number of bands plus 1')\n                    else:\n                        if prefix is None:\n                            names_list = names\n                        else:\n                            names_list = [f'{prefix}{name_i}' for name_i in names]\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n            # Do not return dataframe\n            else:\n                return X_na, y_na\n\n        # Do not remove NAN values\n        else: \n            # return dataframe\n            if dataframe is True:\n                y_reshape = y.reshape(-1,1)\n                arr = np.hstack([X, y_reshape])\n\n                # Name is not given\n                if names is None:\n                    if prefix is None:\n                        names_band = [f'B{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    else:\n                        names_band = [f'{prefix}{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n                # Name is given\n                else:\n                    if len(names) != (nbands + 1):\n                        raise ValueError('Length of name should be equal to number of bands plus 1')\n                    else:\n                        if prefix is None:\n                            names_list = names\n                        else:\n                            names_list = [f'{prefix}{name_i}' for name_i in names]\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n            else:\n                return X, y\n</code></pre>"},{"location":"raster/#geonate.raster.layestack","title":"<code>layestack(input)</code>","text":"<p>Stacks multiple raster files or rasterio DatasetReader objects into a single multi-band raster.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>List of file paths to the input raster files or rasterio DatasetReader objects.</p> required <p>Returns:</p> Type Description <code>Stacked raster (raster)</code> <p>Stacked raster image.</p> Source code in <code>geonate/raster.py</code> <pre><code>def layestack(input):\n    \"\"\"\n    Stacks multiple raster files or rasterio DatasetReader objects into a single multi-band raster.\n\n    Parameters:\n        input (list): List of file paths to the input raster files or rasterio DatasetReader objects.\n\n    Returns:\n        Stacked raster (raster): Stacked raster image.\n\n    \"\"\"\n    import numpy as np\n    from .raster import rast\n    from .common import array2raster, check_datatype_consistency, check_extension_consistency\n\n    # Initialize some parameters and variables\n    file2stack = []\n    stacked_array = []\n    nbands = len(input)\n\n    consistency, datatype = check_datatype_consistency(input)\n\n    # If input is list of file paths\n    if (consistency is True) and datatype == \"&lt;class 'str'&gt;\":\n        consistency_ext, extension = check_extension_consistency(input)\n\n        # If input is a list of tif files\n        if (consistency_ext is True) and (extension == 'tif'):\n            # Stack each band \n            for i, bandi in enumerate(input):\n                tmp = rast(input[i])\n                ds = tmp.read(1) # Read each raster and read data array\n                meta = tmp.meta \n                file2stack.append(ds) # stack each band in a list of data\n        # Other data extension\n        else:\n            raise ValueError('Data type is not supported')\n\n    # If input is local raster files \n    elif (consistency is True) and datatype == \"&lt;class 'rasterio.io.DatasetReader'&gt;\":\n        # Stack each band \n        for i, bandi in enumerate(input):\n            ds = input[i].read(1) # Read each band\n            meta = bandi.meta \n            file2stack.append(ds) # stack each band in a list of data\n    else:\n        raise ValueError('Data type is not supported')    \n\n    # convert list to array and update nbands\n    stacked_array = np.stack(file2stack, axis=0) \n    meta.update({'count': nbands})\n\n    # Convert array to raster\n    stacked_image = array2raster(stacked_array, meta)\n\n    return stacked_image\n</code></pre>"},{"location":"raster/#geonate.raster.mask","title":"<code>mask(input, reference, input_meta=None, reference_meta=None, invert=False, nodata=0, output=None)</code>","text":"<p>Mask raster opened by rasterio by shapefile vector or another image</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Image or data array input that need to crop</p> required <code>reference</code> <code>DatasetReader | GeoDataFrame | np.ndarray</code> <p>Region of interest, shapefile opened by geopandas or another image or data array to crop</p> required <code>input_meta</code> <code>Dict</code> <p>Metadata when input is data array. Defaults to None.</p> <code>None</code> <code>reference_meta</code> <code>Dict</code> <p>Metadata when reference is data array. Defaults to None.</p> <code>None</code> <code>invert</code> <code>bool</code> <p>If True, pixels inside shapefile will be masked. Defaults to False.</p> <code>False</code> <code>nodata</code> <code>int</code> <p>Any number to fill nodata pixels outside the ROI. Defaults to 0.</p> <code>0</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image </p> Source code in <code>geonate/raster.py</code> <pre><code>def mask(input, reference, input_meta: Optional[Dict]=None, reference_meta: Optional[Dict]=None, invert=False, nodata=0, output: Optional[AnyStr]=None):\n    \"\"\"Mask raster opened by rasterio by shapefile vector or another image\n\n    Args:\n        input (DatasetReader | np.ndarray): Image or data array input that need to crop\n        reference (DatasetReader | GeoDataFrame | np.ndarray): Region of interest, shapefile opened by geopandas or another image or data array to crop\n        input_meta (Dict, optional): Metadata when input is data array. Defaults to None.\n        reference_meta (Dict, optional): Metadata when reference is data array. Defaults to None.\n        invert (bool, optional): If True, pixels inside shapefile will be masked. Defaults to False.\n        nodata (int, optional): Any number to fill nodata pixels outside the ROI. Defaults to 0.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image \n\n    \"\"\"\n    import os\n    import rasterio\n    import shapely\n    from shapely.geometry import mapping\n    import geopandas as gpd\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            if not os.path.exists('./tmp/'):\n                os.makedirs('./tmp/')\n            writeRaster(input, './tmp/tmp.tif', input_meta)\n            input_image = raster.rast('./tmp/tmp.tif')\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Define boundary\n    if (isinstance(reference, gpd.GeoDataFrame)):\n        poly = reference\n        transform_poly = reference.transform\n        crs_poly = reference.crs\n    else:\n        if isinstance(reference, rasterio.DatasetReader):\n            ds_reference = reference.read(1)\n            transform_poly = reference.meta['transform']\n            crs_poly = reference.meta['crs']\n        elif isinstance(reference, np.ndarray):\n            ds_reference = reference[1, : , : ]\n            transform_poly = reference_meta['transform']\n            crs_poly = reference_meta['crs']\n        else:\n            raise ValueError('Data is not supported')\n\n        masked = np.where(np.isnan(ds_reference), np.nan, 1)\n        masked_convert = masked.astype(np.float32)\n\n        shp = rasterio.features.shapes(masked_convert, mask= ~np.isnan(masked_convert), transform= transform_poly)\n        poly = []\n        values = []\n\n        for shape, value in shp:\n            if value == 1:\n                poly.append(shapely.geometry.shape(shape))\n                values.append(value)\n\n        poly = gpd.GeoDataFrame({'geometry': poly, 'value': values})\n        poly.set_crs(crs_poly.to_string(), inplace=True)\n\n    ### Define nodata\n    if nodata is None:\n        dataType = input_image.meta['dtype']\n        if dataType.lower() == 'int8':\n            nodata_value = 127\n        elif dataType.lower() == 'uint8':\n            nodata_value = 255\n        elif dataType.lower() == 'int16':\n            nodata_value = 32767\n        elif dataType.lower() == 'uint16':\n            nodata_value = 65535\n        elif dataType.lower() == 'int32':\n            nodata_value = 2147483647\n        elif dataType.lower() == 'uint32':\n            nodata_value == 4294967295\n        elif dataType.lower() == 'float16':\n            nodata_value = 65500\n        elif dataType.lower() == 'float32':\n            nodata_value == 999999\n        else:\n            nodata_value == 0\n    else:\n        nodata_value = nodata        \n\n    ### Invert mask\n    if invert is True:\n        masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, invert=True, nodata=nodata_value)\n    else:\n        masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, nodata= nodata_value)\n\n    meta  = input_image.meta\n    meta.update({\n        'height': masked_img.shape[1],\n        'width': masked_img.shape[2],\n        'transform': geotranform,\n        'dtype': np.float32,\n        'nodata': nodata_value})\n\n    # Write output\n    if output is not None:\n        writeRaster(masked_img, output, meta)\n    else:\n        return masked_img, meta\n</code></pre>"},{"location":"raster/#geonate.raster.match","title":"<code>match(input, reference, method='near', input_meta=None, reference_meta=None)</code>","text":"<p>Match input image to the reference image in terms of projection, resolution, and bound extent. It returns image within the bigger boundary.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio objective or data array needs to match </p> required <code>reference</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio object or data array taken as reference to match the input image</p> required <code>method</code> <code>AnyStr</code> <p>String defines resampling method (if applicable) to resample if having different resolution (Method similar to resample). Defaults to 'near'.</p> <code>'near'</code> <code>input_meta</code> <code>Dict</code> <p>Metadata of input required when input is data array. Defaults to None.</p> <code>None</code> <code>reference_meta</code> <code>Dict</code> <p>Metadata of reference required when reference is data array. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def match(input, reference, method: AnyStr='near', input_meta: Optional[Dict]=None, reference_meta: Optional[Dict]=None):\n    \"\"\"Match input image to the reference image in terms of projection, resolution, and bound extent. It returns image within the bigger boundary.\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio objective or data array needs to match \n        reference (DatasetReader | np.ndarray): Rasterio object or data array taken as reference to match the input image\n        method (AnyStr, optional): String defines resampling method (if applicable) to resample if having different resolution (Method similar to resample). Defaults to 'near'.\n        input_meta (Dict, optional): Metadata of input required when input is data array. Defaults to None.\n        reference_meta (Dict, optional): Metadata of reference required when reference is data array. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    from rasterio.transform import from_bounds\n    import numpy as np\n    from .common import get_extent_local\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            input_image = input\n            meta = input_meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Define reference image\n    if isinstance(reference, rasterio.DatasetReader):\n        reference_image = reference.read()\n        meta_reference = reference.meta\n    # input is array\n    elif isinstance(reference, np.ndarray):\n        if reference_meta is None:\n            raise ValueError('It requires metadata of reference')\n        else:\n            reference_image = reference\n            meta_reference = reference_meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Check some conditions\n    if meta[\"crs\"] != meta_reference['crs']:\n        print('Input and reference images have different Projection')\n        print('Output projection will take the reference projection')\n    if meta['transform'][0] != meta_reference['transform'][0]:\n        print('Input and reference images have different resolution')\n        print('Ouput resolution will take the reference resolution')     \n\n    # get general extent from two images\n    ext_input = get_extent_local(input_image)[0]\n    ext_reference = get_extent_local(reference_image)[0]\n\n    ext = ext_input\n    ext = (\n        min(ext[0], ext_reference[0]),\n        min(ext[1], ext_reference[1]),\n        max(ext[2], ext_reference[2]),\n        max(ext[3], ext_reference[3])\n        )\n\n    # calculate new height and width\n    resolution = meta_reference['transform'][0]    \n    width_new = int((ext[2]  - ext[0]) / resolution)\n    height_new = int((ext[3] - ext[1]) / resolution)\n\n    # calculate new transform\n    transform_new = from_bounds(ext[0], ext[1], ext[2], ext[3], width_new, height_new)\n\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # Reproject to match\n    if len(input_image.shape) &gt; 2:\n        nbands = input_image.shape[0]\n    else:\n        nbands = 1\n\n    matched = np.empty((nbands, height_new, width_new), dtype=np.float32)\n    for band in range(0, nbands):\n        if nbands &lt;= 1:\n            ds = input_image\n        else:\n            ds = input_image[band, : , : ]\n        warp.reproject(source=ds, destination=matched[band, :, :], src_transform= meta['transform'], dst_transform= transform_new, src_crs=meta['crs'], dst_crs=meta_reference['crs'], resampling= resampleAlg)\n\n    # match out other values\n    match_masked = np.where(matched == 0, np.nan, matched)\n    match_masked = match_masked.astype(np.float32)\n\n    # update metadata\n    meta_update = meta.copy()\n    meta_update.update({\n        'crs': meta_reference['crs'],\n        'transform': transform_new,\n        'width': width_new,\n        'height': height_new,\n        'dtype': np.float32\n    })\n\n    return match_masked, meta_update\n</code></pre>"},{"location":"raster/#geonate.raster.merge","title":"<code>merge(input)</code>","text":"<p>Merges multiple raster files into a single raster file by computing the average values at overlapped areas.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>List of input raster files.</p> required <p>Returns:</p> Type Description <code>A merged raster (raster)</code> <p>The merged raster file.</p> Source code in <code>geonate/raster.py</code> <pre><code>def merge(input: list):\n    \"\"\"\n    Merges multiple raster files into a single raster file by computing the average values at overlapped areas.\n\n    Args:\n        input (list): List of input raster files.\n\n    Returns:\n        A merged raster (raster): The merged raster file.\n\n    \"\"\"\n    from rasterio import merge \n    from .common import array2raster\n\n    # Initialize empty list to store all input files and stack input into it \n    merged_files = []\n    for tmp in input:\n        merged_files.append(tmp)\n\n    # Compute sum and count numbers of images, and average values at overlapped areas\n    mosaic_sum, out_trans = merge.merge(merged_files, method= merge.copy_sum)\n    mosaic_count, out_trans = merge.merge(merged_files, method= merge.copy_count)\n    mosaic_average = mosaic_sum / mosaic_count\n\n    # Update metadata with new transform and image dimensions\n    meta = merged_files[0].meta\n    meta.update({\"driver\": \"GTiff\",\n                            \"height\": mosaic_average.shape[1],\n                            \"width\": mosaic_average.shape[2],\n                            \"transform\": out_trans})\n\n    # Convert array to raster file\n    merged_raster = array2raster(mosaic_average, meta)\n\n    return merged_raster    \n</code></pre>"},{"location":"raster/#geonate.raster.mergeVRT","title":"<code>mergeVRT(input, output, compress=True, silent=True)</code>","text":"<p>Merge multiple geotif files using gdal VRT for better performance speed</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>List of input geotif files</p> required <code>output</code> <code>AnyStr</code> <p>Path of output tif file</p> required <code>compress</code> <code>bool</code> <p>Whether compress the output data or not. Defaults to True.</p> <code>True</code> <code>silent</code> <code>bool</code> <p>Show or do not show file processing log. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any local variable. It writes raster file to local drive.</p> Source code in <code>geonate/raster.py</code> <pre><code>def mergeVRT(input: AnyStr, output: AnyStr, compress: bool=True, silent=True):\n    \"\"\"Merge multiple geotif files using gdal VRT for better performance speed\n\n    Args:\n        input (list): List of input geotif files\n        output (AnyStr): Path of output tif file\n        compress (bool, optional): Whether compress the output data or not. Defaults to True.\n        silent (bool, optional): Show or do not show file processing log. Defaults to True.\n\n    Return:\n        None: The function does not return any local variable. It writes raster file to local drive.\n\n    \"\"\"\n    import os\n    from osgeo import gdal\n    #  Create a temp vrt file\n    vrt_file = 'merged.vrt'\n\n    if compress is True:\n        vrt_options = gdal.BuildVRTOptions()\n        gdal.BuildVRT(vrt_file, input, options=vrt_options)\n        gdal.Translate(output, vrt_file, format='GTiff', creationOptions=['COMPRESS=LZW'])\n\n    else:\n        gdal.BuildVRT(vrt_file, input)\n        gdal.Translate(output, vrt_file)\n\n    os.remove(vrt_file)\n    if silent is True:\n        pass\n    else:\n        print(f\"Finished merge raster files, the output is at {output}\")\n</code></pre>"},{"location":"raster/#geonate.raster.normalized","title":"<code>normalized(input, meta=None, output=None)</code>","text":"<p>Normalize raster data to rearrange raster values from 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>meta</code> <code>AnyStr</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def normalized(input, meta: Optional[AnyStr]=None, output: Optional[AnyStr]=None):\n    \"\"\"Normalize raster data to rearrange raster values from 0 to 1\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        meta (AnyStr, optional): Metadata in case input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Please provide input metadata')\n        else:\n            dataset = input\n            meta = meta\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Find max min values\n    maxValue = np.nanmax(dataset)\n    minValue = np.nanmin(dataset)\n\n    ### Create empty data array to store output\n    normalized = np.zeros_like(dataset, dtype=np.float32)\n\n    ### Run normalization\n    for i in range(0, dataset.shape[0]):\n        band = dataset[i, : , : ]\n        band_norm = (band.astype(float)  - minValue) / (maxValue  - minValue)\n        normalized[i, : , : ] = band_norm\n        band_norm = None\n\n    ### update meta\n    meta.update({'dtype': np.float32})\n\n    ### return result \n    # Write output\n    if output is not None:\n        writeRaster(normalized, output, meta)\n    else:\n        return normalized, meta\n</code></pre>"},{"location":"raster/#geonate.raster.normalizedDifference","title":"<code>normalizedDifference(input, band1, band2, meta=None, output=None)</code>","text":"<p>Calculate normalized difference index</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio object or data array, input with multiple bands.</p> required <code>band1</code> <code>numeric</code> <p>Order of the first band in the input.</p> required <code>band2</code> <code>numeric</code> <p>Order of the second band in the input.</p> required <code>meta</code> <code>Dict</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def normalizedDifference(input, band1, band2, meta: Optional[Dict]=None, output: Optional[AnyStr]=None):\n    \"\"\"Calculate normalized difference index\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio object or data array, input with multiple bands.\n        band1 (numeric): Order of the first band in the input.\n        band2 (numeric): Order of the second band in the input.\n        meta (Dict, optional): Metadata in case input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            dataset = input\n            meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Extract data\n    ds_band1 = dataset[band1+1, : , : ]\n    ds_band2 = dataset[band2+1, : , : ]\n\n    # calculate index\n    normalized_index  = (ds_band1.astype(float) - ds_band2.astype(float)) / (ds_band1 + ds_band2)\n    normalized_index = normalized_index.astype(np.float32)\n    # remove outliers\n    normalized_index[(normalized_index &lt; -1) | (normalized_index &gt; 1)] = np.nan\n\n    meta.update({'dtype': np.float32})\n\n    # Write output\n    if output is not None:\n        writeRaster(normalized_index, output, meta)\n    else:\n        return normalized_index, meta\n</code></pre>"},{"location":"raster/#geonate.raster.rast","title":"<code>rast(input, show_meta=False, **kwargs)</code>","text":"<p>Open a single geotif raster file using Rasterio</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AnyStr</code> <p>The file path indicates location of geotif file</p> required <code>show_meta</code> <code>bool</code> <p>Whether to show the image metadata. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>optional</code> <p>All parameters in rasterio.open()</p> <code>{}</code> <p>Returns:</p> Type Description <code>Raster object (raster)</code> <p>Rasterio RasterReader object</p> Source code in <code>geonate/raster.py</code> <pre><code>def rast(input: AnyStr, show_meta: Optional[bool]=False, **kwargs):\n    \"\"\"Open a single geotif raster file using Rasterio\n\n    Args:\n        input (AnyStr): The file path indicates location of geotif file\n        show_meta (bool, optional): Whether to show the image metadata. Defaults to False.\n        **kwargs (optional): All parameters in rasterio.open()\n\n    Returns:\n        Raster object (raster): Rasterio RasterReader object\n\n    \"\"\"    \n    import rasterio\n    import os\n\n    img = rasterio.open(input, **kwargs)\n    basename = os.path.basename(input)\n\n    # show meta \n    if show_meta is True:\n        meta = img.meta\n        print(f\"Opening: {basename}\\n{meta}\")\n\n    return img    \n</code></pre>"},{"location":"raster/#geonate.raster.reclassify","title":"<code>reclassify(input, breakpoints, classes, meta=None, output=None)</code>","text":"<p>Reclassify image with discrete or continuous values</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Raster or data array input</p> required <code>breakpoints</code> <code>list</code> <p>Number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]</p> required <code>classes</code> <code>list</code> <p>Number list, define classes, number of classes equal number of breakpoints minus 1</p> required <code>meta</code> <code>Dict</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def reclassify(input, breakpoints, classes, meta: Optional[Dict]=None, output: Optional[AnyStr]=None):\n    \"\"\"Reclassify image with discrete or continuous values\n\n    Args:\n        input (DatasetReader | np.ndarray): Raster or data array input\n        breakpoints (list): Number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]\n        classes (list): Number list, define classes, number of classes equal number of breakpoints minus 1\n        meta (Dict, optional): Metadata in case input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n\n    ### Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        if len(input.shape) == 2:\n            dataset = input.read()\n            meta = input.meta\n        elif len(input.shape) == 3:\n            if  input.shape[0] &gt; 1:\n                raise ValueError('Input data has more than one band')\n            else:\n                dataset = input.read(1)\n                meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            if (len(input.shape)) &gt; 2 and (input.shape[0] &gt; 1):\n                raise ValueError('Input data has more than one band')\n            else:\n                dataset = input\n                meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ####\n    # Create unique values and empty data array to store reclassified result \n    uniques = np.unique(dataset)\n    reclassified = np.zeros_like(dataset)\n\n    ####\n    # If image has discrete values\n    if len(uniques) == len(classes): \n        if len(breakpoints) == len(classes):\n            for i in range(len(classes)):\n                reclassified[dataset == breakpoints[i]] = classes[i]\n        elif len(breakpoints) == (len(classes)-1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n    # If image has continuous values\n    else:\n        if len(breakpoints) == (len(classes)+1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n\n    # Write output\n    if output is not None:\n        writeRaster(reclassified, output, meta)\n    else:\n        return reclassified, meta\n</code></pre>"},{"location":"raster/#geonate.raster.reproject","title":"<code>reproject(input, reference=None, method='near', res=None)</code>","text":"<p>Reprojects and resamples a given raster image to a specified coordinate reference system (CRS) and resolution.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>rasterio.io.DatasetReader</code> <p>The input raster image to be reprojected.</p> required <code>reference</code> <code>Optional[AnyStr]</code> <p>The reference CRS for reprojection. It can be a string (e.g., 'EPSG:4326') or a rasterio DatasetReader object. If None, the input CRS is used.</p> <code>None</code> <code>method</code> <code>Optional[AnyStr]</code> <p>The resampling method to use. Default is 'near'. Supported methods include 'nearest', 'average', 'max', 'min', 'median', 'mode', 'q1', 'q3', 'rms', 'sum', 'cubic', 'cubic_spline', 'bilinear', 'gauss', 'lanczos'.</p> <code>'near'</code> <code>res</code> <code>Optional[float]</code> <p>The output resolution. If None, the input resolution is used.</p> <code>None</code> <p>Returns:</p> Type Description <code>rasterio.io.DatasetReader</code> <p>The reprojected raster image</p> Source code in <code>geonate/raster.py</code> <pre><code>def reproject(input, reference:Optional[AnyStr]=None, method: Optional[AnyStr]='near', res: Optional[float]=None):\n    \"\"\"\n    Reprojects and resamples a given raster image to a specified coordinate reference system (CRS) and resolution.\n\n    Args:\n        input (rasterio.io.DatasetReader): The input raster image to be reprojected.\n        reference (Optional[AnyStr]): The reference CRS for reprojection. It can be a string (e.g., 'EPSG:4326') or a rasterio DatasetReader object. If None, the input CRS is used.\n        method (Optional[AnyStr]): The resampling method to use. Default is 'near'. Supported methods include 'nearest', 'average', 'max', 'min', 'median', 'mode', 'q1', 'q3', 'rms', 'sum', 'cubic', 'cubic_spline', 'bilinear', 'gauss', 'lanczos'.\n        res (Optional[float]): The output resolution. If None, the input resolution is used.\n\n    Returns:\n        rasterio.io.DatasetReader: The reprojected raster image\n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    import numpy as np\n    from .common import array2raster\n\n    ### Define input image\n    input_image = input.read()\n    meta = input.meta\n    left, bottom, right, top = input.bounds\n\n    # If reference is not given, it will take the CRS from input. The function now used for resampling\n    if reference is None:\n        dst_crs = meta['crs']\n        if res is None:\n            xsize, ysize = xsize, ysize = meta['transform'][0], meta['transform'][0]\n        else:\n            xsize, ysize = res, res\n        transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n\n    # string of EPSG\n    elif isinstance(reference, str):\n        dst_crs = reference\n        if res is None:\n            raise ValueError('Please provide output resolution')\n        else:\n            xsize, ysize = res, res\n        transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n\n    # Take all paras from reference image\n    elif isinstance(reference, rasterio.DatasetReader):\n        dst_crs = reference.crs\n        if res is None:\n            xsize, ysize = reference.res\n        else:\n            xsize, ysize = res, res\n        transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n\n    # Other cases\n    else:\n        raise ValueError('Please define correct reference, it is CRS string or an image reference')\n\n    # Update metadata\n    meta_update = meta.copy()\n    meta_update.update({\n        'crs': dst_crs,\n        'transform': transform,\n        'width': width,\n        'height': height,\n    })\n\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # Running reproject \n    projected_array = np.empty((input_image.shape[0], height, width), dtype= meta['dtype'])\n    for band in range(0, input_image.shape[0]):\n        ds = input_image[band, : , : ]\n        warp.reproject(source=ds, destination=projected_array[(band), :, :], src_transform= meta['transform'], dst_transform=transform, src_crs=meta['crs'], dst_crs=dst_crs, resampling= resampleAlg)\n\n    # Convert array back to raster\n    reprojected = array2raster(projected_array, meta_update)\n\n    return reprojected\n</code></pre>"},{"location":"raster/#geonate.raster.resample","title":"<code>resample(input, factor, resample, method='near', meta=None, output=None)</code>","text":"<p>Resample raster image based on factor (not the target resolution)</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Input rasterio image or data array</p> required <code>factor</code> <code>numeric</code> <p>Resampling factor compare to origin image (e.g., 2, 4, 6)</p> required <code>resample</code> <code>AnyStr</code> <p>Resample method [\"aggregate\", \"disaggregate\"]</p> required <code>method</code> <code>str</code> <p>Resampling method (if changing resolution), optional, default method is 'nearest neighbor', other methods are at rasterio.Resampling. (e.g., nearest, cubic, bilinear, average). Defaults to 'near'.</p> <code>'near'</code> <code>meta</code> <code>Dict</code> <p>Required metadata when input is data array. Defaults to None.</p> <code>None</code> <code>output</code> <code>AnyStr</code> <p>File path to write out geotif file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>np.darray</code> <p>Data array contains all image pixel values metadata: Metedata of the image</p> Source code in <code>geonate/raster.py</code> <pre><code>def resample(input, factor, resample: AnyStr, method='near', meta: Optional[Dict]=None, output: Optional[AnyStr]=None):\n    \"\"\"Resample raster image based on factor (not the target resolution)\n\n    Args:\n        input (DatasetReader | np.ndarray): Input rasterio image or data array\n        factor (numeric): Resampling factor compare to origin image (e.g., 2, 4, 6)\n        resample (AnyStr): Resample method [\"aggregate\", \"disaggregate\"]\n        method (str, optional): Resampling method (if changing resolution), optional, default method is 'nearest neighbor', other methods are at rasterio.Resampling. (e.g., nearest, cubic, bilinear, average). Defaults to 'near'.\n        meta (Dict, optional): Required metadata when input is data array. Defaults to None.\n        output (AnyStr, optional): File path to write out geotif file to local directory. Defaults to None.\n\n    Returns:\n        np.darray: Data array contains all image pixel values\n        metadata: Metedata of the image\n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    import numpy as np\n    from .common import get_extent_local\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n        left, bottom, right, top = input.bounds\n        nbands = input.count\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            dataset = input\n            meta = meta\n            left, bottom, right, top = get_extent_local(dataset, meta)[0]\n            if len(dataset.shape) &gt; 2:\n                nbands = dataset.shape[0]\n            else:\n                nbands = 1\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    #### Calculate new rows and columns\n    if (resample.lower() == 'aggregate') or (resample.lower() == 'agg') or (resample.lower() == 'a'):\n        new_height = meta['height'] // factor\n        new_width = meta['width'] // factor\n    elif (resample.lower() == 'disaggregate') or (resample.lower() == 'disagg') or (resample.lower() == 'd'):\n        new_height = meta['height'] * factor\n        new_width = meta['width'] * factor\n    else:\n        raise ValueError('Resample method is not supported [\"aggregate\", \"disaggregate\"]')\n\n    transform_new, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=meta['crs'], width=new_width, height=new_height, left=left, bottom=bottom, right=right, top=top)\n\n# Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # Define the metadata for the destination raster\n    metadata = meta.copy()\n    metadata.update({\n        'transform': transform_new,\n        'width': new_width,\n        'height': new_height, \n        'dtype': np.float32\n    })\n\n    resampled = np.empty((nbands, new_height, new_width), dtype=np.float32)\n    for band in range(0, nbands):\n        if nbands &lt;= 1:\n            ds = dataset\n        else:\n            ds = dataset[band, : , : ]\n        warp.reproject(source=ds, destination=resampled[band, :, :], src_transform= meta['transform'], dst_transform= transform_new, src_crs=meta['crs'], dst_crs=input.crs, resampling= resampleAlg)\n\n    # Write output\n    if output is not None:\n        writeRaster(resampled, output, metadata)\n    else:\n        return resampled, metadata\n</code></pre>"},{"location":"raster/#geonate.raster.values","title":"<code>values(input, meta=None, na_rm=True, names=None, prefix=None)</code>","text":"<p>Extract all pixel values of image and create dataframe from them, each band is a column</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array.</p> required <code>meta</code> <code>AnyStr</code> <p>Metadata in case input is data array. Defaults to None.</p> <code>None</code> <code>na_rm</code> <code>bool</code> <p>Remove or do not remove NA value from output dataframe. Defaults to True.</p> <code>True</code> <code>names</code> <code>list</code> <p>Given expected names for each column in the dataframe, if not, default name will be assigned. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>AnyStr</code> <p>Given character before each band name. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe stores all pixel values across all image bands.</p> Source code in <code>geonate/raster.py</code> <pre><code>def values(input, meta: Optional[AnyStr]=None, na_rm: Optional[bool]=True, names: Optional[list]=None, prefix: Optional[AnyStr]=None):\n    \"\"\"Extract all pixel values of image and create dataframe from them, each band is a column\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array.\n        meta (AnyStr, optional): Metadata in case input is data array. Defaults to None.\n        na_rm (bool, optional): Remove or do not remove NA value from output dataframe. Defaults to True.\n        names (list, optional): Given expected names for each column in the dataframe, if not, default name will be assigned. Defaults to None.\n        prefix (AnyStr, optional): Given character before each band name. Defaults to None.\n\n    Returns:\n        DataFrame: Dataframe stores all pixel values across all image bands.\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            dataset = input\n            meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ########\n    nbands = dataset.shape[0]\n    bands_array = [dataset[band, : , : ].flatten() for band in range(0, nbands)]\n\n    if names is not None:\n        if len(names) != nbands:\n            raise ValueError('Length of name should be equal to number of bands')\n        else:\n            if prefix is None:\n                data = pd.DataFrame(np.array(bands_array).T, columns=names)\n            else:\n                names_new = [f'{prefix}{name}' for name in names]\n                data = pd.DataFrame(np.array(bands_array).T, columns=names_new)\n    else:\n        if prefix is None:\n            data = pd.DataFrame(np.array(bands_array).T, columns=[f'B{i}' for i in range(1,nbands +1)])\n        else:\n            data = pd.DataFrame(np.array(bands_array).T, columns=[f'{prefix}{i}' for i in range(1, nbands +1)])\n\n    ####### \n    # Remove NA values or not\n    if na_rm is True: \n        data_out = data.dropna().reset_index(drop=True)\n    else:\n        data_out = data\n\n    return data_out\n</code></pre>"},{"location":"raster/#geonate.raster.vect","title":"<code>vect(input, show_meta=False, **kwargs)</code>","text":"<p>Read shapefile vector file using Geopandas </p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AnyStr</code> <p>The file path indicates location of shapefile </p> required <code>show_meta</code> <code>bool</code> <p>Whether to show the image metadata. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>optional</code> <p>All parameters in gpd.read_file()</p> <code>{}</code> <p>Returns:</p> Type Description <code>Shapefile (geodataframe)</code> <p>Geodataframe of shapefile with attributes from geopandas object</p> Source code in <code>geonate/raster.py</code> <pre><code>def vect(input: AnyStr, show_meta: Optional[bool]=False, **kwargs):\n    \"\"\"Read shapefile vector file using Geopandas \n\n    Args:\n        input (AnyStr): The file path indicates location of shapefile \n        show_meta (bool, optional): Whether to show the image metadata. Defaults to False.\n        **kwargs (optional): All parameters in gpd.read_file()\n\n    Returns:\n        Shapefile (geodataframe): Geodataframe of shapefile with attributes from geopandas object\n\n    \"\"\"\n    import geopandas as gpd\n    import os\n\n    vect = gpd.read_file(input, **kwargs)\n\n    # show meta \n    if show_meta is True:\n        basename = os.path.basename(input)\n        crs = vect.crs\n        datashape = vect.shape\n        print(f\"Opening: {basename}\\n Projection (crs): {crs}\\n Data shape: {datashape}\")\n\n    return vect\n</code></pre>"},{"location":"raster/#geonate.raster.writeRaster","title":"<code>writeRaster(input, output, meta=None, compress='lzw')</code>","text":"<p>Write raster Geotif from Raster or Data Array using Rasterio</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | array</code> <p>Raster or Data array in form of [band, height, width]</p> required <code>output</code> <code>AnyStr</code> <p>Output file path</p> required <code>meta</code> <code>Dict</code> <p>Rasterio profile settings needed when input is dataArray. Defaults to None.</p> <code>None</code> <code>compress</code> <code>AnyStr</code> <p>Compression algorithm ['lzw', 'deflate']. Defaults to 'lzw'.</p> <code>'lzw'</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any local variable. It writes raster file to local drive (.tif).</p> Source code in <code>geonate/raster.py</code> <pre><code>def writeRaster(input, output, meta: Optional[Dict]=None, compress: Optional[AnyStr] = 'lzw'):\n    \"\"\"Write raster Geotif from Raster or Data Array using Rasterio\n\n    Args:\n        input (raster | array): Raster or Data array in form of [band, height, width]\n        output (AnyStr): Output file path\n        meta (Dict, optional): Rasterio profile settings needed when input is dataArray. Defaults to None.\n        compress (AnyStr, optional): Compression algorithm ['lzw', 'deflate']. Defaults to 'lzw'.\n\n    Returns:\n        None: The function does not return any local variable. It writes raster file to local drive (.tif).\n\n    \"\"\"   \n    import rasterio\n    import numpy as np\n\n    # Input is rasterio image\n    if isinstance(input, rasterio.DatasetReader):\n        meta_out = input.meta\n        data_array = input.read()\n\n        # compress data or not\n        if compress is None:\n            meta_out = meta_out\n        else:\n            if compress.lower() == 'deflate':\n                meta_out.update({'compress': 'deflate'})\n            elif compress.lower() == 'lzw':\n                meta_out.update({'compress': 'lzw'})\n            else:\n                raise ValueError('Compress method is not supported')\n\n        # output has single band\n        if len(data_array.shape) == 2:\n            meta_out['count'] = int(1)\n            with rasterio.open(output, 'w', **meta_out) as dst:\n                for band in range(0, 1):\n                    data = data_array\n                    dst.write(data, band + 1)\n        # output has multi bands\n        else:\n            meta_out['count'] = int(data_array.shape[0])\n            with rasterio.open(output, 'w', **meta_out) as dst:\n                for band in range(0, int(data_array.shape[0])):\n                    data = data_array[band, : , : ]\n                    dst.write(data, band + 1)\n\n    # input is data array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Input is dataArray, please give metadata profile')\n        else:        \n        # compress data or not\n            if compress is None:\n                meta = meta\n            else:\n                if compress.lower() == 'deflate':\n                    meta.update({'compress': 'deflate'})\n                elif compress.lower() == 'lzw':\n                    meta.update({'compress': 'lzw'})\n                else:\n                    raise ValueError('Compress method is not supported')\n\n            # output has single band\n            if len(input.shape) == 2:\n                meta['count'] = int(1)\n                with rasterio.open(output, 'w', **meta) as dst:\n                    for band in range(0, 1):\n                        data = input\n                        dst.write(data, band + 1)\n            # output has multi bands\n            else:\n                meta['count'] = int(input.shape[0])\n                with rasterio.open(output, 'w', **meta) as dst:\n                    for band in range(0, int(input.shape[0])):\n                        data = input[band, : , : ]\n                        dst.write(data, band + 1)\n    else:\n        raise ValueError('Input data is not supported')    \n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geonate in a project:</p> <pre><code>import geonate\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>from geonate import common, raster\n</pre> from geonate import common, raster"}]}