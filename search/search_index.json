{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geonate","text":"<p>Python package synthesizes conventional tools and codes for image processing</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://canng.github.io/geonate</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>TODO</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/canng/geonate/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geonate could always use more documentation, whether as part of the official geonate docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/canng/geonate/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geonate for local development.</p> <ol> <li> <p>Fork the geonate repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geonate.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geonate\n$ cd geonate/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geonate tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/canng/geonate/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geonate/","title":"geonate module","text":"<p>Main module.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geonate, run this command in your terminal:</p> <pre><code>pip install geonate\n</code></pre> <p>This is the preferred method to install geonate, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geonate from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/canng/geonate\n</code></pre>"},{"location":"raster/","title":"raster module","text":""},{"location":"raster/#geonate.raster.cellSize","title":"<code>cellSize(input, unit='km', meta=None, output=None)</code>","text":"<p>Calculate pixel size (area), the input has to be in the projection of 'EPSG:4326'. If not, it can be reprojected by \"project\" function</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>rasterio image or data array</p> required <code>unit</code> <code>~AnyStr</code> <p>string, default is \"km\", the unit to calculate area</p> <code>'km'</code> <code>meta</code> <code>Optional[~AnyStr]</code> <p>optional dict, metadata in case input is data array</p> <code>None</code> <code>output</code> <code>Optional[~AnyStr]</code> <p>Optional string, whether write out geotif file to local directory</p> <code>None</code> <p>Examples:</p> <p>img = raster.rast('./Sample_data/temperature.tif') cellArea, meta = raster.cellSize(img, unit='km)    </p> Source code in <code>geonate/raster.py</code> <pre><code>def cellSize(input, unit: AnyStr='km', meta: Optional[AnyStr]=None, output: Optional[AnyStr]=None):\n    '''\n    Calculate pixel size (area), the input has to be in the projection of 'EPSG:4326'. If not, it can be reprojected by \"project\" function\n\n    Parameters:\n        input: rasterio image or data array\n        unit: string, default is \"km\", the unit to calculate area\n        meta: optional dict, metadata in case input is data array\n        output: Optional string, whether write out geotif file to local directory\n\n    Example:\n       img = raster.rast('./Sample_data/temperature.tif')\n       cellArea, meta = raster.cellSize(img, unit='km)    \n\n    '''\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        if len(input.shape) == 2:\n            dataset = input.read()\n            meta = input.meta\n        else:\n            dataset = input.read(1)\n            meta = input.meta\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Please provide input metadata')\n        else:\n            if len(input) &gt; 2:\n                dataset = input[0, :, : ]\n            else:\n                dataset = input\n            meta = meta\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Read metadata\n    transform = meta['transform']\n    pix_width = transform[0]\n    upper_X = transform[2]\n    upper_Y = transform[5]\n    rows = meta['height']\n    cols = meta['width']\n    lower_X = upper_X + transform[0] * cols\n    lower_Y = upper_Y + transform[4] * rows\n\n    lats = np.linspace(upper_Y, lower_Y, rows + 1)\n\n    a = 6378137.0  # Equatorial radius\n    b = 6356752.3142  # Polar radius\n\n    # Degrees to radians\n    lats = lats * np.pi/180\n\n    # Intermediate vars\n    e = np.sqrt(1-(b/a)**2)\n    sinlats = np.sin(lats)\n    zm = 1 - e * sinlats\n    zp = 1 + e * sinlats\n\n    # Distance between meridians\n    q = pix_width/360\n\n    # Compute areas for each latitude in square km\n    areas_to_equator = np.pi * b**2 * ((2*np.arctanh(e*sinlats) / (2*e) + sinlats / (zp*zm))) / 10**6\n    areas_between_lats = np.diff(areas_to_equator)\n    areas_cells = np.abs(areas_between_lats) * q\n\n    # Create empty array to store output\n    cellArea = np.zeros_like(dataset, dtype=np.float32)\n\n    # Assign estimated cell area to every pixel\n    if len(cellArea.shape) == 2:\n        for i in range(0, cellArea.shape[1]):\n            cellArea[:, i] = areas_cells.flatten()\n    else:\n        for i in range(0, cellArea.shape[2]):\n            cellArea[:, :, i] = areas_cells.flatten()\n\n    ### Update metadata\n    meta.update({'dtype': np.float32, 'count': 1})\n\n    ### Convert unit (if applicable)\n    if (unit.lower() == 'km') or (unit.lower() == 'kilometer'):\n        outArea = cellArea\n    elif (unit.lower() == 'm') or (unit.lower() == 'meter'):\n        outArea = cellArea * 1_000_000\n    elif (unit.lower() == 'ha') or (unit.lower() == 'hectare'):\n        outArea = cellArea * 10_000\n\n    # Write output\n    if output is not None:\n        writeRaster(outArea, output, meta)\n    else:\n        return outArea, meta\n</code></pre>"},{"location":"raster/#geonate.raster.crop","title":"<code>crop(input, reference, input_meta=None, reference_meta=None, invert=False, nodata=None, output=None)</code>","text":"<p>Crop raster opened by rasterio by shapefile vector or another image</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>image or data array input that need to crop</p> required <code>reference</code> <p>region of interest, shapefile opened by geopandas or another image or data array to crop</p> required <code>input_meta</code> <code>Optional[Dict]</code> <p>Optional metadata when input is data array</p> <code>None</code> <code>reference_meta</code> <code>Optional[Dict]</code> <p>Optional metadata when reference is data array</p> <code>None</code> <code>invert</code> <p>bool, if True, pixels inside shapefile will be masked </p> <code>False</code> <code>output</code> <code>Optional[~AnyStr]</code> <p>Optional string, whether write out geotif file to local directory</p> <code>None</code> <p>Examples:</p> <p>img = rasterio.open('./landsat_multi/landsat_img_test.tif', 'r') roi = gpd.read_file('./roi/roi.shp') clipped, meta = raster.crop(img, roi)</p> <p>import earthpy.plot as ep ep.plot_rgb(clipped, stretch=True, rgb=(3,2,1))</p> Source code in <code>geonate/raster.py</code> <pre><code>def crop(input, reference, input_meta: Optional[Dict]=None, reference_meta: Optional[Dict]=None, invert=False, nodata=None, output: Optional[AnyStr]=None):\n    '''\n    Crop raster opened by rasterio by shapefile vector or another image\n\n    Parameters:\n        input: image or data array input that need to crop\n        reference: region of interest, shapefile opened by geopandas or another image or data array to crop\n        input_meta: Optional metadata when input is data array\n        reference_meta: Optional metadata when reference is data array\n        invert: bool, if True, pixels inside shapefile will be masked \n        output: Optional string, whether write out geotif file to local directory\n\n    Example:\n        img = rasterio.open('./landsat_multi/landsat_img_test.tif', 'r')\n        roi = gpd.read_file('./roi/roi.shp')\n        clipped, meta = raster.crop(img, roi)\n\n        import earthpy.plot as ep\n        ep.plot_rgb(clipped, stretch=True, rgb=(3,2,1))\n\n    '''\n    import rasterio\n    from rasterio.transform import Affine\n    from shapely.geometry import mapping\n    from shapely.geometry import box\n    import geopandas as gpd\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            if not os.path.exists('./tmp/'):\n                os.makedirs('./tmp/')\n            writeRaster(input, './tmp/tmp.tif', input_meta)\n            input_image = rast('./tmp/tmp.tif')\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Define boundary\n    # Reference is shapefile\n    if isinstance(reference, gpd.GeoDataFrame):\n        minx, miny, maxx, maxy = reference.total_bounds\n        # define box\n        bbox = box(minx, miny, maxx, maxy)\n        poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs=reference.crs)\n    # Reference is raster\n    elif isinstance(reference, rasterio.DatasetReader):\n        minx, miny, maxx, maxy = reference.bounds\n        # define box\n        bbox = box(minx, miny, maxx, maxy)\n        poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs=reference.crs)\n    # Reference is array\n    elif isinstance(reference, np.ndarray):\n        if reference_meta is None:\n            raise ValueError('It requires metadata of reference')\n        else:\n            minx, miny = reference_meta['transform'] * (0, 0)\n            maxx, maxy = reference_meta['transform']* (reference_meta['width'], reference_meta['height'])\n            # define box\n            bbox = box(minx, miny, maxx, maxy)\n            poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs= reference_meta['crs'])\n    else:\n        raise ValueError('Reference data is not supported')   \n\n    ### Define nodata\n    if nodata is None:\n        dataType = input_image.meta['dtype']\n        if dataType.lower() == 'int8':\n            nodata_value = 127\n        elif dataType.lower() == 'uint8':\n            nodata_value = 255\n        elif dataType.lower() == 'int16':\n            nodata_value = 32767\n        elif dataType.lower() == 'uint16':\n            nodata_value = 65535\n        elif dataType.lower() == 'int32':\n            nodata_value = 2147483647\n        elif dataType.lower() == 'uint32':\n            nodata_value == 4294967295\n        elif dataType.lower() == 'float16':\n            nodata_value = 65500\n        elif dataType.lower() == 'float32':\n            nodata_value == 999999\n        else:\n            nodata_value == 0\n    else:\n        nodata_value = nodata    \n\n    ### Invert crop\n    if invert is True:\n        clipped, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), crop=True, invert=True, nodata=-999999)\n    else:\n        clipped, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), crop=True, nodata=-999999)\n\n    # Define metadata\n    meta  = input_image.meta\n    meta.update({\n        'height': clipped.shape[1],\n        'width': clipped.shape[2],\n        'transform': geotranform,\n        'dtype': np.float32,\n        'nodata': nodata_value})\n\n    # Write output\n    if output is not None:\n        writeRaster(clipped, output, meta)\n    else:\n        return clipped, meta\n</code></pre>"},{"location":"raster/#geonate.raster.extractValues","title":"<code>extractValues(input, roi, field=None, meta=None, dataframe=True, names=None, na_rm=True, nodata=None, prefix=None, tail=True)</code>","text":"<p>Extract pixel values in GCP for both point and polygon </p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>~AnyStr</code> <p>rasterio image or data array</p> required <code>roi</code> <code>~AnyStr</code> <p>variable indicates name of shapefile where GCP points located, read by geopandas </p> required <code>field</code> <code>~AnyStr</code> <p>string, but the value of field must be number, the field name in shapefile GCP to extract label values, e.g., 'class'</p> <code>None</code> <code>meta</code> <code>Optional[~AnyStr]</code> <p>optional dict, metadata in case input is data array</p> <code>None</code> <code>dataframe</code> <code>Optional[bool]</code> <p>optional bool, whether to return dataframe or separate X, y arrays</p> <code>True</code> <code>names</code> <code>Optional[list]</code> <p>optional list, given expected names</p> <code>None</code> <code>na_rm</code> <code>bool</code> <p>bool, remove NA value from the output or not</p> <code>True</code> <code>prefix</code> <code>Optional[~AnyStr]</code> <p>optional string, given character before each band name</p> <code>None</code> <p>Examples:</p> <p>img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif') roi = gpd.read_file('./Sample_data/shapefile/GCP_polys.shp')</p>"},{"location":"raster/#geonate.raster.extractValues--return-combined-dataframe","title":"return combined dataframe","text":"<p>df = raster.extractValues(img, roi, field='class') df.head(5)</p>"},{"location":"raster/#geonate.raster.extractValues--return-separate-array-of-x-and-y","title":"return separate array of X and y","text":"<p>X, y = raster.extractValues(img, roi, field='class', dataframe=False)</p> Source code in <code>geonate/raster.py</code> <pre><code>def extractValues(input: AnyStr, roi: AnyStr, field: AnyStr=None, meta: Optional[AnyStr]=None, dataframe: Optional[bool]=True, names: Optional[list]=None, na_rm: bool=True, nodata=None, prefix: Optional[AnyStr]=None, tail=True):\n    '''\n    Extract pixel values in GCP for both point and polygon \n\n    Parameters:\n        input: rasterio image or data array\n        roi: variable indicates name of shapefile where GCP points located, read by geopandas \n        field: string, but the value of field must be number, the field name in shapefile GCP to extract label values, e.g., 'class'\n        meta: optional dict, metadata in case input is data array\n        dataframe: optional bool, whether to return dataframe or separate X, y arrays\n        names: optional list, given expected names\n        na_rm: bool, remove NA value from the output or not\n        prefix: optional string, given character before each band name\n\n    Example:\n       img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif')\n       roi = gpd.read_file('./Sample_data/shapefile/GCP_polys.shp')\n\n       # return combined dataframe\n       df = raster.extractValues(img, roi, field='class')\n       df.head(5)\n\n       # return separate array of X and y\n       X, y = raster.extractValues(img, roi, field='class', dataframe=False)\n\n    '''\n    import rasterio\n    from rasterio.plot import reshape_as_image\n    import numpy as np\n    from shapely.geometry import mapping\n    from rasterio import mask\n    import pandas as pd\n\n    if field is None:\n        raise ValueError('Please provide field name')\n    else:\n        ### Define input image\n        # input is raster\n        if isinstance(input, rasterio.DatasetReader):\n            input_image = input\n        # input is array\n        elif isinstance(input, np.ndarray):\n            if meta is None:\n                raise ValueError('It requires metadata of input')\n            else:\n                if not os.path.exists('./tmp/'):\n                    os.makedirs('./tmp/')\n                writeRaster(input, './tmp/tmp.tif', meta)\n                input_image = rast('./tmp/tmp.tif')\n        # Other input\n        else:\n            raise ValueError('Input data is not supported')\n\n        ########\n\n        ### Define nodata\n        if nodata is None:\n            dataType = input_image.meta['dtype']\n            if dataType.lower() == 'int8':\n                nodata_value = 127\n            elif dataType.lower() == 'uint8':\n                nodata_value = 255\n            elif dataType.lower() == 'int16':\n                nodata_value = 32767\n            elif dataType.lower() == 'uint16':\n                nodata_value = 65535\n            elif dataType.lower() == 'int32':\n                nodata_value = 2147483647\n            elif dataType.lower() == 'uint32':\n                nodata_value == 4294967295\n            elif dataType.lower() == 'float16':\n                nodata_value = 65500\n            elif dataType.lower() == 'float32':\n                nodata_value == 999999\n            else:\n                nodata_value == 0\n        else:\n            nodata_value = nodata   \n\n        # Convert shapefile to shapely geometry\n        geoms = roi.geometry.values\n\n        # Extract some metadata information\n        nbands = input_image.count\n        dtype_X = np.float32()\n        dtype_y = np.float32()\n\n        # Create empty array to contain X and y arrays\n        X = np.array([], dtype= dtype_X).reshape(0, nbands)\n        y = np.array([], dtype= dtype_y)\n\n        # Run loop over each features in shapefile to extract pixel values\n        for index, geom in enumerate(geoms):\n            poly = [mapping(geom)]\n\n            # Crop image based on feature\n            cropped, transform = mask.mask(input_image, poly, crop=True, nodata=nodata_value)\n\n            # Reshape dataset in form of (values, bands)\n            cropped_reshape = reshape_as_image(cropped)\n            reshapped = cropped_reshape.reshape(-1, nbands)\n\n            # Append 1D array y\n            y = np.append(y, [roi[field][index]] * reshapped.shape[0])\n\n            # vertical stack 2D array X\n            X = np.vstack((X, reshapped))\n\n        # Remove NAN value or not\n        if na_rm is True: \n            data = np.hstack((X, y.reshape(y.shape[0], 1)))\n            data_na = data[~np.isnan(data).any(axis=1)]\n            data_nodata = data_na[~(data_na == nodata_value).any(axis=1)]\n\n            X_na = data_nodata[ :, 0:nbands]\n            y_na = data_nodata[ : , nbands]\n\n            # return dataframe\n            if dataframe is True:\n                y_na_reshape = y_na.reshape(-1,1)\n\n                # class tail\n                if tail is True:\n                    arr = np.hstack([X_na, y_na_reshape])\n                else:\n                    arr = np.hstack([y_na_reshape, X_na])\n\n                # Name is not given\n                if names is None:\n                    if prefix is None:\n                        names_band = [f'B{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    else:\n                        names_band = [f'{prefix}{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n                # Name is given\n                else:\n                    if len(names) != (nbands + 1):\n                        raise ValueError('Length of name should be equal to number of bands plus 1')\n                    else:\n                        if prefix is None:\n                            names_list = names\n                        else:\n                            names_list = [f'{prefix}{name_i}' for name_i in names]\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n            # Do not return dataframe\n            else:\n                return X_na, y_na\n\n        # Do not remove NAN values\n        else: \n            # return dataframe\n            if dataframe is True:\n                y_reshape = y.reshape(-1,1)\n                arr = np.hstack([X, y_reshape])\n\n                # Name is not given\n                if names is None:\n                    if prefix is None:\n                        names_band = [f'B{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    else:\n                        names_band = [f'{prefix}{i}' for i in range(1, input_image.count +1)]\n                        name_class = [str(field)]\n                        if tail is True:\n                            names_list = names_band + name_class\n                        else:\n                            names_list = name_class + names_band\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n                # Name is given\n                else:\n                    if len(names) != (nbands + 1):\n                        raise ValueError('Length of name should be equal to number of bands plus 1')\n                    else:\n                        if prefix is None:\n                            names_list = names\n                        else:\n                            names_list = [f'{prefix}{name_i}' for name_i in names]\n                    data = pd.DataFrame(arr, columns=names_list)            \n                    return data\n\n            else:\n                return X, y\n</code></pre>"},{"location":"raster/#geonate.raster.getBounds","title":"<code>getBounds(input, meta=None)</code>","text":"<p>Return bounds of raster image</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>~AnyStr</code> <p>image or data array input that need to crop</p> required <code>meta</code> <code>Optional[Dict]</code> <p>Optional metadata when input is data array</p> <code>None</code> <p>Examples:</p> <p>img = raster.rast('./Sample_data/landsat_multi/landsat_stacked.tif') meta = img.meta ds= img.read()</p> <p>left, bottom, right, top = raster.getBounds(ds, meta) print(left, bottom, right, top)</p> Source code in <code>geonate/raster.py</code> <pre><code>def getBounds(input: AnyStr, meta: Optional[Dict]=None):\n    '''\n    Return bounds of raster image\n\n    Parameters:\n        input: image or data array input that need to crop\n        meta: Optional metadata when input is data array\n\n    Example:\n        img = raster.rast('./Sample_data/landsat_multi/landsat_stacked.tif')\n        meta = img.meta\n        ds= img.read()\n\n        left, bottom, right, top = raster.getBounds(ds, meta)\n        print(left, bottom, right, top)\n\n    '''\n    import rasterio\n    import numpy as np\n\n    # Check input \n    if isinstance(input, rasterio.DatasetReader):\n        left, bottom, right, top = input.bounds\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            transform = meta['transform']\n            width = meta['width']\n            height = meta['height']\n            left, top = transform * (0, 0)\n            right, bottom = transform * (width, height)\n\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    return left, bottom, right, top\n</code></pre>"},{"location":"raster/#geonate.raster.layerstack","title":"<code>layerstack(input, output=None)</code>","text":"<p>Stack layers for different geotif images with the same extent and each image may have more than 1 band</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>String, List of input geotif files</p> required <code>output</code> <code>Optional[~AnyStr]</code> <p>Optional string, whether to write the stacked image or not</p> <code>None</code> <p>Examples:</p> <p>input = tools.list_files('./Sample_data/landsat_multi/Single_band/', '*tif') stacked, meta = raster.layerstack(input, 'output.tif')</p> Source code in <code>geonate/raster.py</code> <pre><code>def layerstack(input, output: Optional[AnyStr]=None):\n    '''\n    Stack layers for different geotif images with the same extent and each image may have more than 1 band\n\n    Parameters:\n        input: String, List of input geotif files\n        output: Optional string, whether to write the stacked image or not\n\n    Example:\n       input = tools.list_files('./Sample_data/landsat_multi/Single_band/', '*tif')\n       stacked, meta = raster.layerstack(input, 'output.tif')\n\n    '''\n\n    import rasterio\n    from rasterio.plot import reshape_as_raster\n    import numpy as np\n\n    files2stack = []\n    stacked_array = []\n    nbands = len(input)\n\n    for file in input:\n        with rasterio.open(file) as src:\n            data = src.read(1)\n            meta = src.meta\n            files2stack.append(data)\n\n    stacked_array = np.stack(files2stack, axis=-1)\n    stacked = reshape_as_raster(stacked_array)\n    meta.update({'count': nbands,\n                            'driver': 'GTiff',\n                            'compress': 'lzw'})\n\n    # write out result \n    if output is not None:\n        writeRaster(stacked, output, meta)\n    else:\n        return stacked, meta\n</code></pre>"},{"location":"raster/#geonate.raster.mask","title":"<code>mask(input, reference, input_meta=None, reference_meta=None, invert=False, nodata=0, output=None)</code>","text":"<p>Mask raster opened by rasterio by shapefile vector or another image</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>image or data array input that need to crop</p> required <code>reference</code> <p>region of interest, shapefile opened by geopandas or another image or data array to crop</p> required <code>input_meta</code> <code>Optional[Dict]</code> <p>Optional metadata when input is data array</p> <code>None</code> <code>reference_meta</code> <code>Optional[Dict]</code> <p>Optional metadata when reference is data array</p> <code>None</code> <code>invert</code> <p>bool, if True, pixels inside shapefile will be masked </p> <code>False</code> <code>output</code> <code>Optional[~AnyStr]</code> <p>Optional string, whether write out geotif file to local directory</p> <code>None</code> <p>Examples:</p> <p>img = rasterio.open('./landsat_multi/landsat_img_test.tif', 'r') roi = gpd.read_file('./roi/roi.shp') masked = raster.mask(img, roi)</p> <p>import earthpy.plot as ep ep.plot_rgb(masked, stretch=True, rgb=(3,2,1))</p> Source code in <code>geonate/raster.py</code> <pre><code>def mask(input, reference, input_meta: Optional[Dict]=None, reference_meta: Optional[Dict]=None, invert=False, nodata=0, output: Optional[AnyStr]=None):\n    '''\n    Mask raster opened by rasterio by shapefile vector or another image\n\n    Parameters:\n        input: image or data array input that need to crop\n        reference: region of interest, shapefile opened by geopandas or another image or data array to crop\n        input_meta: Optional metadata when input is data array\n        reference_meta: Optional metadata when reference is data array\n        invert: bool, if True, pixels inside shapefile will be masked \n        output: Optional string, whether write out geotif file to local directory\n\n    Example:\n        img = rasterio.open('./landsat_multi/landsat_img_test.tif', 'r')\n        roi = gpd.read_file('./roi/roi.shp')\n        masked = raster.mask(img, roi)\n\n        import earthpy.plot as ep\n        ep.plot_rgb(masked, stretch=True, rgb=(3,2,1))\n\n    '''\n    import rasterio\n    import shapely\n    from shapely.geometry import mapping\n    import geopandas as gpd\n    import numpy as np\n    from geonate import raster\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            if not os.path.exists('./tmp/'):\n                os.makedirs('./tmp/')\n            writeRaster(input, './tmp/tmp.tif', input_meta)\n            input_image = rast('./tmp/tmp.tif')\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Define boundary\n    if (isinstance(reference, gpd.GeoDataFrame)):\n        poly = reference\n        transform_poly = reference.transform\n        crs_poly = reference.crs\n    else:\n        if isinstance(reference, rasterio.DatasetReader):\n            ds_reference = reference.read(1)\n            transform_poly = reference.meta['transform']\n            crs_poly = reference.meta['crs']\n        elif isinstance(reference, np.ndarray):\n            ds_reference = reference[1, : , : ]\n            transform_poly = reference_meta['transform']\n            crs_poly = reference_meta['crs']\n        else:\n            raise ValueError('Data is not supported')\n\n        masked = np.where(np.isnan(ds_reference), np.nan, 1)\n        masked_convert = masked.astype(np.float32)\n\n        shp = rasterio.features.shapes(masked_convert, mask= ~np.isnan(masked_convert), transform= transform_poly)\n        poly = []\n        values = []\n\n        for shape, value in shp:\n            if value == 1:\n                poly.append(shapely.geometry.shape(shape))\n                values.append(value)\n\n        poly = gpd.GeoDataFrame({'geometry': poly, 'value': values})\n        poly.set_crs(crs_poly.to_string(), inplace=True)\n\n    ### Define nodata\n    if nodata is None:\n        dataType = input_image.meta['dtype']\n        if dataType.lower() == 'int8':\n            nodata_value = 127\n        elif dataType.lower() == 'uint8':\n            nodata_value = 255\n        elif dataType.lower() == 'int16':\n            nodata_value = 32767\n        elif dataType.lower() == 'uint16':\n            nodata_value = 65535\n        elif dataType.lower() == 'int32':\n            nodata_value = 2147483647\n        elif dataType.lower() == 'uint32':\n            nodata_value == 4294967295\n        elif dataType.lower() == 'float16':\n            nodata_value = 65500\n        elif dataType.lower() == 'float32':\n            nodata_value == 999999\n        else:\n            nodata_value == 0\n    else:\n        nodata_value = nodata        \n\n    ### Invert mask\n    if invert is True:\n        masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, invert=True, nodata=nodata_value)\n    else:\n        masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, nodata= nodata_value)\n\n    meta  = input_image.meta\n    meta.update({\n        'height': masked_img.shape[1],\n        'width': masked_img.shape[2],\n        'transform': geotranform,\n        'dtype': np.float32,\n        'nodata': nodata_value})\n\n    # Write output\n    if output is not None:\n        raster.writeRaster(masked_img, output, meta)\n    else:\n        return masked_img, meta\n</code></pre>"},{"location":"raster/#geonate.raster.match","title":"<code>match(input, reference, method='near', input_meta=None, reference_meta=None)</code>","text":"<p>Match input image to the reference image in terms of projection, resolution, and bound extent It returns image within the bigger boundary</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>rasterio objective needs to match </p> required <code>reference</code> <p>rasterio object taken as reference to match the input image</p> required <code>method</code> <code>~AnyStr</code> <p>optional string defines resampling method (if applicable) to resample if having different resolution</p> <code>'near'</code> <code>input_meta</code> <code>Optional[Dict]</code> <p>Optional Dict, metadata of input required when input is data array</p> <code>None</code> <code>reference_meta</code> <code>Optional[Dict]</code> <p>Optional Dict, metadata of reference required when reference is data array</p> <code>None</code> <p>Examples:</p> <p>img1 = rasterio.open('./Sample_data/landsat_multi/scene/landsat_img_01.tif') img2 = rasterio.open('./Sample_data/landsat_multi/scene/landsat_img_02.tif')</p> <p>img1_matched, meta = raster.match(img1, img2) ep.plot_bands(img1_matched)</p> Source code in <code>geonate/raster.py</code> <pre><code>def match(input, reference, method: AnyStr='near', input_meta: Optional[Dict]=None, reference_meta: Optional[Dict]=None):\n    '''\n    Match input image to the reference image in terms of projection, resolution, and bound extent\n    It returns image within the bigger boundary\n\n    Parameters:\n        input: rasterio objective needs to match \n        reference: rasterio object taken as reference to match the input image\n        method: optional string defines resampling method (if applicable) to resample if having different resolution\n        input_meta: Optional Dict, metadata of input required when input is data array\n        reference_meta: Optional Dict, metadata of reference required when reference is data array\n\n    Example:\n        img1 = rasterio.open('./Sample_data/landsat_multi/scene/landsat_img_01.tif')\n        img2 = rasterio.open('./Sample_data/landsat_multi/scene/landsat_img_02.tif')\n\n        img1_matched, meta = raster.match(img1, img2)\n        ep.plot_bands(img1_matched)\n\n    '''\n    import rasterio\n    from rasterio import warp\n    from rasterio.transform import from_bounds\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            input_image = input\n            meta = input_meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Define reference image\n    if isinstance(reference, rasterio.DatasetReader):\n        reference_image = reference.read()\n        meta_reference = reference.meta\n    # input is array\n    elif isinstance(reference, np.ndarray):\n        if reference_meta is None:\n            raise ValueError('It requires metadata of reference')\n        else:\n            reference_image = reference\n            meta_reference = reference_meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Check some conditions\n    if meta[\"crs\"] != meta_reference['crs']:\n        print('Input and reference images have different Projection')\n        print('Output projection will take the reference projection')\n    if meta['transform'][0] != meta_reference['transform'][0]:\n        print('Input and reference images have different resolution')\n        print('Ouput resolution will take the reference resolution')     \n\n    # get general extent from two images\n    ext_input = getBounds(input_image, meta)\n    ext_reference = getBounds(reference_image, meta_reference)\n\n    ext = ext_input\n    ext = (\n        min(ext[0], ext_reference[0]),\n        min(ext[1], ext_reference[1]),\n        max(ext[2], ext_reference[2]),\n        max(ext[3], ext_reference[3])\n        )\n\n    # calculate new height and width\n    resolution = meta_reference['transform'][0]    \n    width_new = int((ext[2]  - ext[0]) / resolution)\n    height_new = int((ext[3] - ext[1]) / resolution)\n\n    # calculate new transform\n    transform_new = from_bounds(ext[0], ext[1], ext[2], ext[3], width_new, height_new)\n\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # Reproject to match\n    if len(input_image.shape) &gt; 2:\n        nbands = input_image.shape[0]\n    else:\n        nbands = 1\n\n    matched = np.empty((nbands, height_new, width_new), dtype=np.float32)\n    for band in range(0, nbands):\n        if nbands &lt;= 1:\n            ds = input_image\n        else:\n            ds = input_image[band, : , : ]\n        warp.reproject(source=ds, destination=matched[band, :, :], src_transform= meta['transform'], dst_transform= transform_new, src_crs=meta['crs'], dst_crs=meta_reference['crs'], resampling= resampleAlg)\n\n    # match out other values\n    match_masked = np.where(matched == 0, np.nan, matched)\n    match_masked = match_masked.astype(np.float32)\n\n    # update metadata\n    meta_update = meta.copy()\n    meta_update.update({\n        'crs': meta_reference['crs'],\n        'transform': transform_new,\n        'width': width_new,\n        'height': height_new,\n        'dtype': np.float32\n    })\n\n    return match_masked, meta_update\n</code></pre>"},{"location":"raster/#geonate.raster.merge","title":"<code>merge(input, output=None, compress='lzw')</code>","text":"<p>Merge multiple geotif file using Rasterio </p> <p>Parameters:</p> Name Type Description Default <code>input_files</code> <p>List of input geotif files</p> required <code>output_file</code> <p>path of output tif file</p> required <p>Examples:</p> <p>input_list = tools.listFiles('./test/', 'tif) raster.merge(input_list, './test/output.tif')</p> Source code in <code>geonate/raster.py</code> <pre><code>def merge(input: AnyStr, output: Optional[AnyStr]=None, compress: Optional[AnyStr]='lzw'):\n    '''\n    Merge multiple geotif file using Rasterio \n\n    Parameters:\n        input_files: List of input geotif files\n        output_file: path of output tif file\n\n    Example:\n       input_list = tools.listFiles('./test/', 'tif)\n       raster.merge(input_list, './test/output.tif')\n\n    '''\n    import rasterio\n    from rasterio import merge \n\n    src_files = []\n    for file in input:\n        ds = rasterio.open(file)\n        src_files.append(ds)\n\n    fun_sum = merge.copy_sum\n    fun_count = merge.copy_count\n\n    mosaic_sum, out_trans = merge.merge(src_files, method=fun_sum)\n    mosaic_count, out_trans = merge.merge(src_files, method=fun_count)\n\n    mosaic_avg = mosaic_sum / mosaic_count\n\n    meta = src_files[0].meta.copy()\n    meta.update({\"driver\": \"GTiff\",\n                            \"height\": mosaic_avg.shape[1],\n                            \"width\": mosaic_avg.shape[2],\n                            \"transform\": out_trans,\n                            \"compress\": compress})\n\n    # write out result \n    if output is not None:\n        with rasterio.open(output, \"w\", **meta) as dest:\n            dest.write(mosaic_avg)\n        print(f\"Finished merge raster files, the output is at {output}\")\n    # keep local\n    else:\n        return mosaic_avg, meta      \n</code></pre>"},{"location":"raster/#geonate.raster.mergeVRT","title":"<code>mergeVRT(input, output, compress=True, silent=True)</code>","text":"<p>Merge multiple geotif files using gdal VRT for better performance speed</p> <p>Parameters:</p> Name Type Description Default <code>input_files</code> <p>List of input geotif files</p> required <code>output_file</code> <p>path of output tif file</p> required <p>Examples:</p> <p>input_list = tools.list_files('./test/', '*tif') raster.mergeVRT(input_list, './test/output.tif')</p> Source code in <code>geonate/raster.py</code> <pre><code>def mergeVRT(input: AnyStr, output: AnyStr, compress: bool=True, silent=True):\n    '''\n    Merge multiple geotif files using gdal VRT for better performance speed\n\n    Parameters:\n        input_files: List of input geotif files\n        output_file: path of output tif file\n\n    Example:\n       input_list = tools.list_files('./test/', '*tif')\n       raster.mergeVRT(input_list, './test/output.tif')\n\n    '''\n\n    import os\n    from osgeo import gdal\n    #  Create a temp vrt file\n    vrt_file = 'merged.vrt'\n\n    if compress is True:\n        gdal.BuildVRT(vrt_file, input, options=['COMPRESS=LZW'])\n        gdal.Translate(output, vrt_file, format='GTiff', creationOptions=['COMPRESS=LZW'])\n\n    else:\n        gdal.BuildVRT(vrt_file, input)\n        gdal.Translate(output, vrt_file)\n\n    os.remove(vrt_file)\n    if silent is True:\n        pass\n    else:\n        print(f\"Finished merge raster files, the output is at {output}\")\n</code></pre>"},{"location":"raster/#geonate.raster.mimax","title":"<code>mimax(input, digit=3)</code>","text":"<p>Calculate maximum and minimum values of raster or array</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>rasterio image or data array</p> required <code>digit</code> <p>Optional string, whether write out geotif file to local directory</p> <code>3</code> <p>Examples:</p> <p>img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif') minvalue, maxvalue = raster.mimax(img)</p> Source code in <code>geonate/raster.py</code> <pre><code>def mimax(input, digit=3):\n    '''\n    Calculate maximum and minimum values of raster or array\n\n    Parameters:\n        input: rasterio image or data array\n        digit: Optional string, whether write out geotif file to local directory\n\n    Example:\n       img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif')\n       minvalue, maxvalue = raster.mimax(img)\n\n    '''\n\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Calculate min and max values\n    minValue = round(np.nanmin(dataset), digit)\n    maxValue = round(np.nanmax(dataset), digit)\n\n    # Convert min and max to string for print\n    min_round = str(round(minValue, digit))\n    max_round = str(round(maxValue, digit))\n\n    print(f\"Min: {min_round} \\nMax: {max_round}\")\n\n    return minValue, maxValue\n</code></pre>"},{"location":"raster/#geonate.raster.normalized","title":"<code>normalized(input, meta=None, output=None)</code>","text":"<p>Normalize raster data to rearrange raster values from 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>rasterio image or data array</p> required <code>meta</code> <code>Optional[~AnyStr]</code> <p>optional dict, metadata in case input is data array</p> <code>None</code> <code>output</code> <code>Optional[~AnyStr]</code> <p>Optional string, whether write out geotif file to local directory</p> <code>None</code> <p>Examples:</p> <p>img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif') normalized, meta = raster.normalized(img)       </p> Source code in <code>geonate/raster.py</code> <pre><code>def normalized(input, meta: Optional[AnyStr]=None, output: Optional[AnyStr]=None):\n    '''\n    Normalize raster data to rearrange raster values from 0 to 1\n\n    Parameters:\n        input: rasterio image or data array\n        meta: optional dict, metadata in case input is data array\n        output: Optional string, whether write out geotif file to local directory\n\n    Example:\n       img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif')\n       normalized, meta = raster.normalized(img)       \n\n    '''\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Please provide input metadata')\n        else:\n            dataset = input\n            meta = meta\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Find max min values\n    maxValue = np.nanmax(dataset)\n    minValue = np.nanmin(dataset)\n\n    ### Create empty data array to store output\n    normalized = np.zeros_like(dataset, dtype=np.float32)\n\n    ### Run normalization\n    for i in range(0, dataset.shape[0]):\n        band = dataset[i, : , : ]\n        band_norm = (band.astype(float)  - minValue) / (maxValue  - minValue)\n        normalized[i, : , : ] = band_norm\n        band_norm = None\n\n    ### update meta\n    meta.update({'dtype': np.float32})\n\n    ### return result \n    # Write output\n    if output is not None:\n        writeRaster(normalized, output, meta)\n    else:\n        return normalized, meta\n</code></pre>"},{"location":"raster/#geonate.raster.normalizedDifference","title":"<code>normalizedDifference(input, band1, band2, meta=None, output=None)</code>","text":"<p>Calculate normalized difference index</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>rasterio object or data array, input with multiple bands </p> required <code>band1</code> <p>numeric, order of the first band</p> required <code>band2</code> <p>numeric, order of the second band</p> required <code>meta</code> <code>Optional[Dict]</code> <p>optional dict, metadata in case input is data array</p> <code>None</code> <code>output</code> <code>Optional[~AnyStr]</code> <p>Optional string, whether write out geotif file to local directory</p> <code>None</code> <p>Examples:</p> <p>img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif') ndvi = raster.normalizedDifference(img, 4, 3)</p> Source code in <code>geonate/raster.py</code> <pre><code>def normalizedDifference(input, band1, band2, meta: Optional[Dict]=None, output: Optional[AnyStr]=None):\n    '''\n    Calculate normalized difference index\n\n    Parameters:\n        input: rasterio object or data array, input with multiple bands \n        band1: numeric, order of the first band\n        band2: numeric, order of the second band\n        meta: optional dict, metadata in case input is data array\n        output: Optional string, whether write out geotif file to local directory\n\n    Example:\n        img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif')\n        ndvi = raster.normalizedDifference(img, 4, 3)\n\n    '''    \n    import numpy as np\n    import rasterio\n\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            dataset = input\n            meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Extract data\n    ds_band1 = dataset[band1+1, : , : ]\n    ds_band2 = dataset[band2+1, : , : ]\n\n    # calculate index\n    normalized_index  = (ds_band1.astype(float) - ds_band2.astype(float)) / (ds_band1 + ds_band2)\n    normalized_index = normalized_index.astype(np.float32)\n    # remove outliers\n    normalized_index[(normalized_index &lt; -1) | (normalized_index &gt; 1)] = np.nan\n\n    meta.update({'dtype': np.float32})\n\n    # Write output\n    if output is not None:\n        writeRaster(normalized_index, output, meta)\n    else:\n        return normalized_index, meta\n</code></pre>"},{"location":"raster/#geonate.raster.project","title":"<code>project(input, reference=None, method='near', input_meta=None, res=None, output=None)</code>","text":"<p>Reproject raster data to a new projection and resample (if required)</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>Input rasterio image or data array</p> required <code>reference</code> <code>Optional[~AnyStr]</code> <p>reference data of even another image or 'crs' string, e.g., 'EPSG:4326'</p> <code>None</code> <code>method</code> <code>Optional[~AnyStr]</code> <p>resampling method (if changing resolution), optional, default method is 'nearest neighbor', other methods are at rasterio.Resampling. (e.g., nearest, cubic, bilinear, average)</p> <code>'near'</code> <code>input_meta</code> <code>Optional[Dict]</code> <p>Dict, required when input is data array</p> <code>None</code> <code>res</code> <code>Optional[float]</code> <p>Optional number, Resolution of the output in degree or meters depends on the output crs</p> <code>None</code> <code>output</code> <code>Optional[~AnyStr]</code> <p>Optional string, whether write out geotif file to local directory</p> <code>None</code> <p>Examples:</p> <p>img = raster.rast('./Sample_data/landsat_multi/landsat_stacked.tif') ds = img.read() meta = img.meta arr, metadata = raster.project(input=ds, reference='EPSG:32648', input_meta=meta, res=1000)</p> Source code in <code>geonate/raster.py</code> <pre><code>def project(input, reference:Optional[AnyStr]=None, method: Optional[AnyStr]='near', input_meta: Optional[Dict]=None, res: Optional[float]=None, output: Optional[AnyStr]=None):\n    '''\n    Reproject raster data to a new projection and resample (if required)\n\n    Parameters:\n        input: Input rasterio image or data array\n        reference: reference data of even another image or 'crs' string, e.g., 'EPSG:4326'\n        method: resampling method (if changing resolution), optional, default method is 'nearest neighbor', other methods are at rasterio.Resampling. (e.g., nearest, cubic, bilinear, average)\n        input_meta: Dict, required when input is data array\n        res: Optional number, Resolution of the output in degree or meters depends on the output crs\n        output: Optional string, whether write out geotif file to local directory\n\n    Example:\n        img = raster.rast('./Sample_data/landsat_multi/landsat_stacked.tif')\n        ds = img.read()\n        meta = img.meta\n        arr, metadata = raster.project(input=ds, reference='EPSG:32648', input_meta=meta, res=1000)\n\n    '''\n    import rasterio\n    from rasterio import warp\n    import numpy as np\n\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input.read()\n        meta = input.meta\n        # define boundary of input image\n        left, bottom, right, top = input.bounds\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if input_meta is None:\n            raise ValueError('It requires metadata of input')\n        else:\n            input_image = input\n            meta = input_meta\n            left, bottom = meta['transform'] * (0, 0)\n            # define boundary of input image\n            right, top = meta['transform']* (meta['width'], meta['height'])\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # If reference is not given, it will take the CRS from input\n    # the function now used for resampling\n    if reference is None:\n        dst_crs = meta['crs']\n        if res is None:\n            xsize, ysize = xsize, ysize = meta['transform'][0], meta['transform'][0]\n        else:\n            xsize, ysize = res, res\n        transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n\n    else:\n        # string of EPSG\n        if isinstance(reference, str):\n            dst_crs = reference\n            if res is None:\n                raise ValueError('Please provide output resolution')\n            else:\n                xsize, ysize = res, res\n            transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n\n        # Take all paras from reference image\n        elif isinstance(reference, rasterio.DatasetReader):\n            dst_crs = reference.crs\n            if res is None:\n                xsize, ysize = reference.res\n            else:\n                xsize, ysize = res, res\n            transform, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, height=meta['height'], width=meta['width'], resolution=(xsize, ysize), left=left, bottom=bottom, right=right, top=top)\n        else:\n            raise ValueError('Please define correct reference, it is CRS string or an image')\n\n    # Update metadata\n    meta_update = meta.copy()\n    meta_update.update({\n        'crs': dst_crs,\n        'transform': transform,\n        'width': width,\n        'height': height,\n    })\n\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # Running project \n    projected = np.empty((input_image.shape[0], height, width), dtype= meta['dtype'])\n    for band in range(0, input_image.shape[0]):\n        ds = input_image[band, : , : ]\n        warp.reproject(source=ds, destination=projected[(band), :, :], src_transform= meta['transform'], dst_transform=transform, src_crs=meta['crs'], dst_crs=dst_crs, resampling= resampleAlg)\n\n    # Write output\n    if output is not None:\n        writeRaster(projected, output, meta_update)\n    else:\n        return projected, meta_update\n</code></pre>"},{"location":"raster/#geonate.raster.rast","title":"<code>rast(input, show_meta=False)</code>","text":"<p>Open a single geotif raster file using Rasterio</p> <p>Parameters:</p> Name Type Description Default <code>inputpath</code> <p>the file path indicates location of geotif file</p> required <p>Examples:</p> <p>path = '../test/landsat_multi/landsat_img_test.tif' img = raster.rast(path)</p> Source code in <code>geonate/raster.py</code> <pre><code>def rast(input: AnyStr, show_meta: Optional[bool]=False):\n    '''\n    Open a single geotif raster file using Rasterio\n\n    Parameters:\n        inputpath: the file path indicates location of geotif file\n\n    Example:\n       path = '../test/landsat_multi/landsat_img_test.tif'\n       img = raster.rast(path)\n\n    '''\n    import rasterio\n    import os\n\n    img = rasterio.open(input)\n    basename = os.path.basename(input)\n\n    # show meta \n    if show_meta is True:\n        meta = img.meta\n        print(f\"Opening: {basename} \\n{meta}\")\n\n    return img    \n</code></pre>"},{"location":"raster/#geonate.raster.reclassify","title":"<code>reclassify(input, breakpoints, classes, meta=None, output=None)</code>","text":"<p>Reclassify image with discrete or continuous values</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>raster or data array input</p> required <code>breakpoints</code> <p>number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]</p> required <code>classes</code> <p>number list, define classes, number of classes equal number of breakpoints minus 1</p> required <code>meta</code> <code>Optional[Dict]</code> <code>None</code> <code>output</code> <code>Optional[~AnyStr]</code> <p>Optional string, whether write out geotif file to local directory</p> <code>None</code> <p>Examples:</p> <p>img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif') rc = raster.reclassify(img, breakpoints=[float('-inf'), -0.5, 0, 0.5, float('-inf')], classes=[1, 2, 3, 4])</p> Source code in <code>geonate/raster.py</code> <pre><code>def reclassify(input, breakpoints, classes, meta: Optional[Dict]=None, output: Optional[AnyStr]=None):\n    '''\n    Reclassify image with discrete or continuous values\n\n    Parameters:\n        input: raster or data array input\n        breakpoints: number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]\n        classes: number list, define classes, number of classes equal number of breakpoints minus 1\n        meta: meta: optional dict, metadata in case input is data array\n        output: Optional string, whether write out geotif file to local directory\n\n    Example:\n        img = rasterio.open('./Sample_data/landsat_multi/landsat_stacked.tif')\n        rc = raster.reclassify(img, breakpoints=[float('-inf'), -0.5, 0, 0.5, float('-inf')], classes=[1, 2, 3, 4])\n\n    '''    \n    import rasterio\n    import numpy as np\n\n    ### Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        if len(input.shape) == 2:\n            dataset = input.read()\n            meta = input.meta\n        elif len(input.shape) == 3:\n            if  input.shape[0] &gt; 1:\n                raise ValueError('Input data has more than one band')\n            else:\n                dataset = input.read(1)\n                meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            if (len(input.shape)) &gt; 2 and (input.shape[0] &gt; 1):\n                raise ValueError('Input data has more than one band')\n            else:\n                dataset = input\n                meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ####\n    # Create unique values and empty data array to store reclassified result \n    uniques = np.unique(dataset)\n    reclassified = np.zeros_like(dataset)\n\n    ####\n    # If image has discrete values\n    if len(uniques) == len(classes): \n        if len(breakpoints) == len(classes):\n            for i in range(len(classes)):\n                reclassified[dataset == breakpoints[i]] = classes[i]\n        elif len(breakpoints) == (len(classes)-1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n    # If image has continuous values\n    else:\n        if len(breakpoints) == (len(classes)+1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n\n    # Write output\n    if output is not None:\n        writeRaster(reclassified, output, meta)\n    else:\n        return reclassified, meta\n</code></pre>"},{"location":"raster/#geonate.raster.values","title":"<code>values(input, meta=None, na_rm=True, names=None, prefix=None)</code>","text":"<p>Extract all pixel values of image and create dataframe from them, each band is a column</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>rasterio image or data array</p> required <code>meta</code> <code>Optional[~AnyStr]</code> <code>None</code> <code>names</code> <code>Optional[list]</code> <p>optional list, given expected names</p> <code>None</code> <code>prefix</code> <code>Optional[~AnyStr]</code> <p>optional string, given character before each band name</p> <code>None</code> <p>Examples:</p> <p>img = rasterio.open('./Sample_data/landsat_multi/landsat_crop.tif') df = raster.values(img, prefix='Band') df.head(5)</p> Source code in <code>geonate/raster.py</code> <pre><code>def values(input, meta: Optional[AnyStr]=None, na_rm: Optional[bool]=True, names: Optional[list]=None, prefix: Optional[AnyStr]=None):\n    '''\n    Extract all pixel values of image and create dataframe from them, each band is a column\n\n    Parameters:\n        input: rasterio image or data array\n        meta: meta: optional dict, metadata in case input is data array\n        names: optional list, given expected names\n        prefix: optional string, given character before each band name\n\n    Example:\n        img = rasterio.open('./Sample_data/landsat_multi/landsat_crop.tif')\n        df = raster.values(img, prefix='Band')\n        df.head(5)\n\n    '''    \n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    ### Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('It requires metadata')\n        else:\n            dataset = input\n            meta = meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    ########\n    nbands = dataset.shape[0]\n    bands_array = [dataset[band, : , : ].flatten() for band in range(0, nbands)]\n\n    if names is not None:\n        if len(names) != nbands:\n            raise ValueError('Length of name should be equal to number of bands')\n        else:\n            if prefix is None:\n                data = pd.DataFrame(np.array(bands_array).T, columns=names)\n            else:\n                names_new = [f'{prefix}{name}' for name in names]\n                data = pd.DataFrame(np.array(bands_array).T, columns=names_new)\n    else:\n        if prefix is None:\n            data = pd.DataFrame(np.array(bands_array).T, columns=[f'B{i}' for i in range(1,nbands +1)])\n        else:\n            data = pd.DataFrame(np.array(bands_array).T, columns=[f'{prefix}{i}' for i in range(1, nbands +1)])\n\n    ####### \n    # Remove NA values or not\n    if na_rm is True: \n        data_out = data.dropna().reset_index(drop=True)\n    else:\n        data_out = data\n\n    return data_out\n</code></pre>"},{"location":"raster/#geonate.raster.vect","title":"<code>vect(input, show_meta=False)</code>","text":"<p>Read shapefile vector file using Geopandas </p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <p>the file path indicates location of shapefile </p> required <p>Examples:</p> <p>path ='../test/roi/roi.shp poly = raster.vect(path)</p> Source code in <code>geonate/raster.py</code> <pre><code>def vect(input: AnyStr, show_meta: Optional[bool]=False):\n    '''\n    Read shapefile vector file using Geopandas \n\n    Parameters:\n        input_path: the file path indicates location of shapefile \n\n    Example:\n        path ='../test/roi/roi.shp\n        poly = raster.vect(path)\n\n    '''\n    import geopandas as gpd\n    import os\n\n    vect = gpd.read_file(input)\n\n    # show meta \n    if show_meta is True:\n        basename = os.path.basename(input)\n        crs = vect.crs\n        datashape = vect.shape\n        print(f\"Opening: {basename} \\n Projection (crs): {crs} \\n Data shape: {datashape}\")\n\n    return vect\n</code></pre>"},{"location":"raster/#geonate.raster.writeRaster","title":"<code>writeRaster(input, output, meta=None, compress='lzw')</code>","text":"<p>Write raster Geotif from data Array using Rasterio.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>~AnyStr</code> <p>Data array in form of [band, height, width]</p> required <code>output</code> <code>~AnyStr</code> <p>Output file path.</p> required <code>meta</code> <code>Optional[Dict]</code> <p>Rasterio profile settings.</p> <code>None</code> <code>compress</code> <code>Optional[~AnyStr]</code> <p>Boolean indicating whether to compress the output.</p> <code>'lzw'</code> <code>compress_opt</code> <p>Compression algorithm (optional).</p> required <p>Examples:</p> <p>meta = img.meta meta.update({'count': 1}) meta.update({'dtype': rasterio.float32}) raster.writeRatser(arr, 'output.tif', meta=meta, compress='LZW')</p> Source code in <code>geonate/raster.py</code> <pre><code>def writeRaster(input: AnyStr, output: AnyStr, meta: Optional[Dict]=None, compress: Optional[AnyStr] = 'lzw'):\n    '''\n    Write raster Geotif from data Array using Rasterio.\n\n    Parameters:\n        input: Data array in form of [band, height, width]\n        output: Output file path.\n        meta: Rasterio profile settings.\n        compress: Boolean indicating whether to compress the output.\n        compress_opt: Compression algorithm (optional).\n\n    Example:\n        meta = img.meta\n        meta.update({'count': 1})\n        meta.update({'dtype': rasterio.float32})\n        raster.writeRatser(arr, 'output.tif', meta=meta, compress='LZW')\n\n    '''\n\n    import rasterio\n    import numpy as np\n\n    class RasterWriteError(Exception):\n        pass\n\n    # Input is rasterio image\n    if isinstance(input, rasterio.DatasetReader):\n        meta_out = input.meta\n        data_array = input.read()\n\n        # compress data or not\n        if compress is None:\n            meta_out = meta_out\n        else:\n            if compress.lower() == 'deflate':\n                meta_out.update({'compress': 'deflate'})\n            elif compress.lower() == 'lzw':\n                meta_out.update({'compress': 'lzw'})\n            else:\n                raise ValueError('Compress method is not supported')\n\n        # output has single band\n        if len(data_array.shape) == 2:\n            meta_out['count'] = int(1)\n            with rasterio.open(output, 'w', **meta_out) as dst:\n                for band in range(0, 1):\n                    data = data_array\n                    dst.write(data, band + 1)\n        # output has multi bands\n        else:\n            meta_out['count'] = int(data_array.shape[0])\n            with rasterio.open(output, 'w', **meta_out) as dst:\n                for band in range(0, int(data_array.shape[0])):\n                    data = data_array[band, : , : ]\n                    dst.write(data, band + 1)\n\n    # input is data array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Input is dataArray, please give metadata profile')\n        else:        \n        # compress data or not\n            if compress is None:\n                meta = meta\n            else:\n                if compress.lower() == 'deflate':\n                    meta.update({'compress': 'deflate'})\n                elif compress.lower() == 'lzw':\n                    meta.update({'compress': 'lzw'})\n                else:\n                    raise ValueError('Compress method is not supported')\n\n            # output has single band\n            if len(input.shape) == 2:\n                meta['count'] = int(1)\n                with rasterio.open(output, 'w', **meta) as dst:\n                    for band in range(0, 1):\n                        data = input\n                        dst.write(data, band + 1)\n            # output has multi bands\n            else:\n                meta['count'] = int(input.shape[0])\n                with rasterio.open(output, 'w', **meta) as dst:\n                    for band in range(0, int(input.shape[0])):\n                        data = input[band, : , : ]\n                        dst.write(data, band + 1)\n    else:\n        raise ValueError('Input data is not supported')    \n</code></pre>"},{"location":"tool/","title":"tool module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"tool/#geonate.tool.dataframe","title":"<code>dataframe(nrows, ncols, value='NA', name=None)</code>","text":"<p>Create an empty dataframe</p> <p>Parameters:</p> Name Type Description Default <code>nrows</code> <p>numeric, numbers of rows</p> required <code>ncols</code> <p>numeric, number of columns</p> required <code>value</code> <p>input value in all cells, default is NA</p> <code>'NA'</code> <code>name</code> <p>vector, names of columns, if not given, it will return default as number of column</p> <code>None</code> <p>Examples:</p> <p>data = tools.dataframe(nrows= 5, ncols= 2, name= ['Col1', 'Col2'])</p> Source code in <code>geonate/tool.py</code> <pre><code>def dataframe(nrows, ncols, value='NA', name=None):\n    '''\n    Create an empty dataframe\n\n    Parameters:\n        nrows: numeric, numbers of rows\n        ncols: numeric, number of columns\n        value: input value in all cells, default is NA\n        name: vector, names of columns, if not given, it will return default as number of column\n\n    Example:\n        data = tools.dataframe(nrows= 5, ncols= 2, name= ['Col1', 'Col2'])\n\n    '''\n    import pandas as pd\n    import numpy as np\n\n    # Check validity of column name\n    if name is None:\n        column_names = [f'Col_{i+1}' for i in range(ncols)]\n    elif len(name) == ncols:\n        column_names = name\n    else:\n        raise ValueError(\"Length of column names vector must match numbers of columns\")\n\n    # check input value\n    try: \n        if isinstance(value, int):\n            val = value\n        elif isinstance(value, float):\n            val = value\n        else:\n            val = np.nan\n    except ValueError:\n        val = np.nan\n\n    # Create data and parse it into dataframe \n    data = [[val] * ncols for _ in range(nrows)]\n    dataframe = pd.DataFrame(data, columns= column_names)\n\n    return dataframe\n</code></pre>"},{"location":"tool/#geonate.tool.extent","title":"<code>extent(input, poly=True)</code>","text":"<p>Get spatial extent of geotif image from a list or local variable</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>~AnyStr</code> <p>string, an input as a list of geotif files or local image/shapefile</p> required <code>poly</code> <code>bool</code> <p>bool, whether returns the extent polygon as geopandas object</p> <code>True</code> <p>Examples:</p> <p>files = tools.list_files('./landsat_multi/merge/', 'tif') ext, poly = tools.extent(files)</p> Source code in <code>geonate/tool.py</code> <pre><code>def extent(input: AnyStr, poly: bool= True):\n    '''\n    Get spatial extent of geotif image from a list or local variable\n\n    Parameters:\n        input: string, an input as a list of geotif files or local image/shapefile\n        poly: bool, whether returns the extent polygon as geopandas object\n\n    Example:\n        files = tools.list_files('./landsat_multi/merge/', 'tif')\n        ext, poly = tools.extent(files)\n\n    '''\n    import rasterio\n    import geopandas as gpd\n    from shapely.geometry import Polygon\n\n    general_extent = None\n\n    # get extent for raster files store in folder\n    if (isinstance(input, list)) or (isinstance(input, str)):\n        for file in input:\n            with rasterio.open(file) as src:\n                ext = src.bounds\n                crs = src.crs\n\n                if general_extent is None:\n                    general_extent = ext\n                else:\n                    general_extent =  (\n                        min(general_extent[0], ext[0]),\n                        min(general_extent[1], ext[1]),\n                        max(general_extent[2], ext[2]),\n                        max(general_extent[3], ext[3])\n                        )\n\n    # get extent for local read shapefile    \n    elif isinstance(input, gpd.GeoDataFrame):\n        ext = input.bounds\n        crs = input.crs\n        general_extent = (ext['minx'], ext['miny'],\n                                        ext['maxx'], ext['maxy'])\n\n    # get extent for local read geotif \n    else:\n        general_extent = input.bounds\n        crs = input.crs\n\n    # return rectangle of extennt\n    if poly is True:\n        poly_geom = Polygon([\n            (general_extent[0], general_extent[1]), \n            (general_extent[2], general_extent[1]), \n            (general_extent[2], general_extent[3]), \n            (general_extent[0], general_extent[3])\n            ])\n        poly = gpd.GeoDataFrame(index=[0], geometry=[poly_geom])\n        poly.crs = {'init': crs}\n    else: \n        poly = None\n\n    return general_extent, poly\n</code></pre>"},{"location":"tool/#geonate.tool.listFiles","title":"<code>listFiles(path, pattern, search_type='pattern', full_name=True)</code>","text":"<p>List all files with specific pattern within a folder path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>~AnyStr</code> <p>string, folder path where files stored</p> required <code>pattern</code> <code>~AnyStr</code> <p>string, search pattern of files (e.g., '*.tif')</p> required <code>search_type</code> <code>~AnyStr</code> <p>string, search type whether by \"extension\" or name \"pattern\"</p> <code>'pattern'</code> <code>full_name</code> <code>bool</code> <p>boolean, whether returning full name with path detail or not</p> <code>True</code> <p>Examples:</p> <p>files = tools.list_files(path= './Sample_data/shapefile/', pattern='*shp')</p> Source code in <code>geonate/tool.py</code> <pre><code>def listFiles(path: AnyStr, pattern: AnyStr, search_type: AnyStr = 'pattern', full_name: bool=True):\n    '''\n    List all files with specific pattern within a folder path\n\n    Parameters:\n        path: string, folder path where files stored\n        pattern: string, search pattern of files (e.g., '*.tif')\n        search_type: string, search type whether by \"extension\" or name \"pattern\"\n        full_name: boolean, whether returning full name with path detail or not\n\n    Example:\n        files = tools.list_files(path= './Sample_data/shapefile/', pattern='*shp')\n\n    '''\n    import os\n    import fnmatch\n\n    # Create empty list to store list of files\n    files_list = []\n\n    # Check search type\n    if (search_type.upper() == 'EXTENSION') or (search_type.upper() == 'E'):\n        if '*' in pattern:\n            raise ValueError(\"Do not use '*' in the pattern of extension search\")\n        else:\n            for root, dirs, files in os.walk(path):\n                for file in files:\n                    if file.lower().endswith(pattern):\n                        if full_name is True:\n                            files_list.append(os.path.join(root, file))\n                        else:\n                            files_list.append(file)    \n\n    elif (search_type.upper() == 'PATTERN') or (search_type.upper() == 'P'):\n        if '*' not in pattern:\n            raise ValueError(\"Pattern search requires '*' in pattern\")\n        else:\n            for root, dirs, files in os.walk(path):\n                for file in fnmatch.filter(files, pattern):\n                    if full_name is True:\n                        files_list.append(os.path.join(root, file))\n                    else:\n                        files_list.append(file)\n\n    else:\n        raise ValueError('Search pattern must be one of these types (pattern, p, extension, e)')\n\n    return files_list\n</code></pre>"},{"location":"tool/#geonate.tool.meter2degree","title":"<code>meter2degree(input, latitude)</code>","text":"<p>Convert image resolution from meter to acr-degree depending on location of latitude</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>number, input resolution of distance</p> required <code>latitude</code> <p>number, latitude presents location </p> required <p>Examples:</p> <p>degree = raster.meter2degree(30, 10.25)   </p> Source code in <code>geonate/tool.py</code> <pre><code>def meter2degree(input, latitude):\n    '''\n    Convert image resolution from meter to acr-degree depending on location of latitude\n\n    Parameters:\n        input: number, input resolution of distance\n        latitude: number, latitude presents location \n\n    Example:\n       degree = raster.meter2degree(30, 10.25)   \n\n    '''\n    import numpy as np\n\n    if latitude is None:\n        # Equator location\n        degree = input / (111320 * np.cos(np.radians(0.0)))\n    else:\n        degree = input / (111320 * np.cos(np.radians(latitude)))\n\n    return degree\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geonate in a project:</p> <pre><code>import geonate\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>print('Hello World!')\n</pre> print('Hello World!') <pre>Hello World!\n</pre>"}]}