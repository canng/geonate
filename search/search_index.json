{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geonate","text":"<p>Python package synthesizes conventional tools and codes for image processing</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://canng.github.io/geonate</li> </ul>"},{"location":"#features","title":"Features","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <p>New Features:</p>"},{"location":"classify/","title":"classify module","text":"<p>Classification module.</p>"},{"location":"classify/#geonate.classify.Gaussian_Naive_Bayes","title":"<code> Gaussian_Naive_Bayes        </code>","text":"<p>A class to implement Gaussian Naive Bayes classifier for training, tuning, and classification tasks.</p> Source code in <code>geonate/classify.py</code> <pre><code>class Gaussian_Naive_Bayes:\n    \"\"\"\n    A class to implement Gaussian Naive Bayes classifier for training, tuning, and classification tasks.\n\n    \"\"\"\n    def __init__(self, X_train, y_train, X_test, y_test):\n        \"\"\"\n        Initialize the Gaussian_Naive_Bayes class with training and testing data.\n\n        Args:\n            X_train (array-like): Training feature data.\n            y_train (array-like): Training target data.\n            X_test (array-like): Testing feature data.\n            y_test (array-like): Testing target data.\n\n        \"\"\"\n        self.X_train = X_train\n        self.y_train = y_train\n        self.X_test = X_test\n        self.y_test = y_test\n        self.initial_gnb = None\n        self.tuned_gnb = None\n\n        # Automatically run the initial model \n        self.model()\n\n    # Initial model and validation\n    def model(self, **kwargs):\n        \"\"\"\n        Train and validate the initial Gaussian Naive Bayes model.\n\n        Args:\n            **kwargs: Additional keyword arguments for GaussianNB.\n\n        Returns:\n            GaussianNB: The trained Gaussian Naive Bayes model.\n\n        \"\"\"\n        from sklearn.naive_bayes import GaussianNB\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        # Initialize model and fit the model\n        gnb = GaussianNB(**kwargs)\n        gnb.fit(self.X_train, self.y_train)\n\n        # Validate the initial model and return validation metrics\n        y_pred = gnb.predict(self.X_test)\n        self.accuracy = accuracy_score(self.y_test, y_pred)\n        self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n        self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.classification_report = classification_report(self.y_test, y_pred)\n\n        self.initial_gnb = gnb\n        return self.initial_gnb\n\n    # Tune the best parameters for classifier using random search or grid search methods\n    def tune(self, method=\"random\", var_smoothing=[1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e-0], n_iter=5, cv=5, n_job=-1):\n        \"\"\"\n        Tune the Gaussian Naive Bayes model using random search or grid search methods.\n\n        Args:\n            method (str): The tuning method to use ('random' or 'grid').\n            var_smoothing (list): List of var_smoothing values to try.\n            n_iter (int): Number of iterations for random search.\n            cv (int): Number of cross-validation folds.\n            n_job (int): Number of jobs to run in parallel.\n\n        Returns:\n            The tuned Gaussian Naive Bayes model.\n\n        \"\"\"\n        from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        paras = [{\n            'var_smoothing': var_smoothing\n        }]\n\n        if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n            random_searched = RandomizedSearchCV(estimator= self.initial_gnb, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n            random_searched.fit(self.X_train, self.y_train)\n            tuned_model = random_searched\n            self.tuned_gnb = tuned_model\n\n        elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n            grid_search = GridSearchCV(estimator= self.initial_gnb, param_grid= paras, cv=cv, scoring='accuracy', verbose=True, n_jobs=-1)\n            grid_search.fit(self.X_train, self.y_train)\n\n            tuned_model = grid_search\n            self.tuned_gnb = tuned_model\n\n        else:\n            raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n        # Validate the initial model and return validation metrics\n        tuned_y_pred = tuned_model.predict(self.X_test)\n        self.tuned_accuracy = accuracy_score(self.y_test, tuned_y_pred)\n        self.tuned_confusion_matrix = confusion_matrix(self.y_test, tuned_y_pred)\n        self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.tuned_classification_report = classification_report(self.y_test, tuned_y_pred)\n\n        return self.tuned_gnb\n\n    # Classify image \n    def classify(self, src, model=None):\n        \"\"\"\n        Classify an image using the Gaussian Naive Bayes model.\n\n        Args:\n            src (rasterio.DatasetReader): The source image to classify.\n            model (GaussianNB, optional): The model to use for classification. If None, the tuned model or initial model will be used.\n\n        Returns:\n            The classified image.\n\n        \"\"\"\n        import rasterio\n        from geonate.common import reshape_raster, array2raster\n\n        # Define the random forest model to use\n        if model is not None:\n            GNB_model = model\n        else: \n            GNB_model = self.tuned_gnb if self.tuned_gnb is not None else self.initial_gnb\n\n        # Define input parameters\n        if not isinstance(src, rasterio.DatasetReader):\n            raise ValueError('Source image is not supported')\n        else: \n            src_meta = src.meta\n            nbands = src.count\n            src_height = src.height\n            src_width = src.width            \n            src_rast = src.read()\n\n            # Reshape and flatten data\n            src_img = reshape_raster(src_rast, mode='image')\n            ds = src_img.reshape((-1, nbands))\n\n            # Predict labels using the defined model\n            pred_labels = GNB_model.predict(ds)\n\n            # Reshape data and convert to raster format\n            pred_result = pred_labels.reshape(src_height, src_width)\n\n            src_meta.update({'count': 1})\n            classified = array2raster(pred_result, metadata=src_meta)            \n\n            return classified\n</code></pre>"},{"location":"classify/#geonate.classify.Gaussian_Naive_Bayes.__init__","title":"<code>__init__(self, X_train, y_train, X_test, y_test)</code>  <code>special</code>","text":"<p>Initialize the Gaussian_Naive_Bayes class with training and testing data.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>array-like</code> <p>Training feature data.</p> required <code>y_train</code> <code>array-like</code> <p>Training target data.</p> required <code>X_test</code> <code>array-like</code> <p>Testing feature data.</p> required <code>y_test</code> <code>array-like</code> <p>Testing target data.</p> required Source code in <code>geonate/classify.py</code> <pre><code>def __init__(self, X_train, y_train, X_test, y_test):\n    \"\"\"\n    Initialize the Gaussian_Naive_Bayes class with training and testing data.\n\n    Args:\n        X_train (array-like): Training feature data.\n        y_train (array-like): Training target data.\n        X_test (array-like): Testing feature data.\n        y_test (array-like): Testing target data.\n\n    \"\"\"\n    self.X_train = X_train\n    self.y_train = y_train\n    self.X_test = X_test\n    self.y_test = y_test\n    self.initial_gnb = None\n    self.tuned_gnb = None\n\n    # Automatically run the initial model \n    self.model()\n</code></pre>"},{"location":"classify/#geonate.classify.Gaussian_Naive_Bayes.classify","title":"<code>classify(self, src, model=None)</code>","text":"<p>Classify an image using the Gaussian Naive Bayes model.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>rasterio.DatasetReader</code> <p>The source image to classify.</p> required <code>model</code> <code>GaussianNB</code> <p>The model to use for classification. If None, the tuned model or initial model will be used.</p> <code>None</code> <p>Returns:</p> Type Description <p>The classified image.</p> Source code in <code>geonate/classify.py</code> <pre><code>def classify(self, src, model=None):\n    \"\"\"\n    Classify an image using the Gaussian Naive Bayes model.\n\n    Args:\n        src (rasterio.DatasetReader): The source image to classify.\n        model (GaussianNB, optional): The model to use for classification. If None, the tuned model or initial model will be used.\n\n    Returns:\n        The classified image.\n\n    \"\"\"\n    import rasterio\n    from geonate.common import reshape_raster, array2raster\n\n    # Define the random forest model to use\n    if model is not None:\n        GNB_model = model\n    else: \n        GNB_model = self.tuned_gnb if self.tuned_gnb is not None else self.initial_gnb\n\n    # Define input parameters\n    if not isinstance(src, rasterio.DatasetReader):\n        raise ValueError('Source image is not supported')\n    else: \n        src_meta = src.meta\n        nbands = src.count\n        src_height = src.height\n        src_width = src.width            \n        src_rast = src.read()\n\n        # Reshape and flatten data\n        src_img = reshape_raster(src_rast, mode='image')\n        ds = src_img.reshape((-1, nbands))\n\n        # Predict labels using the defined model\n        pred_labels = GNB_model.predict(ds)\n\n        # Reshape data and convert to raster format\n        pred_result = pred_labels.reshape(src_height, src_width)\n\n        src_meta.update({'count': 1})\n        classified = array2raster(pred_result, metadata=src_meta)            \n\n        return classified\n</code></pre>"},{"location":"classify/#geonate.classify.Gaussian_Naive_Bayes.model","title":"<code>model(self, **kwargs)</code>","text":"<p>Train and validate the initial Gaussian Naive Bayes model.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments for GaussianNB.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GaussianNB</code> <p>The trained Gaussian Naive Bayes model.</p> Source code in <code>geonate/classify.py</code> <pre><code>def model(self, **kwargs):\n    \"\"\"\n    Train and validate the initial Gaussian Naive Bayes model.\n\n    Args:\n        **kwargs: Additional keyword arguments for GaussianNB.\n\n    Returns:\n        GaussianNB: The trained Gaussian Naive Bayes model.\n\n    \"\"\"\n    from sklearn.naive_bayes import GaussianNB\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    # Initialize model and fit the model\n    gnb = GaussianNB(**kwargs)\n    gnb.fit(self.X_train, self.y_train)\n\n    # Validate the initial model and return validation metrics\n    y_pred = gnb.predict(self.X_test)\n    self.accuracy = accuracy_score(self.y_test, y_pred)\n    self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n    self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.classification_report = classification_report(self.y_test, y_pred)\n\n    self.initial_gnb = gnb\n    return self.initial_gnb\n</code></pre>"},{"location":"classify/#geonate.classify.Gaussian_Naive_Bayes.tune","title":"<code>tune(self, method='random', var_smoothing=[1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10, 1e-09, 1e-08, 1e-07, 1e-06, 1e-05, 0.0001, 0.001, 0.01, 0.1, 1.0], n_iter=5, cv=5, n_job=-1)</code>","text":"<p>Tune the Gaussian Naive Bayes model using random search or grid search methods.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The tuning method to use ('random' or 'grid').</p> <code>'random'</code> <code>var_smoothing</code> <code>list</code> <p>List of var_smoothing values to try.</p> <code>[1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10, 1e-09, 1e-08, 1e-07, 1e-06, 1e-05, 0.0001, 0.001, 0.01, 0.1, 1.0]</code> <code>n_iter</code> <code>int</code> <p>Number of iterations for random search.</p> <code>5</code> <code>cv</code> <code>int</code> <p>Number of cross-validation folds.</p> <code>5</code> <code>n_job</code> <code>int</code> <p>Number of jobs to run in parallel.</p> <code>-1</code> <p>Returns:</p> Type Description <p>The tuned Gaussian Naive Bayes model.</p> Source code in <code>geonate/classify.py</code> <pre><code>def tune(self, method=\"random\", var_smoothing=[1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e-0], n_iter=5, cv=5, n_job=-1):\n    \"\"\"\n    Tune the Gaussian Naive Bayes model using random search or grid search methods.\n\n    Args:\n        method (str): The tuning method to use ('random' or 'grid').\n        var_smoothing (list): List of var_smoothing values to try.\n        n_iter (int): Number of iterations for random search.\n        cv (int): Number of cross-validation folds.\n        n_job (int): Number of jobs to run in parallel.\n\n    Returns:\n        The tuned Gaussian Naive Bayes model.\n\n    \"\"\"\n    from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    paras = [{\n        'var_smoothing': var_smoothing\n    }]\n\n    if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n        random_searched = RandomizedSearchCV(estimator= self.initial_gnb, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n        random_searched.fit(self.X_train, self.y_train)\n        tuned_model = random_searched\n        self.tuned_gnb = tuned_model\n\n    elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n        grid_search = GridSearchCV(estimator= self.initial_gnb, param_grid= paras, cv=cv, scoring='accuracy', verbose=True, n_jobs=-1)\n        grid_search.fit(self.X_train, self.y_train)\n\n        tuned_model = grid_search\n        self.tuned_gnb = tuned_model\n\n    else:\n        raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n    # Validate the initial model and return validation metrics\n    tuned_y_pred = tuned_model.predict(self.X_test)\n    self.tuned_accuracy = accuracy_score(self.y_test, tuned_y_pred)\n    self.tuned_confusion_matrix = confusion_matrix(self.y_test, tuned_y_pred)\n    self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.tuned_classification_report = classification_report(self.y_test, tuned_y_pred)\n\n    return self.tuned_gnb\n</code></pre>"},{"location":"classify/#geonate.classify.KNN","title":"<code> KNN        </code>","text":"<p>A class that encapsulates a K-Nearest Neighbors (KNN) model for classification tasks, including model training, hyperparameter tuning using grid or random search, and classification of image data.</p> <p>Attributes:</p> Name Type Description <code>X_train</code> <code>ndarray or DataFrame</code> <p>The training features for model fitting.</p> <code>y_train</code> <code>ndarray or Series</code> <p>The training labels for model fitting.</p> <code>X_test</code> <code>ndarray or DataFrame</code> <p>The test features for model validation.</p> <code>y_test</code> <code>ndarray or Series</code> <p>The test labels for model validation.</p> <code>initial_knn</code> <code>KNeighborsClassifier</code> <p>The initial KNN model (untuned).</p> <code>tuned_knn</code> <code>KNeighborsClassifier</code> <p>The KNN model after tuning using grid or random search.</p> <code>accuracy</code> <code>float</code> <p>Accuracy of the initial (naive) KNN model.</p> <code>confusion_matrix</code> <code>ndarray</code> <p>Confusion matrix of the initial (naive) KNN model.</p> <code>confusion_matrix_percent</code> <code>ndarray</code> <p>Percent-based confusion matrix for the initial (naive) model.</p> <code>tuned_accuracy</code> <code>float</code> <p>Accuracy of the tuned KNN model.</p> <code>tuned_confusion_matrix</code> <code>ndarray</code> <p>Confusion matrix of the tuned KNN model.</p> <code>tuned_confusion_matrix_percent</code> <code>ndarray</code> <p>Percent-based confusion matrix for the tuned model.</p> Source code in <code>geonate/classify.py</code> <pre><code>class KNN:\n    \"\"\"\n    A class that encapsulates a K-Nearest Neighbors (KNN) model for classification tasks, including model training,\n    hyperparameter tuning using grid or random search, and classification of image data.\n\n    Attributes:\n        X_train (ndarray or DataFrame): The training features for model fitting.\n        y_train (ndarray or Series): The training labels for model fitting.\n        X_test (ndarray or DataFrame): The test features for model validation.\n        y_test (ndarray or Series): The test labels for model validation.\n        initial_knn (KNeighborsClassifier, optional): The initial KNN model (untuned).\n        tuned_knn (KNeighborsClassifier, optional): The KNN model after tuning using grid or random search.\n        accuracy (float, optional): Accuracy of the initial (naive) KNN model.\n        confusion_matrix (ndarray, optional): Confusion matrix of the initial (naive) KNN model.\n        confusion_matrix_percent (ndarray, optional): Percent-based confusion matrix for the initial (naive) model.\n        tuned_accuracy (float, optional): Accuracy of the tuned KNN model.\n        tuned_confusion_matrix (ndarray, optional): Confusion matrix of the tuned KNN model.\n        tuned_confusion_matrix_percent (ndarray, optional): Percent-based confusion matrix for the tuned model.\n\n    \"\"\"\n    def __init__(self, X_train, y_train, X_test, y_test):\n        \"\"\"\n        Initializes the KNN class with the provided training and testing data.\n\n        Args:\n            X_train (ndarray or DataFrame): The training features for model fitting.\n            y_train (ndarray or Series): The training labels for model fitting.\n            X_test (ndarray or DataFrame): The test features for model validation.\n            y_test (ndarray or Series): The test labels for model validation.\n\n        \"\"\"\n        self.X_train = X_train\n        self.y_train = y_train\n        self.X_test = X_test\n        self.y_test = y_test\n        self.initial_knn = None\n        self.tuned_knn = None\n\n        # Automatically run the initial model \n        self.model()\n\n    # Initial model and validation\n    def model(self, **kwargs):\n        \"\"\"\n        Trains and validates the initial KNN model.\n\n        Args:\n            **kwargs: Additional keyword arguments for the KNeighborsClassifier model.\n\n        Returns:\n            KNeighborsClassifier: The trained KNN model.\n\n        \"\"\"\n        from sklearn.neighbors import KNeighborsClassifier\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        # Initialize model and fit the model\n        knn = KNeighborsClassifier(**kwargs)\n        knn.fit(self.X_train, self.y_train)\n\n        # Validate the initial model and return validation metrics\n        y_pred = knn.predict(self.X_test)\n        self.accuracy = accuracy_score(self.y_test, y_pred)\n        self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n        self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.classification_report = classification_report(self.y_test, y_pred)\n\n        self.initial_knn = knn\n        return self.initial_knn\n\n    # Tune the best parameters for classifier using random search or grid search methods\n    def tune(self, method=\"random\", n_neighbors=[3, 5, 7, 9, 11], weights= ['uniform', 'distance'],n_iter=5, cv=5, n_job=-1):\n        \"\"\"\n        Tunes the best parameters for the KNN classifier using random search or grid search methods.\n\n        Args:\n            method (str): The tuning method to use ('random' or 'grid'). Default is 'random'.\n            n_neighbors (list): List of values for the number of neighbors to use. Default is [3, 5, 7, 9, 11].\n            weights (list): List of weight functions used in prediction. Default is ['uniform', 'distance'].\n            n_iter (int): Number of parameter settings that are sampled in random search. Default is 5.\n            cv (int): Number of cross-validation folds. Default is 5.\n            n_jobs (int): Number of jobs to run in parallel. Default is -1 (use all processors).\n\n        Returns:\n            KNeighborsClassifier: The tuned KNN model.\n\n        \"\"\"\n        from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        paras = [{\n            'n_neighbors': n_neighbors,\n            'weights': weights\n        }]\n\n        if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n            random_searched = RandomizedSearchCV(estimator= self.initial_knn, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n            random_searched.fit(self.X_train, self.y_train)\n            tuned_model = random_searched\n            self.tuned_knn = tuned_model\n\n        elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n            grid_search = GridSearchCV(estimator= self.initial_knn, param_grid= paras, cv=cv, verbose=True, n_jobs=-1, scoring='accuracy')\n            grid_search.fit(self.X_train, self.y_train)\n\n            tuned_model = grid_search\n            self.tuned_knn = tuned_model\n\n        else:\n            raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n        # Validate the initial model and return validation metrics\n        tuned_y_pred = tuned_model.predict(self.X_test)\n        self.tuned_accuracy = accuracy_score(self.y_test, tuned_y_pred)\n        self.tuned_confusion_matrix = confusion_matrix(self.y_test, tuned_y_pred)\n        self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.tuned_classification_report = classification_report(self.y_test, tuned_y_pred)\n\n        return self.tuned_knn\n\n    # Classify image \n    def classify(self, src, model=None):\n        \"\"\"\n        Classifies an image using the trained or tuned KNN model.\n\n        Args:\n            src (rasterio.DatasetReader): A rasterio object representing the image to classify.\n            model (KNeighborsClassifier, optional): Trained KNN model to classify the image. If None, uses the tuned KNN model if available, otherwise the naive KNN model.\n\n        Returns:\n            rasterio.DatasetReader: The classified image as a raster object.\n\n        \"\"\"\n        import rasterio\n        from geonate.common import reshape_raster, array2raster\n\n        # Define the model to use\n        if model is not None:\n            KNN_model = model\n        else: \n            KNN_model = self.tuned_knn if self.tuned_knn is not None else self.initial_knn\n\n        # Define input parameters\n        if not isinstance(src, rasterio.DatasetReader):\n            raise ValueError('Source image is not supported')\n        else: \n            src_meta = src.meta\n            nbands = src.count\n            src_height = src.height\n            src_width = src.width            \n            src_rast = src.read()\n\n            # Reshape and flatten data\n            src_img = reshape_raster(src_rast, mode='image')\n            ds = src_img.reshape((-1, nbands))\n\n            # Predict labels using the define model\n            pred_labels = KNN_model.predict(ds)\n\n            # Reshape data and convert to raster format\n            pred_result = pred_labels.reshape(src_height, src_width)\n\n            src_meta.update({'count': 1})\n            classified = array2raster(pred_result, metadata=src_meta)            \n\n            return classified\n</code></pre>"},{"location":"classify/#geonate.classify.KNN.__init__","title":"<code>__init__(self, X_train, y_train, X_test, y_test)</code>  <code>special</code>","text":"<p>Initializes the KNN class with the provided training and testing data.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>ndarray or DataFrame</code> <p>The training features for model fitting.</p> required <code>y_train</code> <code>ndarray or Series</code> <p>The training labels for model fitting.</p> required <code>X_test</code> <code>ndarray or DataFrame</code> <p>The test features for model validation.</p> required <code>y_test</code> <code>ndarray or Series</code> <p>The test labels for model validation.</p> required Source code in <code>geonate/classify.py</code> <pre><code>def __init__(self, X_train, y_train, X_test, y_test):\n    \"\"\"\n    Initializes the KNN class with the provided training and testing data.\n\n    Args:\n        X_train (ndarray or DataFrame): The training features for model fitting.\n        y_train (ndarray or Series): The training labels for model fitting.\n        X_test (ndarray or DataFrame): The test features for model validation.\n        y_test (ndarray or Series): The test labels for model validation.\n\n    \"\"\"\n    self.X_train = X_train\n    self.y_train = y_train\n    self.X_test = X_test\n    self.y_test = y_test\n    self.initial_knn = None\n    self.tuned_knn = None\n\n    # Automatically run the initial model \n    self.model()\n</code></pre>"},{"location":"classify/#geonate.classify.KNN.classify","title":"<code>classify(self, src, model=None)</code>","text":"<p>Classifies an image using the trained or tuned KNN model.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>rasterio.DatasetReader</code> <p>A rasterio object representing the image to classify.</p> required <code>model</code> <code>KNeighborsClassifier</code> <p>Trained KNN model to classify the image. If None, uses the tuned KNN model if available, otherwise the naive KNN model.</p> <code>None</code> <p>Returns:</p> Type Description <code>rasterio.DatasetReader</code> <p>The classified image as a raster object.</p> Source code in <code>geonate/classify.py</code> <pre><code>def classify(self, src, model=None):\n    \"\"\"\n    Classifies an image using the trained or tuned KNN model.\n\n    Args:\n        src (rasterio.DatasetReader): A rasterio object representing the image to classify.\n        model (KNeighborsClassifier, optional): Trained KNN model to classify the image. If None, uses the tuned KNN model if available, otherwise the naive KNN model.\n\n    Returns:\n        rasterio.DatasetReader: The classified image as a raster object.\n\n    \"\"\"\n    import rasterio\n    from geonate.common import reshape_raster, array2raster\n\n    # Define the model to use\n    if model is not None:\n        KNN_model = model\n    else: \n        KNN_model = self.tuned_knn if self.tuned_knn is not None else self.initial_knn\n\n    # Define input parameters\n    if not isinstance(src, rasterio.DatasetReader):\n        raise ValueError('Source image is not supported')\n    else: \n        src_meta = src.meta\n        nbands = src.count\n        src_height = src.height\n        src_width = src.width            \n        src_rast = src.read()\n\n        # Reshape and flatten data\n        src_img = reshape_raster(src_rast, mode='image')\n        ds = src_img.reshape((-1, nbands))\n\n        # Predict labels using the define model\n        pred_labels = KNN_model.predict(ds)\n\n        # Reshape data and convert to raster format\n        pred_result = pred_labels.reshape(src_height, src_width)\n\n        src_meta.update({'count': 1})\n        classified = array2raster(pred_result, metadata=src_meta)            \n\n        return classified\n</code></pre>"},{"location":"classify/#geonate.classify.KNN.model","title":"<code>model(self, **kwargs)</code>","text":"<p>Trains and validates the initial KNN model.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments for the KNeighborsClassifier model.</p> <code>{}</code> <p>Returns:</p> Type Description <code>KNeighborsClassifier</code> <p>The trained KNN model.</p> Source code in <code>geonate/classify.py</code> <pre><code>def model(self, **kwargs):\n    \"\"\"\n    Trains and validates the initial KNN model.\n\n    Args:\n        **kwargs: Additional keyword arguments for the KNeighborsClassifier model.\n\n    Returns:\n        KNeighborsClassifier: The trained KNN model.\n\n    \"\"\"\n    from sklearn.neighbors import KNeighborsClassifier\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    # Initialize model and fit the model\n    knn = KNeighborsClassifier(**kwargs)\n    knn.fit(self.X_train, self.y_train)\n\n    # Validate the initial model and return validation metrics\n    y_pred = knn.predict(self.X_test)\n    self.accuracy = accuracy_score(self.y_test, y_pred)\n    self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n    self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.classification_report = classification_report(self.y_test, y_pred)\n\n    self.initial_knn = knn\n    return self.initial_knn\n</code></pre>"},{"location":"classify/#geonate.classify.KNN.tune","title":"<code>tune(self, method='random', n_neighbors=[3, 5, 7, 9, 11], weights=['uniform', 'distance'], n_iter=5, cv=5, n_job=-1)</code>","text":"<p>Tunes the best parameters for the KNN classifier using random search or grid search methods.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The tuning method to use ('random' or 'grid'). Default is 'random'.</p> <code>'random'</code> <code>n_neighbors</code> <code>list</code> <p>List of values for the number of neighbors to use. Default is [3, 5, 7, 9, 11].</p> <code>[3, 5, 7, 9, 11]</code> <code>weights</code> <code>list</code> <p>List of weight functions used in prediction. Default is ['uniform', 'distance'].</p> <code>['uniform', 'distance']</code> <code>n_iter</code> <code>int</code> <p>Number of parameter settings that are sampled in random search. Default is 5.</p> <code>5</code> <code>cv</code> <code>int</code> <p>Number of cross-validation folds. Default is 5.</p> <code>5</code> <code>n_jobs</code> <code>int</code> <p>Number of jobs to run in parallel. Default is -1 (use all processors).</p> required <p>Returns:</p> Type Description <code>KNeighborsClassifier</code> <p>The tuned KNN model.</p> Source code in <code>geonate/classify.py</code> <pre><code>def tune(self, method=\"random\", n_neighbors=[3, 5, 7, 9, 11], weights= ['uniform', 'distance'],n_iter=5, cv=5, n_job=-1):\n    \"\"\"\n    Tunes the best parameters for the KNN classifier using random search or grid search methods.\n\n    Args:\n        method (str): The tuning method to use ('random' or 'grid'). Default is 'random'.\n        n_neighbors (list): List of values for the number of neighbors to use. Default is [3, 5, 7, 9, 11].\n        weights (list): List of weight functions used in prediction. Default is ['uniform', 'distance'].\n        n_iter (int): Number of parameter settings that are sampled in random search. Default is 5.\n        cv (int): Number of cross-validation folds. Default is 5.\n        n_jobs (int): Number of jobs to run in parallel. Default is -1 (use all processors).\n\n    Returns:\n        KNeighborsClassifier: The tuned KNN model.\n\n    \"\"\"\n    from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    paras = [{\n        'n_neighbors': n_neighbors,\n        'weights': weights\n    }]\n\n    if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n        random_searched = RandomizedSearchCV(estimator= self.initial_knn, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n        random_searched.fit(self.X_train, self.y_train)\n        tuned_model = random_searched\n        self.tuned_knn = tuned_model\n\n    elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n        grid_search = GridSearchCV(estimator= self.initial_knn, param_grid= paras, cv=cv, verbose=True, n_jobs=-1, scoring='accuracy')\n        grid_search.fit(self.X_train, self.y_train)\n\n        tuned_model = grid_search\n        self.tuned_knn = tuned_model\n\n    else:\n        raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n    # Validate the initial model and return validation metrics\n    tuned_y_pred = tuned_model.predict(self.X_test)\n    self.tuned_accuracy = accuracy_score(self.y_test, tuned_y_pred)\n    self.tuned_confusion_matrix = confusion_matrix(self.y_test, tuned_y_pred)\n    self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.tuned_classification_report = classification_report(self.y_test, tuned_y_pred)\n\n    return self.tuned_knn\n</code></pre>"},{"location":"classify/#geonate.classify.RandomForest","title":"<code> RandomForest        </code>","text":"<p>A class that encapsulates a Random Forest model for classification tasks, including model training, hyperparameter tuning using grid or random search, and classification of image data.</p> <p>Attributes:</p> Name Type Description <code>X_train</code> <code>ndarray or DataFrame</code> <p>The training features for model fitting.</p> <code>y_train</code> <code>ndarray or Series</code> <p>The training labels for model fitting.</p> <code>X_test</code> <code>ndarray or DataFrame</code> <p>The test features for model validation.</p> <code>y_test</code> <code>ndarray or Series</code> <p>The test labels for model validation.</p> <code>initial_rf</code> <code>RandomForestClassifier</code> <p>The initial Random Forest model (untuned).</p> <code>tuned_rf</code> <code>RandomForestClassifier</code> <p>The Random Forest model after tuning using grid or random search.</p> <code>accuracy</code> <code>float</code> <p>Accuracy of the initial (naive) Random Forest model.</p> <code>confusion_matrix</code> <code>ndarray</code> <p>Confusion matrix of the initial (naive) Random Forest model.</p> <code>confusion_matrix_percent</code> <code>ndarray</code> <p>Percent-based confusion matrix for the initial (naive) model.</p> <code>tuned_accuracy</code> <code>float</code> <p>Accuracy of the tuned Random Forest model.</p> <code>tuned_confusion_matrix</code> <code>ndarray</code> <p>Confusion matrix of the tuned Random Forest model.</p> <code>tuned_confusion_matrix_percent</code> <code>ndarray</code> <p>Percent-based confusion matrix for the tuned model.</p> Source code in <code>geonate/classify.py</code> <pre><code>class RandomForest:\n    \"\"\"\n    A class that encapsulates a Random Forest model for classification tasks, including model training,\n    hyperparameter tuning using grid or random search, and classification of image data.\n\n    Attributes:\n        X_train (ndarray or DataFrame): The training features for model fitting.\n        y_train (ndarray or Series): The training labels for model fitting.\n        X_test (ndarray or DataFrame): The test features for model validation.\n        y_test (ndarray or Series): The test labels for model validation.\n        initial_rf (RandomForestClassifier, optional): The initial Random Forest model (untuned).\n        tuned_rf (RandomForestClassifier, optional): The Random Forest model after tuning using grid or random search.\n        accuracy (float, optional): Accuracy of the initial (naive) Random Forest model.\n        confusion_matrix (ndarray, optional): Confusion matrix of the initial (naive) Random Forest model.\n        confusion_matrix_percent (ndarray, optional): Percent-based confusion matrix for the initial (naive) model.\n        tuned_accuracy (float, optional): Accuracy of the tuned Random Forest model.\n        tuned_confusion_matrix (ndarray, optional): Confusion matrix of the tuned Random Forest model.\n        tuned_confusion_matrix_percent (ndarray, optional): Percent-based confusion matrix for the tuned model.\n\n    \"\"\"\n    def __init__(self, X_train, y_train, X_test, y_test):\n        \"\"\"\n        Initializes the RandomForest class with the provided training and testing data.\n\n        Args:\n            X_train (ndarray or DataFrame): The training features for model fitting.\n            y_train (ndarray or Series): The training labels for model fitting.\n            X_test (ndarray or DataFrame): The test features for model validation.\n            y_test (ndarray or Series): The test labels for model validation.\n        \"\"\"\n        self.X_train = X_train\n        self.y_train = y_train\n        self.X_test = X_test\n        self.y_test = y_test\n        self.initial_rf = None\n        self.tuned_rf = None\n\n        # Automatically run the initial model \n        self.model()\n\n    # Initial model and validation\n    def model(self, n_estimators=100,**kwargs):\n        \"\"\"\n        Trains a random forest classifier with the provided hyperparameters and validates it.\n\n        Args:\n            n_estimators (int, optional): The number of trees in the forest. Default is 100.\n            **kwargs: Additional keyword arguments passed to the RandomForestClassifier.\n\n        Returns:\n            RandomForestClassifier: The trained (naive) random forest classifier.\n\n        \"\"\"\n        from sklearn.ensemble import RandomForestClassifier\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        # Initialize model and fit the model\n        rf = RandomForestClassifier(n_estimators= n_estimators, **kwargs)\n        rf.fit(self.X_train, self.y_train)\n\n        # Validate the initial model and return validation metrics\n        y_pred = rf.predict(self.X_test)\n        self.accuracy = accuracy_score(self.y_test, y_pred)\n        self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n        self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.classification_report = classification_report(self.y_test, y_pred)\n\n        self.initial_rf = rf\n        return self.initial_rf\n\n    # Tune the best parameters for classifier using random search or grid search methods\n    def tune(self, method=\"random\", n_estimators=[100, 200, 300, 500, 1000], max_depth=[None, 10, 20, 30, 50], min_samples_split=[2, 5, 10, 20], min_samples_leaf=[1, 2, 3, 5], max_features= ['sqrt'], n_iter=5, cv=5, n_job=-1):\n        \"\"\"\n        Tunes the Random Forest model's hyperparameters using grid or random search.\n\n        Args:\n            method (str, optional): The method used for hyperparameter search. Can be 'random' or 'grid'. Default is 'random'.\n            n_estimators (list, optional): List of values for the number of trees to search over. Default is [100, 200, 300, 500, 1000].\n            max_depth (list, optional): List of values for the maximum depth of trees. Default is [None].\n            min_samples_split (list, optional): List of values for the minimum number of samples required to split an internal node. Default is [2, 5, 10, 20].\n            min_samples_leaf (list, optional): List of values for the minimum number of samples required to be at a leaf node. Default is [1, 2, 3, 5].\n            max_features (list, optional): List of values for the number of features to consider when looking for the best split. Default is ['sqrt'].\n            n_iter (int, optional): The number of iterations for RandomizedSearchCV. Default is 3.\n            cv (int, optional): Cross-validation generator or an iterable. Default is 3.\n            n_jobs (int, optional): The number of jobs to run in parallel. Default is -1 (use all processors).\n\n        Returns:\n            RandomForestClassifier: The tuned Random Forest classifier.\n\n        \"\"\"\n        from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        paras = [{\n            'n_estimators': n_estimators,\n            'max_depth': max_depth,\n            'min_samples_split': min_samples_split,\n            'min_samples_leaf': min_samples_leaf,\n            'max_features': max_features\n        }]\n\n        if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n            random_searched = RandomizedSearchCV(estimator= self.initial_rf, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n            random_searched.fit(self.X_train, self.y_train)\n            tuned_model = random_searched\n            self.tuned_rf = tuned_model\n\n        elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n            grid_search = GridSearchCV(estimator= self.initial_rf, param_grid= paras, cv=cv, scoring='accuracy', verbose=True, n_jobs=-1)\n            grid_search.fit(self.X_train, self.y_train)\n\n            tuned_model = grid_search\n            self.tuned_rf = tuned_model\n\n        else:\n            raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n        # Validate the initial model and return validation metrics\n        tunded_y_pred = tuned_model.predict(self.X_test)\n        self.tuned_accuracy = accuracy_score(self.y_test, tunded_y_pred)\n        self.tuned_confusion_matrix = confusion_matrix(self.y_test, tunded_y_pred)\n        self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.tuned_classification_report = classification_report(self.y_test, tunded_y_pred)\n\n        return self.tuned_rf\n\n    # Classify image \n    def classify(self, src, model=None):\n        \"\"\"\n        Classifies an image using the trained or tuned Random Forest model.\n\n        Args:\n            src (rasterio.DatasetReader): A rasterio object representing the image to classify.\n            model (object): trained Random forest model to classify image.\n\n        Returns:\n            rasterio.DatasetReader: The classified image as a raster object.\n\n        \"\"\"\n        import rasterio\n        from .common import reshape_raster, array2raster\n\n        # Define the model to use\n        if model is not None:\n            RF_model = model\n        else: \n            RF_model = self.tuned_rf if self.tuned_rf is not None else self.initial_rf\n\n        # Define input parameters\n        if not isinstance(src, rasterio.DatasetReader):\n            raise ValueError('Source image is not supported')\n        else: \n            src_meta = src.meta\n            nbands = src.count\n            src_height = src.height\n            src_width = src.width            \n            src_rast = src.read()\n\n            # Reshape and flatten data\n            src_img = reshape_raster(src_rast, mode='image')\n            ds = src_img.reshape((-1, nbands))\n\n            # Predict labels using the define model\n            pred_labels = RF_model.predict(ds)\n\n            # Reshape data and convert to raster format\n            pred_result = pred_labels.reshape(src_height, src_width)\n\n            src_meta.update({'count': 1})\n            classified = array2raster(pred_result, metadata=src_meta)            \n\n            return classified\n</code></pre>"},{"location":"classify/#geonate.classify.RandomForest.__init__","title":"<code>__init__(self, X_train, y_train, X_test, y_test)</code>  <code>special</code>","text":"<p>Initializes the RandomForest class with the provided training and testing data.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>ndarray or DataFrame</code> <p>The training features for model fitting.</p> required <code>y_train</code> <code>ndarray or Series</code> <p>The training labels for model fitting.</p> required <code>X_test</code> <code>ndarray or DataFrame</code> <p>The test features for model validation.</p> required <code>y_test</code> <code>ndarray or Series</code> <p>The test labels for model validation.</p> required Source code in <code>geonate/classify.py</code> <pre><code>def __init__(self, X_train, y_train, X_test, y_test):\n    \"\"\"\n    Initializes the RandomForest class with the provided training and testing data.\n\n    Args:\n        X_train (ndarray or DataFrame): The training features for model fitting.\n        y_train (ndarray or Series): The training labels for model fitting.\n        X_test (ndarray or DataFrame): The test features for model validation.\n        y_test (ndarray or Series): The test labels for model validation.\n    \"\"\"\n    self.X_train = X_train\n    self.y_train = y_train\n    self.X_test = X_test\n    self.y_test = y_test\n    self.initial_rf = None\n    self.tuned_rf = None\n\n    # Automatically run the initial model \n    self.model()\n</code></pre>"},{"location":"classify/#geonate.classify.RandomForest.classify","title":"<code>classify(self, src, model=None)</code>","text":"<p>Classifies an image using the trained or tuned Random Forest model.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>rasterio.DatasetReader</code> <p>A rasterio object representing the image to classify.</p> required <code>model</code> <code>object</code> <p>trained Random forest model to classify image.</p> <code>None</code> <p>Returns:</p> Type Description <code>rasterio.DatasetReader</code> <p>The classified image as a raster object.</p> Source code in <code>geonate/classify.py</code> <pre><code>def classify(self, src, model=None):\n    \"\"\"\n    Classifies an image using the trained or tuned Random Forest model.\n\n    Args:\n        src (rasterio.DatasetReader): A rasterio object representing the image to classify.\n        model (object): trained Random forest model to classify image.\n\n    Returns:\n        rasterio.DatasetReader: The classified image as a raster object.\n\n    \"\"\"\n    import rasterio\n    from .common import reshape_raster, array2raster\n\n    # Define the model to use\n    if model is not None:\n        RF_model = model\n    else: \n        RF_model = self.tuned_rf if self.tuned_rf is not None else self.initial_rf\n\n    # Define input parameters\n    if not isinstance(src, rasterio.DatasetReader):\n        raise ValueError('Source image is not supported')\n    else: \n        src_meta = src.meta\n        nbands = src.count\n        src_height = src.height\n        src_width = src.width            \n        src_rast = src.read()\n\n        # Reshape and flatten data\n        src_img = reshape_raster(src_rast, mode='image')\n        ds = src_img.reshape((-1, nbands))\n\n        # Predict labels using the define model\n        pred_labels = RF_model.predict(ds)\n\n        # Reshape data and convert to raster format\n        pred_result = pred_labels.reshape(src_height, src_width)\n\n        src_meta.update({'count': 1})\n        classified = array2raster(pred_result, metadata=src_meta)            \n\n        return classified\n</code></pre>"},{"location":"classify/#geonate.classify.RandomForest.model","title":"<code>model(self, n_estimators=100, **kwargs)</code>","text":"<p>Trains a random forest classifier with the provided hyperparameters and validates it.</p> <p>Parameters:</p> Name Type Description Default <code>n_estimators</code> <code>int</code> <p>The number of trees in the forest. Default is 100.</p> <code>100</code> <code>**kwargs</code> <p>Additional keyword arguments passed to the RandomForestClassifier.</p> <code>{}</code> <p>Returns:</p> Type Description <code>RandomForestClassifier</code> <p>The trained (naive) random forest classifier.</p> Source code in <code>geonate/classify.py</code> <pre><code>def model(self, n_estimators=100,**kwargs):\n    \"\"\"\n    Trains a random forest classifier with the provided hyperparameters and validates it.\n\n    Args:\n        n_estimators (int, optional): The number of trees in the forest. Default is 100.\n        **kwargs: Additional keyword arguments passed to the RandomForestClassifier.\n\n    Returns:\n        RandomForestClassifier: The trained (naive) random forest classifier.\n\n    \"\"\"\n    from sklearn.ensemble import RandomForestClassifier\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    # Initialize model and fit the model\n    rf = RandomForestClassifier(n_estimators= n_estimators, **kwargs)\n    rf.fit(self.X_train, self.y_train)\n\n    # Validate the initial model and return validation metrics\n    y_pred = rf.predict(self.X_test)\n    self.accuracy = accuracy_score(self.y_test, y_pred)\n    self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n    self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.classification_report = classification_report(self.y_test, y_pred)\n\n    self.initial_rf = rf\n    return self.initial_rf\n</code></pre>"},{"location":"classify/#geonate.classify.RandomForest.tune","title":"<code>tune(self, method='random', n_estimators=[100, 200, 300, 500, 1000], max_depth=[None, 10, 20, 30, 50], min_samples_split=[2, 5, 10, 20], min_samples_leaf=[1, 2, 3, 5], max_features=['sqrt'], n_iter=5, cv=5, n_job=-1)</code>","text":"<p>Tunes the Random Forest model's hyperparameters using grid or random search.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The method used for hyperparameter search. Can be 'random' or 'grid'. Default is 'random'.</p> <code>'random'</code> <code>n_estimators</code> <code>list</code> <p>List of values for the number of trees to search over. Default is [100, 200, 300, 500, 1000].</p> <code>[100, 200, 300, 500, 1000]</code> <code>max_depth</code> <code>list</code> <p>List of values for the maximum depth of trees. Default is [None].</p> <code>[None, 10, 20, 30, 50]</code> <code>min_samples_split</code> <code>list</code> <p>List of values for the minimum number of samples required to split an internal node. Default is [2, 5, 10, 20].</p> <code>[2, 5, 10, 20]</code> <code>min_samples_leaf</code> <code>list</code> <p>List of values for the minimum number of samples required to be at a leaf node. Default is [1, 2, 3, 5].</p> <code>[1, 2, 3, 5]</code> <code>max_features</code> <code>list</code> <p>List of values for the number of features to consider when looking for the best split. Default is ['sqrt'].</p> <code>['sqrt']</code> <code>n_iter</code> <code>int</code> <p>The number of iterations for RandomizedSearchCV. Default is 3.</p> <code>5</code> <code>cv</code> <code>int</code> <p>Cross-validation generator or an iterable. Default is 3.</p> <code>5</code> <code>n_jobs</code> <code>int</code> <p>The number of jobs to run in parallel. Default is -1 (use all processors).</p> required <p>Returns:</p> Type Description <code>RandomForestClassifier</code> <p>The tuned Random Forest classifier.</p> Source code in <code>geonate/classify.py</code> <pre><code>def tune(self, method=\"random\", n_estimators=[100, 200, 300, 500, 1000], max_depth=[None, 10, 20, 30, 50], min_samples_split=[2, 5, 10, 20], min_samples_leaf=[1, 2, 3, 5], max_features= ['sqrt'], n_iter=5, cv=5, n_job=-1):\n    \"\"\"\n    Tunes the Random Forest model's hyperparameters using grid or random search.\n\n    Args:\n        method (str, optional): The method used for hyperparameter search. Can be 'random' or 'grid'. Default is 'random'.\n        n_estimators (list, optional): List of values for the number of trees to search over. Default is [100, 200, 300, 500, 1000].\n        max_depth (list, optional): List of values for the maximum depth of trees. Default is [None].\n        min_samples_split (list, optional): List of values for the minimum number of samples required to split an internal node. Default is [2, 5, 10, 20].\n        min_samples_leaf (list, optional): List of values for the minimum number of samples required to be at a leaf node. Default is [1, 2, 3, 5].\n        max_features (list, optional): List of values for the number of features to consider when looking for the best split. Default is ['sqrt'].\n        n_iter (int, optional): The number of iterations for RandomizedSearchCV. Default is 3.\n        cv (int, optional): Cross-validation generator or an iterable. Default is 3.\n        n_jobs (int, optional): The number of jobs to run in parallel. Default is -1 (use all processors).\n\n    Returns:\n        RandomForestClassifier: The tuned Random Forest classifier.\n\n    \"\"\"\n    from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    paras = [{\n        'n_estimators': n_estimators,\n        'max_depth': max_depth,\n        'min_samples_split': min_samples_split,\n        'min_samples_leaf': min_samples_leaf,\n        'max_features': max_features\n    }]\n\n    if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n        random_searched = RandomizedSearchCV(estimator= self.initial_rf, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n        random_searched.fit(self.X_train, self.y_train)\n        tuned_model = random_searched\n        self.tuned_rf = tuned_model\n\n    elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n        grid_search = GridSearchCV(estimator= self.initial_rf, param_grid= paras, cv=cv, scoring='accuracy', verbose=True, n_jobs=-1)\n        grid_search.fit(self.X_train, self.y_train)\n\n        tuned_model = grid_search\n        self.tuned_rf = tuned_model\n\n    else:\n        raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n    # Validate the initial model and return validation metrics\n    tunded_y_pred = tuned_model.predict(self.X_test)\n    self.tuned_accuracy = accuracy_score(self.y_test, tunded_y_pred)\n    self.tuned_confusion_matrix = confusion_matrix(self.y_test, tunded_y_pred)\n    self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.tuned_classification_report = classification_report(self.y_test, tunded_y_pred)\n\n    return self.tuned_rf\n</code></pre>"},{"location":"classify/#geonate.classify.SVM","title":"<code> SVM        </code>","text":"<p>A class that encapsulates a Support Vector Machine (SVM) model for classification tasks, including model training, hyperparameter tuning using grid or random search, and classification of image data.</p> <p>Attributes:</p> Name Type Description <code>X_train</code> <code>ndarray or DataFrame</code> <p>The training features for model fitting.</p> <code>y_train</code> <code>ndarray or Series</code> <p>The training labels for model fitting.</p> <code>X_test</code> <code>ndarray or DataFrame</code> <p>The test features for model validation.</p> <code>y_test</code> <code>ndarray or Series</code> <p>The test labels for model validation.</p> <code>initial_svm</code> <code>SVC</code> <p>The initial SVM model (untuned).</p> <code>tuned_svm</code> <code>SVC</code> <p>The SVM model after tuning using grid or random search.</p> <code>accuracy</code> <code>float</code> <p>Accuracy of the initial (naive) SVM model.</p> <code>confusion_matrix</code> <code>ndarray</code> <p>Confusion matrix of the initial (naive) SVM model.</p> <code>confusion_matrix_percent</code> <code>ndarray</code> <p>Percent-based confusion matrix for the initial (naive) model.</p> <code>tuned_accuracy</code> <code>float</code> <p>Accuracy of the tuned SVM model.</p> <code>tuned_confusion_matrix</code> <code>ndarray</code> <p>Confusion matrix of the tuned SVM model.</p> <code>tuned_confusion_matrix_percent</code> <code>ndarray</code> <p>Percent-based confusion matrix for the tuned model.</p> Source code in <code>geonate/classify.py</code> <pre><code>class SVM:\n    \"\"\"\n    A class that encapsulates a Support Vector Machine (SVM) model for classification tasks, including model training,\n    hyperparameter tuning using grid or random search, and classification of image data.\n\n    Attributes:\n        X_train (ndarray or DataFrame): The training features for model fitting.\n        y_train (ndarray or Series): The training labels for model fitting.\n        X_test (ndarray or DataFrame): The test features for model validation.\n        y_test (ndarray or Series): The test labels for model validation.\n        initial_svm (SVC, optional): The initial SVM model (untuned).\n        tuned_svm (SVC, optional): The SVM model after tuning using grid or random search.\n        accuracy (float, optional): Accuracy of the initial (naive) SVM model.\n        confusion_matrix (ndarray, optional): Confusion matrix of the initial (naive) SVM model.\n        confusion_matrix_percent (ndarray, optional): Percent-based confusion matrix for the initial (naive) model.\n        tuned_accuracy (float, optional): Accuracy of the tuned SVM model.\n        tuned_confusion_matrix (ndarray, optional): Confusion matrix of the tuned SVM model.\n        tuned_confusion_matrix_percent (ndarray, optional): Percent-based confusion matrix for the tuned model.\n\n    \"\"\"\n    def __init__(self, X_train, y_train, X_test, y_test):\n        \"\"\"\n        Initializes the SVM class with the provided training and testing data.\n\n        Args:\n            X_train (ndarray or DataFrame): The training features for model fitting.\n            y_train (ndarray or Series): The training labels for model fitting.\n            X_test (ndarray or DataFrame): The test features for model validation.\n            y_test (ndarray or Series): The test labels for model validation.\n\n        \"\"\"\n        self.X_train = X_train\n        self.y_train = y_train\n        self.X_test = X_test\n        self.y_test = y_test\n        self.initial_svm = None\n        self.tuned_svm = None\n\n        # Automatically run the initial model \n        self.model()\n\n    # Initial model and validation\n    def model(self, kernel='rbf',**kwargs):\n        \"\"\"\n        Trains and validates the initial SVM model.\n\n        Args:\n            kernel (str): Specifies the kernel type to be used in the algorithm. Default is 'rbf'.\n            **kwargs: Additional keyword arguments for the SVC model.\n\n        Returns:\n            SVC: The trained SVM model.\n\n        \"\"\"\n        from sklearn.svm import SVC\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        # Initialize model and fit the model\n        svm = SVC(kernel=kernel, **kwargs)\n        svm.fit(self.X_train, self.y_train)\n\n        # Validate the initial model and return validation metrics\n        y_pred = svm.predict(self.X_test)\n        self.accuracy = accuracy_score(self.y_test, y_pred)\n        self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n        self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.classification_report = classification_report(self.y_test, y_pred)\n\n        self.initial_svm = svm\n        return self.initial_svm\n\n    # Tune the best parameters for classifier using random search or grid search methods\n    def tune(self, method=\"random\", kernel=['rbf'], C=[1, 2, 4, 8, 10, 16, 32, 64, 100, 128, 1000], gamma=[1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e-0], n_iter=5, cv=5, n_job=-1):\n        \"\"\"\n        Tunes the best parameters for the SVM classifier using random search or grid search methods.\n\n        Args:\n            method (str): The tuning method to use ('random' or 'grid'). Default is 'random'.\n            kernel (list): List of kernel types to be used in the algorithm. Default is ['rbf'].\n            C (list): List of regularization parameters. Default is [1, 2, 4, 8, 10, 16, 32, 64, 100, 128, 1000].\n            gamma (list): List of kernel coefficient values. Default is [1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e-0].\n            n_iter (int): Number of parameter settings that are sampled in random search. Default is 3.\n            cv (int): Number of cross-validation folds. Default is 5.\n            n_job (int): Number of jobs to run in parallel. Default is -1 (use all processors).\n\n        Returns:\n            SVC: The tuned SVM model.\n        \"\"\"\n        from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        paras = [{\n            'kernel': kernel,\n            'C': C,\n            'gamma': gamma\n        }]\n\n        if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n            random_searched = RandomizedSearchCV(estimator= self.initial_svm, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n            random_searched.fit(self.X_train, self.y_train)\n            tuned_model = random_searched\n            self.tuned_svm = tuned_model\n\n        elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n            grid_search = GridSearchCV(estimator= self.initial_svm, param_grid= paras, cv=cv, n_jobs=-1, scoring='accuracy', verbose=True)\n            grid_search.fit(self.X_train, self.y_train)\n\n            tuned_model = grid_search\n            self.tuned_svm = tuned_model\n\n        else:\n            raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n        # Validate the initial model and return validation metrics\n        tuned_y_pred = tuned_model.predict(self.X_test)\n        self.tuned_accuracy = accuracy_score(self.y_test, tuned_y_pred)\n        self.tuned_confusion_matrix = confusion_matrix(self.y_test, tuned_y_pred)\n        self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.tuned_classification_report = classification_report(self.y_test, tuned_y_pred)\n\n        return self.tuned_svm\n\n    # Classify image \n    def classify(self, src, model=None):\n        \"\"\"\n        Classifies an image using the trained or tuned SVM model.\n\n        Args:\n            src (rasterio.DatasetReader): A rasterio object representing the image to classify.\n            model (SVC, optional): Trained SVM model to classify the image. If None, uses the tuned SVM model if available, otherwise the naive SVM model.\n\n        Returns:\n            rasterio.DatasetReader: The classified image as a raster object.\n\n        \"\"\"\n        import rasterio\n        from .common import reshape_raster, array2raster\n\n        # Define the model to use\n        if model is not None:\n            SVM_model = model\n        else: \n            SVM_model = self.tuned_svm if self.tuned_svm is not None else self.initial_svm\n\n        # Define input parameters\n        if not isinstance(src, rasterio.DatasetReader):\n            raise ValueError('Source image is not supported')\n        else: \n            src_meta = src.meta\n            nbands = src.count\n            src_height = src.height\n            src_width = src.width            \n            src_rast = src.read()\n\n            # Reshape and flatten data\n            src_img = reshape_raster(src_rast, mode='image')\n            ds = src_img.reshape((-1, nbands))\n\n            # Predict labels using the define model\n            pred_labels = SVM_model.predict(ds)\n\n            # Reshape data and convert to raster format\n            pred_result = pred_labels.reshape(src_height, src_width)\n\n            src_meta.update({'count': 1})\n            classified = array2raster(pred_result, metadata=src_meta)            \n\n            return classified\n</code></pre>"},{"location":"classify/#geonate.classify.SVM.__init__","title":"<code>__init__(self, X_train, y_train, X_test, y_test)</code>  <code>special</code>","text":"<p>Initializes the SVM class with the provided training and testing data.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>ndarray or DataFrame</code> <p>The training features for model fitting.</p> required <code>y_train</code> <code>ndarray or Series</code> <p>The training labels for model fitting.</p> required <code>X_test</code> <code>ndarray or DataFrame</code> <p>The test features for model validation.</p> required <code>y_test</code> <code>ndarray or Series</code> <p>The test labels for model validation.</p> required Source code in <code>geonate/classify.py</code> <pre><code>def __init__(self, X_train, y_train, X_test, y_test):\n    \"\"\"\n    Initializes the SVM class with the provided training and testing data.\n\n    Args:\n        X_train (ndarray or DataFrame): The training features for model fitting.\n        y_train (ndarray or Series): The training labels for model fitting.\n        X_test (ndarray or DataFrame): The test features for model validation.\n        y_test (ndarray or Series): The test labels for model validation.\n\n    \"\"\"\n    self.X_train = X_train\n    self.y_train = y_train\n    self.X_test = X_test\n    self.y_test = y_test\n    self.initial_svm = None\n    self.tuned_svm = None\n\n    # Automatically run the initial model \n    self.model()\n</code></pre>"},{"location":"classify/#geonate.classify.SVM.classify","title":"<code>classify(self, src, model=None)</code>","text":"<p>Classifies an image using the trained or tuned SVM model.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>rasterio.DatasetReader</code> <p>A rasterio object representing the image to classify.</p> required <code>model</code> <code>SVC</code> <p>Trained SVM model to classify the image. If None, uses the tuned SVM model if available, otherwise the naive SVM model.</p> <code>None</code> <p>Returns:</p> Type Description <code>rasterio.DatasetReader</code> <p>The classified image as a raster object.</p> Source code in <code>geonate/classify.py</code> <pre><code>def classify(self, src, model=None):\n    \"\"\"\n    Classifies an image using the trained or tuned SVM model.\n\n    Args:\n        src (rasterio.DatasetReader): A rasterio object representing the image to classify.\n        model (SVC, optional): Trained SVM model to classify the image. If None, uses the tuned SVM model if available, otherwise the naive SVM model.\n\n    Returns:\n        rasterio.DatasetReader: The classified image as a raster object.\n\n    \"\"\"\n    import rasterio\n    from .common import reshape_raster, array2raster\n\n    # Define the model to use\n    if model is not None:\n        SVM_model = model\n    else: \n        SVM_model = self.tuned_svm if self.tuned_svm is not None else self.initial_svm\n\n    # Define input parameters\n    if not isinstance(src, rasterio.DatasetReader):\n        raise ValueError('Source image is not supported')\n    else: \n        src_meta = src.meta\n        nbands = src.count\n        src_height = src.height\n        src_width = src.width            \n        src_rast = src.read()\n\n        # Reshape and flatten data\n        src_img = reshape_raster(src_rast, mode='image')\n        ds = src_img.reshape((-1, nbands))\n\n        # Predict labels using the define model\n        pred_labels = SVM_model.predict(ds)\n\n        # Reshape data and convert to raster format\n        pred_result = pred_labels.reshape(src_height, src_width)\n\n        src_meta.update({'count': 1})\n        classified = array2raster(pred_result, metadata=src_meta)            \n\n        return classified\n</code></pre>"},{"location":"classify/#geonate.classify.SVM.model","title":"<code>model(self, kernel='rbf', **kwargs)</code>","text":"<p>Trains and validates the initial SVM model.</p> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>str</code> <p>Specifies the kernel type to be used in the algorithm. Default is 'rbf'.</p> <code>'rbf'</code> <code>**kwargs</code> <p>Additional keyword arguments for the SVC model.</p> <code>{}</code> <p>Returns:</p> Type Description <code>SVC</code> <p>The trained SVM model.</p> Source code in <code>geonate/classify.py</code> <pre><code>def model(self, kernel='rbf',**kwargs):\n    \"\"\"\n    Trains and validates the initial SVM model.\n\n    Args:\n        kernel (str): Specifies the kernel type to be used in the algorithm. Default is 'rbf'.\n        **kwargs: Additional keyword arguments for the SVC model.\n\n    Returns:\n        SVC: The trained SVM model.\n\n    \"\"\"\n    from sklearn.svm import SVC\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    # Initialize model and fit the model\n    svm = SVC(kernel=kernel, **kwargs)\n    svm.fit(self.X_train, self.y_train)\n\n    # Validate the initial model and return validation metrics\n    y_pred = svm.predict(self.X_test)\n    self.accuracy = accuracy_score(self.y_test, y_pred)\n    self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n    self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.classification_report = classification_report(self.y_test, y_pred)\n\n    self.initial_svm = svm\n    return self.initial_svm\n</code></pre>"},{"location":"classify/#geonate.classify.SVM.tune","title":"<code>tune(self, method='random', kernel=['rbf'], C=[1, 2, 4, 8, 10, 16, 32, 64, 100, 128, 1000], gamma=[1e-10, 1e-09, 1e-08, 1e-07, 1e-06, 1e-05, 0.0001, 0.001, 0.01, 0.1, 1.0], n_iter=5, cv=5, n_job=-1)</code>","text":"<p>Tunes the best parameters for the SVM classifier using random search or grid search methods.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The tuning method to use ('random' or 'grid'). Default is 'random'.</p> <code>'random'</code> <code>kernel</code> <code>list</code> <p>List of kernel types to be used in the algorithm. Default is ['rbf'].</p> <code>['rbf']</code> <code>C</code> <code>list</code> <p>List of regularization parameters. Default is [1, 2, 4, 8, 10, 16, 32, 64, 100, 128, 1000].</p> <code>[1, 2, 4, 8, 10, 16, 32, 64, 100, 128, 1000]</code> <code>gamma</code> <code>list</code> <p>List of kernel coefficient values. Default is [1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e-0].</p> <code>[1e-10, 1e-09, 1e-08, 1e-07, 1e-06, 1e-05, 0.0001, 0.001, 0.01, 0.1, 1.0]</code> <code>n_iter</code> <code>int</code> <p>Number of parameter settings that are sampled in random search. Default is 3.</p> <code>5</code> <code>cv</code> <code>int</code> <p>Number of cross-validation folds. Default is 5.</p> <code>5</code> <code>n_job</code> <code>int</code> <p>Number of jobs to run in parallel. Default is -1 (use all processors).</p> <code>-1</code> <p>Returns:</p> Type Description <code>SVC</code> <p>The tuned SVM model.</p> Source code in <code>geonate/classify.py</code> <pre><code>def tune(self, method=\"random\", kernel=['rbf'], C=[1, 2, 4, 8, 10, 16, 32, 64, 100, 128, 1000], gamma=[1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e-0], n_iter=5, cv=5, n_job=-1):\n    \"\"\"\n    Tunes the best parameters for the SVM classifier using random search or grid search methods.\n\n    Args:\n        method (str): The tuning method to use ('random' or 'grid'). Default is 'random'.\n        kernel (list): List of kernel types to be used in the algorithm. Default is ['rbf'].\n        C (list): List of regularization parameters. Default is [1, 2, 4, 8, 10, 16, 32, 64, 100, 128, 1000].\n        gamma (list): List of kernel coefficient values. Default is [1e-10, 1e-9, 1e-8, 1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1, 1e-0].\n        n_iter (int): Number of parameter settings that are sampled in random search. Default is 3.\n        cv (int): Number of cross-validation folds. Default is 5.\n        n_job (int): Number of jobs to run in parallel. Default is -1 (use all processors).\n\n    Returns:\n        SVC: The tuned SVM model.\n    \"\"\"\n    from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    paras = [{\n        'kernel': kernel,\n        'C': C,\n        'gamma': gamma\n    }]\n\n    if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n        random_searched = RandomizedSearchCV(estimator= self.initial_svm, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n        random_searched.fit(self.X_train, self.y_train)\n        tuned_model = random_searched\n        self.tuned_svm = tuned_model\n\n    elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n        grid_search = GridSearchCV(estimator= self.initial_svm, param_grid= paras, cv=cv, n_jobs=-1, scoring='accuracy', verbose=True)\n        grid_search.fit(self.X_train, self.y_train)\n\n        tuned_model = grid_search\n        self.tuned_svm = tuned_model\n\n    else:\n        raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n    # Validate the initial model and return validation metrics\n    tuned_y_pred = tuned_model.predict(self.X_test)\n    self.tuned_accuracy = accuracy_score(self.y_test, tuned_y_pred)\n    self.tuned_confusion_matrix = confusion_matrix(self.y_test, tuned_y_pred)\n    self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.tuned_classification_report = classification_report(self.y_test, tuned_y_pred)\n\n    return self.tuned_svm\n</code></pre>"},{"location":"classify/#geonate.classify.XGBoost","title":"<code> XGBoost        </code>","text":"<p>A wrapper class for XGBoost classification, including model training, hyperparameter tuning, and classification of raster images.</p> <p>Attributes:</p> Name Type Description <code>X_train</code> <code>array-like</code> <p>Training feature set.</p> <code>y_train</code> <code>array-like</code> <p>Training labels.</p> <code>X_test</code> <code>array-like</code> <p>Testing feature set.</p> <code>y_test</code> <code>array-like</code> <p>Testing labels.</p> <code>initial_xgb</code> <code>XGBClassifier or None</code> <p>The initial trained XGBoost model.</p> <code>tuned_xgb</code> <code>XGBClassifier or None</code> <p>The tuned XGBoost model (if tuning is performed).</p> <code>accuracy</code> <code>float</code> <p>Accuracy of the initial model on the test set.</p> <code>confusion_matrix</code> <code>ndarray</code> <p>Confusion matrix of the initial model.</p> <code>confusion_matrix_percent</code> <code>ndarray</code> <p>Normalized confusion matrix as percentages.</p> <code>classification_report</code> <code>str</code> <p>Classification report for the initial model.</p> <code>tuned_accuracy</code> <code>float</code> <p>Accuracy of the tuned model.</p> <code>tuned_confusion_matrix</code> <code>ndarray</code> <p>Confusion matrix of the tuned model.</p> <code>tuned_confusion_matrix_percent</code> <code>ndarray</code> <p>Normalized confusion matrix for the tuned model.</p> <code>tuned_classification_report</code> <code>str</code> <p>Classification report for the tuned model.</p> Source code in <code>geonate/classify.py</code> <pre><code>class XGBoost:\n    \"\"\"\n    A wrapper class for XGBoost classification, including model training, hyperparameter tuning, and classification of raster images.\n\n    Attributes:\n        X_train (array-like): Training feature set.\n        y_train (array-like): Training labels.\n        X_test (array-like): Testing feature set.\n        y_test (array-like): Testing labels.\n        initial_xgb (XGBClassifier or None): The initial trained XGBoost model.\n        tuned_xgb (XGBClassifier or None): The tuned XGBoost model (if tuning is performed).\n        accuracy (float): Accuracy of the initial model on the test set.\n        confusion_matrix (ndarray): Confusion matrix of the initial model.\n        confusion_matrix_percent (ndarray): Normalized confusion matrix as percentages.\n        classification_report (str): Classification report for the initial model.\n        tuned_accuracy (float): Accuracy of the tuned model.\n        tuned_confusion_matrix (ndarray): Confusion matrix of the tuned model.\n        tuned_confusion_matrix_percent (ndarray): Normalized confusion matrix for the tuned model.\n        tuned_classification_report (str): Classification report for the tuned model.\n\n    \"\"\"\n    def __init__(self, X_train, y_train, X_test, y_test):\n        \"\"\"\n        Initializes the XGBoost classifier with training and testing data, and automatically trains an initial model.\n\n        Args:\n            X_train (array-like): Training feature set.\n            y_train (array-like): Training labels.\n            X_test (array-like): Testing feature set.\n            y_test (array-like): Testing labels.\n\n        \"\"\"\n        self.X_train = X_train\n        self.y_train = y_train\n        self.X_test = X_test\n        self.y_test = y_test\n        self.initial_xgb = None\n        self.tuned_xgb = None\n\n        # Automatically run the initial model \n        self.model()\n\n    # Initial model and validation\n    def model(self, **kwargs):\n        \"\"\"\n        Trains an initial XGBoost classifier using the provided training data and evaluates its performance on the test set.\n\n        Args:\n            **kwargs: Additional parameters to pass to XGBClassifier.\n\n        Returns:\n            XGBClassifier: The trained initial model.\n\n        \"\"\"\n        from xgboost import XGBClassifier\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        # Initialize model and fit the model\n        xgb = XGBClassifier(**kwargs)\n        xgb.fit(self.X_train, self.y_train)\n\n        # Validate the initial model and return validation metrics\n        y_pred = xgb.predict(self.X_test)\n        self.accuracy = accuracy_score(self.y_test, y_pred)\n        self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n        self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.classification_report = classification_report(self.y_test, y_pred)\n\n        self.initial_xgb = xgb\n        return self.initial_xgb\n\n    # Tune the best parameters for classifier using random search or grid search methods\n    def tune(self, method=\"random\", n_estimators=[100, 200, 300, 500, 1000], max_depth=[3, 5, 7, 9], learning_rate=[0.0001, 0.001, 0.01, 0.1], subsample=[0.5, 0.7, 1], n_iter=5, cv=5, n_job=-1):\n        \"\"\"\n        Tunes the hyperparameters of the XGBoost classifier using either RandomizedSearchCV or GridSearchCV.\n\n        Args:\n            method (str, optional): Search method, either \"random\" (default) or \"grid\".\n            n_estimators (list, optional): List of values for the number of trees.\n            max_depth (list, optional): List of values for the maximum tree depth.\n            learning_rate (list, optional): List of learning rates.\n            subsample (list, optional): List of subsampling ratios.\n            n_iter (int, optional): Number of iterations for random search (ignored for grid search).\n            cv (int, optional): Number of cross-validation folds.\n            n_job (int, optional): Number of parallel jobs (currently not used in the function).\n\n        Returns:\n            Best estimator from tuning process (XGBClassifier).\n\n        \"\"\"\n        from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n        from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n        paras = [{\n            'n_estimators': n_estimators,\n            'max_depth': max_depth,\n            'learning_rate': learning_rate,\n            'subsample': subsample\n        }]\n\n        if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n            random_searched = RandomizedSearchCV(estimator= self.initial_xgb, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n            random_searched.fit(self.X_train, self.y_train)\n            tuned_model = random_searched\n            self.tuned_xgb = tuned_model\n\n        elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n            grid_search = GridSearchCV(estimator= self.initial_xgb, param_grid= paras, cv=cv, scoring='accuracy', verbose=True, n_jobs=-1)\n            grid_search.fit(self.X_train, self.y_train)\n\n            tuned_model = grid_search\n            self.tuned_xgb = tuned_model\n\n        else:\n            raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n        # Validate the initial model and return validation metrics\n        tuned_y_pred = tuned_model.predict(self.X_test)\n        self.tuned_accuracy = accuracy_score(self.y_test, tuned_y_pred)\n        self.tuned_confusion_matrix = confusion_matrix(self.y_test, tuned_y_pred)\n        self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n        self.tuned_classification_report = classification_report(self.y_test, tuned_y_pred)\n\n        return self.tuned_xgb\n\n    # Classify image \n    def classify(self, src, model=None):\n        \"\"\"\n        Classifies an input raster image using the trained XGBoost model.\n\n        Args:\n            src (rasterio.DatasetReader): The source raster image to classify.\n            model (XGBClassifier, optional): The model to use for classification. If not provided, the tuned model is used (or the initial model if tuning was not performed).\n\n        Returns:\n            rasterio.io.MemoryFile: The classified raster image.\n\n        \"\"\"\n        import rasterio\n        from geonate.common import reshape_raster, array2raster\n\n        # Define the random forest model to use\n        if model is not None:\n            XGB_model = model\n        else: \n            XGB_model = self.tuned_xgb if self.tuned_xgb is not None else self.initial_xgb\n\n        # Define input parameters\n        if not isinstance(src, rasterio.DatasetReader):\n            raise ValueError('Source image is not supported')\n        else: \n            src_meta = src.meta\n            nbands = src.count\n            src_height = src.height\n            src_width = src.width            \n            src_rast = src.read()\n\n            # Reshape and flatten data\n            src_img = reshape_raster(src_rast, mode='image')\n            ds = src_img.reshape((-1, nbands))\n\n            # Predict labels using the defined model\n            pred_labels = XGB_model.predict(ds)\n\n            # Reshape data and convert to raster format\n            pred_result = pred_labels.reshape(src_height, src_width)\n\n            src_meta.update({'count': 1})\n            classified = array2raster(pred_result, metadata=src_meta)            \n\n            return classified\n</code></pre>"},{"location":"classify/#geonate.classify.XGBoost.__init__","title":"<code>__init__(self, X_train, y_train, X_test, y_test)</code>  <code>special</code>","text":"<p>Initializes the XGBoost classifier with training and testing data, and automatically trains an initial model.</p> <p>Parameters:</p> Name Type Description Default <code>X_train</code> <code>array-like</code> <p>Training feature set.</p> required <code>y_train</code> <code>array-like</code> <p>Training labels.</p> required <code>X_test</code> <code>array-like</code> <p>Testing feature set.</p> required <code>y_test</code> <code>array-like</code> <p>Testing labels.</p> required Source code in <code>geonate/classify.py</code> <pre><code>def __init__(self, X_train, y_train, X_test, y_test):\n    \"\"\"\n    Initializes the XGBoost classifier with training and testing data, and automatically trains an initial model.\n\n    Args:\n        X_train (array-like): Training feature set.\n        y_train (array-like): Training labels.\n        X_test (array-like): Testing feature set.\n        y_test (array-like): Testing labels.\n\n    \"\"\"\n    self.X_train = X_train\n    self.y_train = y_train\n    self.X_test = X_test\n    self.y_test = y_test\n    self.initial_xgb = None\n    self.tuned_xgb = None\n\n    # Automatically run the initial model \n    self.model()\n</code></pre>"},{"location":"classify/#geonate.classify.XGBoost.classify","title":"<code>classify(self, src, model=None)</code>","text":"<p>Classifies an input raster image using the trained XGBoost model.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>rasterio.DatasetReader</code> <p>The source raster image to classify.</p> required <code>model</code> <code>XGBClassifier</code> <p>The model to use for classification. If not provided, the tuned model is used (or the initial model if tuning was not performed).</p> <code>None</code> <p>Returns:</p> Type Description <code>rasterio.io.MemoryFile</code> <p>The classified raster image.</p> Source code in <code>geonate/classify.py</code> <pre><code>def classify(self, src, model=None):\n    \"\"\"\n    Classifies an input raster image using the trained XGBoost model.\n\n    Args:\n        src (rasterio.DatasetReader): The source raster image to classify.\n        model (XGBClassifier, optional): The model to use for classification. If not provided, the tuned model is used (or the initial model if tuning was not performed).\n\n    Returns:\n        rasterio.io.MemoryFile: The classified raster image.\n\n    \"\"\"\n    import rasterio\n    from geonate.common import reshape_raster, array2raster\n\n    # Define the random forest model to use\n    if model is not None:\n        XGB_model = model\n    else: \n        XGB_model = self.tuned_xgb if self.tuned_xgb is not None else self.initial_xgb\n\n    # Define input parameters\n    if not isinstance(src, rasterio.DatasetReader):\n        raise ValueError('Source image is not supported')\n    else: \n        src_meta = src.meta\n        nbands = src.count\n        src_height = src.height\n        src_width = src.width            \n        src_rast = src.read()\n\n        # Reshape and flatten data\n        src_img = reshape_raster(src_rast, mode='image')\n        ds = src_img.reshape((-1, nbands))\n\n        # Predict labels using the defined model\n        pred_labels = XGB_model.predict(ds)\n\n        # Reshape data and convert to raster format\n        pred_result = pred_labels.reshape(src_height, src_width)\n\n        src_meta.update({'count': 1})\n        classified = array2raster(pred_result, metadata=src_meta)            \n\n        return classified\n</code></pre>"},{"location":"classify/#geonate.classify.XGBoost.model","title":"<code>model(self, **kwargs)</code>","text":"<p>Trains an initial XGBoost classifier using the provided training data and evaluates its performance on the test set.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional parameters to pass to XGBClassifier.</p> <code>{}</code> <p>Returns:</p> Type Description <code>XGBClassifier</code> <p>The trained initial model.</p> Source code in <code>geonate/classify.py</code> <pre><code>def model(self, **kwargs):\n    \"\"\"\n    Trains an initial XGBoost classifier using the provided training data and evaluates its performance on the test set.\n\n    Args:\n        **kwargs: Additional parameters to pass to XGBClassifier.\n\n    Returns:\n        XGBClassifier: The trained initial model.\n\n    \"\"\"\n    from xgboost import XGBClassifier\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    # Initialize model and fit the model\n    xgb = XGBClassifier(**kwargs)\n    xgb.fit(self.X_train, self.y_train)\n\n    # Validate the initial model and return validation metrics\n    y_pred = xgb.predict(self.X_test)\n    self.accuracy = accuracy_score(self.y_test, y_pred)\n    self.confusion_matrix = confusion_matrix(self.y_test, y_pred)\n    self.confusion_matrix_percent = self.confusion_matrix.astype(float) / self.confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.classification_report = classification_report(self.y_test, y_pred)\n\n    self.initial_xgb = xgb\n    return self.initial_xgb\n</code></pre>"},{"location":"classify/#geonate.classify.XGBoost.tune","title":"<code>tune(self, method='random', n_estimators=[100, 200, 300, 500, 1000], max_depth=[3, 5, 7, 9], learning_rate=[0.0001, 0.001, 0.01, 0.1], subsample=[0.5, 0.7, 1], n_iter=5, cv=5, n_job=-1)</code>","text":"<p>Tunes the hyperparameters of the XGBoost classifier using either RandomizedSearchCV or GridSearchCV.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Search method, either \"random\" (default) or \"grid\".</p> <code>'random'</code> <code>n_estimators</code> <code>list</code> <p>List of values for the number of trees.</p> <code>[100, 200, 300, 500, 1000]</code> <code>max_depth</code> <code>list</code> <p>List of values for the maximum tree depth.</p> <code>[3, 5, 7, 9]</code> <code>learning_rate</code> <code>list</code> <p>List of learning rates.</p> <code>[0.0001, 0.001, 0.01, 0.1]</code> <code>subsample</code> <code>list</code> <p>List of subsampling ratios.</p> <code>[0.5, 0.7, 1]</code> <code>n_iter</code> <code>int</code> <p>Number of iterations for random search (ignored for grid search).</p> <code>5</code> <code>cv</code> <code>int</code> <p>Number of cross-validation folds.</p> <code>5</code> <code>n_job</code> <code>int</code> <p>Number of parallel jobs (currently not used in the function).</p> <code>-1</code> <p>Returns:</p> Type Description <p>Best estimator from tuning process (XGBClassifier).</p> Source code in <code>geonate/classify.py</code> <pre><code>def tune(self, method=\"random\", n_estimators=[100, 200, 300, 500, 1000], max_depth=[3, 5, 7, 9], learning_rate=[0.0001, 0.001, 0.01, 0.1], subsample=[0.5, 0.7, 1], n_iter=5, cv=5, n_job=-1):\n    \"\"\"\n    Tunes the hyperparameters of the XGBoost classifier using either RandomizedSearchCV or GridSearchCV.\n\n    Args:\n        method (str, optional): Search method, either \"random\" (default) or \"grid\".\n        n_estimators (list, optional): List of values for the number of trees.\n        max_depth (list, optional): List of values for the maximum tree depth.\n        learning_rate (list, optional): List of learning rates.\n        subsample (list, optional): List of subsampling ratios.\n        n_iter (int, optional): Number of iterations for random search (ignored for grid search).\n        cv (int, optional): Number of cross-validation folds.\n        n_job (int, optional): Number of parallel jobs (currently not used in the function).\n\n    Returns:\n        Best estimator from tuning process (XGBClassifier).\n\n    \"\"\"\n    from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n    from sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\n    paras = [{\n        'n_estimators': n_estimators,\n        'max_depth': max_depth,\n        'learning_rate': learning_rate,\n        'subsample': subsample\n    }]\n\n    if method.lower() == 'random' or method.lower() =='randomized' or method.lower() =='randomizedsearch' or method.lower() =='randomizedsearchcv':\n        random_searched = RandomizedSearchCV(estimator= self.initial_xgb, param_distributions=paras, n_iter= n_iter, scoring='accuracy', verbose=True)\n        random_searched.fit(self.X_train, self.y_train)\n        tuned_model = random_searched\n        self.tuned_xgb = tuned_model\n\n    elif method.lower() == 'grid' or method.lower() == 'gridsearch' or method.lower() == 'gridsearchcv':\n        grid_search = GridSearchCV(estimator= self.initial_xgb, param_grid= paras, cv=cv, scoring='accuracy', verbose=True, n_jobs=-1)\n        grid_search.fit(self.X_train, self.y_train)\n\n        tuned_model = grid_search\n        self.tuned_xgb = tuned_model\n\n    else:\n        raise ValueError('Tune method is not supported, the current methods are \"randomizedsearch\" and \"gridsearchcv\"')\n\n    # Validate the initial model and return validation metrics\n    tuned_y_pred = tuned_model.predict(self.X_test)\n    self.tuned_accuracy = accuracy_score(self.y_test, tuned_y_pred)\n    self.tuned_confusion_matrix = confusion_matrix(self.y_test, tuned_y_pred)\n    self.tuned_confusion_matrix_percent = self.tuned_confusion_matrix.astype(float) / self.tuned_confusion_matrix.sum(axis=1, keepdims=True) * 100\n    self.tuned_classification_report = classification_report(self.y_test, tuned_y_pred)\n\n    return self.tuned_xgb\n</code></pre>"},{"location":"classify/#geonate.classify.kmeans","title":"<code>kmeans(input, n_cluster=3, max_iter=500, algorithm='lloyd', **kwargs)</code>","text":"<p>Perform K-Means clustering for raster image. Kmeans is a fast and simple algorithm. </p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>rasterio.DatasetReader or np.ndarray</code> <p>Multispectral input data. Can be a raster image or a numpy array.</p> required <code>n_cluster</code> <code>int</code> <p>Number of clusters to form. Default is 3.</p> <code>3</code> <code>max_iter</code> <code>int</code> <p>Maximum number of iterations of the k-means algorithm for a single run. Default is 300.</p> <code>500</code> <code>algorithm</code> <code>str</code> <p>K-means algorithm to use. The available algorithms include \"lloyd\" and \"elkan\". \"elkan\" variation can be more efficient on some datasets with well-defined clusters, by using the triangle inequality. However it\u2019s more memory intensive due to the allocation of an extra array of shape. Default is 'lloyd'.</p> <code>'lloyd'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the KMeans model.</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray or rasterio.DatasetReader</code> <p>K-Means clustering result in the same format as the input.</p> Source code in <code>geonate/classify.py</code> <pre><code>def kmeans(input, n_cluster=3, max_iter=500, algorithm='lloyd', **kwargs):\n    \"\"\"\n    Perform K-Means clustering for raster image. Kmeans is a fast and simple algorithm. \n\n    Args:\n        input (rasterio.DatasetReader or np.ndarray): Multispectral input data. Can be a raster image or a numpy array.\n        n_cluster (int): Number of clusters to form. Default is 3.\n        max_iter (int): Maximum number of iterations of the k-means algorithm for a single run. Default is 300.\n        algorithm (str): K-means algorithm to use. The available algorithms include \"lloyd\" and \"elkan\". \"elkan\" variation can be more efficient on some datasets with well-defined clusters, by using the triangle inequality. However it\u2019s more memory intensive due to the allocation of an extra array of shape. Default is 'lloyd'.\n        **kwargs: Additional keyword arguments to pass to the KMeans model.\n\n    Returns:\n        np.ndarray or rasterio.DatasetReader: K-Means clustering result in the same format as the input.\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    from sklearn.cluster import KMeans\n    from .common import array2raster, reshape_raster\n\n    # Identify datatype and define input data\n    # Raster image\n    if isinstance(input, rasterio.DatasetReader):\n        arr = input.read()\n        height, width = input.shape\n        nbands =  input.count\n        meta = input.meta\n    # Data Array\n    elif isinstance(input, np.ndarray):\n        if len(input.shape) &lt; 3:\n            raise ValueError('Input must be multispectral data (multi-band)')\n        else:\n            arr = input\n            nbands, height, width = input.shape\n\n    else: \n        raise ValueError('Input is not supported')\n\n    # Reshape from raster to image format, and from 3D to 2D\n    arr_reshape_img = reshape_raster(arr, mode='image')\n    print(arr_reshape_img.shape)\n    img_reshaped = arr_reshape_img.reshape((-1, nbands))\n\n    # Define KMeans model and fit the KMeans model\n    kmean_model = KMeans(n_clusters= n_cluster, max_iter= max_iter, algorithm= algorithm, **kwargs)\n    kmean_fit = kmean_model.fit(img_reshaped)\n\n    # Extract labels and reshape based on input image\n    labels = kmean_fit.labels_\n    km_results = labels.reshape((height, width))\n\n    # Return output based on input similar to input\n    if isinstance(input, np.ndarray):\n        return km_results\n\n    elif isinstance(input, rasterio.DatasetReader):\n        meta.update({'count': 1})\n        km_results_rast = array2raster(km_results, meta)\n        return km_results_rast\n</code></pre>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#geonate.common.array2raster","title":"<code>array2raster(array, metadata)</code>","text":"<p>Convert a numpy array and metadata to a rasterio object stored in memory.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>array</code> <p>The input data array.</p> required <code>metadata</code> <code>Dict</code> <p>The metadata dictionary.</p> required <p>Returns:</p> Type Description <code>Local raster file (raster)</code> <p>The rasterio object stored in memory.</p> Source code in <code>geonate/common.py</code> <pre><code>def array2raster(array, metadata: Dict):\n    \"\"\"\n    Convert a numpy array and metadata to a rasterio object stored in memory.\n\n    Args:\n        array (array): The input data array.\n        metadata (Dict): The metadata dictionary.\n\n    Returns:\n        Local raster file (raster): The rasterio object stored in memory.\n\n    \"\"\"\n    import rasterio\n\n     # Determine number of bands\n    if len(array.shape) == 3:\n        nbands = array.shape[0]\n    else:\n        nbands = 1\n\n    # Update metadata with the correct dtype and count\n    metadata.update({\n        'dtype': array.dtype,\n        'count': nbands\n    })\n\n    # Write image in memory file and read it back\n    memory_file = rasterio.MemoryFile()\n    dst = memory_file.open(**metadata)\n\n    if array.ndim == 2:\n        dst.write(array, 1)\n    elif array.ndim == 3:\n        for i in range(array.shape[0]):\n            dst.write(array[i, :, : ], i + 1)\n    dst.close()\n\n    # Read the dataset from memory\n    dataset_reader = rasterio.open(dst.name, mode=\"r\")\n\n    return dataset_reader\n</code></pre>"},{"location":"common/#geonate.common.center_scene","title":"<code>center_scene(input)</code>","text":"<p>Computes the center latitude and longitude of a given geospatial input.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | shapefile</code> <p>A geospatial object with a 'bounds' attribute that defines the spatial extent.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - center_lat (float): The center latitude of the input.     - center_lon (float): The center longitude of the input.</p> Source code in <code>geonate/common.py</code> <pre><code>def center_scene(input):\n    \"\"\"\n    Computes the center latitude and longitude of a given geospatial input.\n\n    Args:\n        input (raster | shapefile): A geospatial object with a 'bounds' attribute that defines the spatial extent.\n\n    Returns:\n        tuple: A tuple containing:\n            - center_lat (float): The center latitude of the input.\n            - center_lon (float): The center longitude of the input.\n\n    \"\"\"\n    import rasterio\n    import geopandas\n\n    # Define boundary \n    bounds, _ = get_extent_local(input)\n    min_lon, min_lat, max_lon, max_lat = bounds[0], bounds[1], bounds[2], bounds[3]\n\n    # Compute center latitude and longitude\n    center_lat = (min_lat + max_lat) / 2\n    center_lon = (min_lon + max_lon) / 2\n\n    return center_lat, center_lon\n</code></pre>"},{"location":"common/#geonate.common.check_crs_consistency","title":"<code>check_crs_consistency(input)</code>","text":"<p>Checks if all elements in the input list have the same Coordinate Reference System (CRS).</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>A list of file paths or local variables (rasterio.io.DatasetReader or geopandas.geodataframe.GeoDataFrame).</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - bool: True if all elements have the same CRS, False otherwise.     - str or None: The CRS of the elements if all elements have the same CRS, otherwise None.</p> Source code in <code>geonate/common.py</code> <pre><code>def check_crs_consistency(input):\n    \"\"\"\n    Checks if all elements in the input list have the same Coordinate Reference System (CRS).\n\n    Args:\n        input (list): A list of file paths or local variables (rasterio.io.DatasetReader or geopandas.geodataframe.GeoDataFrame).\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if all elements have the same CRS, False otherwise.\n            - str or None: The CRS of the elements if all elements have the same CRS, otherwise None.\n\n    \"\"\"\n    import numpy\n    from .geonate import rast, vect\n\n    if not isinstance(input, list):\n        raise ValueError('Input must be a list of local variables or file paths')\n\n    else:\n        _, inputType = check_datatype_consistency(input)\n\n        if str(inputType) == \"&lt;class 'str'&gt;\":\n            file_extensions  = [x.split(\".\")[-1] for x in input]\n            file_extension = numpy.unique(file_extensions)\n            extension_len = len(file_extension)\n\n            if extension_len &gt; 1:\n                raise ValueError('Input must have consistent data format')\n\n            else:\n                if str(file_extension[0]) == 'tif':\n                    files = [rast(file) for file in input]\n                    crs_list = [x.crs.to_string() for x in files]\n\n                    if len(numpy.unique(crs_list)) == 1:\n                        crs = numpy.unique(crs_list)\n                        consistency = True\n                        print(f\"Input is Raster with consistent crs of {crs}\")\n                        return consistency, crs[0]\n\n                    else:\n                        consistency = False\n                        print(f\"Input is Raster with different crs\")\n                        return consistency, None\n\n                elif str(file_extension[0]) == 'shp':\n                    files = [vect(file) for file in input]\n                    crs_list = [file.crs.to_string() for file in files]\n                    if len(numpy.unique(crs_list)) == 1:\n                        crs = numpy.unique(crs_list)\n                        consistency = True\n                        print(f\"Input is Shapefile with consistent crs of {crs}\")\n                        return consistency, crs[0]\n\n                    else:\n                        consistency = False\n                        print(f\"Input is Raster with different crs\")\n                        return consistency, None\n\n                else:\n                    raise ValueError('This function only supports raster (.tif) and shapefile (.shp)')\n\n        elif str(inputType) == \"&lt;class 'rasterio.io.DatasetReader'&gt;\" or str(inputType) == \"&lt;class 'geopandas.geodataframe.GeoDataFrame'&gt;\":\n            crs_list = [x.crs.to_string() for x in input]\n            crs = numpy.unique(crs_list)\n            consistency = True\n            print(f\"Input is Shapefile with consistent crs of {crs}\")\n            return consistency, crs[0]\n\n        else:\n            raise ValueError(f\"Input must have the same data format of raster (.tif) and shapefile (.shp)\")\n</code></pre>"},{"location":"common/#geonate.common.check_datatype_consistency","title":"<code>check_datatype_consistency(input)</code>","text":"<p>Checks if all elements in the input list have the same data type.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>A list of elements to check.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - bool: True if all elements have the same type, False otherwise.     - type or None: The data type of the elements if all elements have the same type, otherwise None.</p> Source code in <code>geonate/common.py</code> <pre><code>def check_datatype_consistency(input):\n    \"\"\"\n    Checks if all elements in the input list have the same data type.\n\n    Args:\n        input (list): A list of elements to check.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if all elements have the same type, False otherwise.\n            - type or None: The data type of the elements if all elements have the same type, otherwise None.\n\n    \"\"\"\n    if not isinstance(input, list):\n        raise ValueError(\"Input must be a list\")\n    else:\n        first_element = type(input[0])\n        if all(isinstance(item, first_element) for item in input):\n            datatype = first_element\n            consistency = True\n            print(f\"Checking datatype consistency\\nInput have data types of {datatype}\")\n        else:\n            datatype = None\n            consistency = False\n            print(f\"Checking datatype consistency\\nInput have different data types\")\n\n        return consistency, str(datatype)\n</code></pre>"},{"location":"common/#geonate.common.check_extension_consistency","title":"<code>check_extension_consistency(input)</code>","text":"<p>Checks if all elements in the input list have the same file extension.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>A list of file paths as strings.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - bool: True if all elements have the same file extension, False otherwise.     - str or None: The file extension if all elements have the same extension, otherwise None.</p> Source code in <code>geonate/common.py</code> <pre><code>def check_extension_consistency(input):\n    \"\"\"\n    Checks if all elements in the input list have the same file extension.\n\n    Args:\n        input (list): A list of file paths as strings.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if all elements have the same file extension, False otherwise.\n            - str or None: The file extension if all elements have the same extension, otherwise None.\n\n    \"\"\"\n    import numpy\n\n    # Check whether a list or not\n    if not isinstance(input, list):\n        raise ValueError(\"Input must be a list of file paths\")\n\n    else:\n        # Check whether all are string\n        if not all(isinstance(x, str) for x in input):\n            raise ValueError('Input must contain only string of file paths')\n        else:\n            # \n            extensions = [e.split(\".\")[-1] for e in input]\n            no_extension = len(numpy.unique(extensions))\n            if no_extension == 1:\n                consistency = True\n                extension = str(extensions[0])\n            else:\n                consistency = False\n                extension = None\n\n            return consistency, extension          \n</code></pre>"},{"location":"common/#geonate.common.degree2meter","title":"<code>degree2meter(input, latitude=None)</code>","text":"<p>Convert distance from degrees to meters depending on latitude</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>numeric</code> <p>Input resolution in degrees</p> required <code>latitude</code> <code>numeric</code> <p>Latitude of the location. If latitude is None, the location is assumed near the Equator. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Distance length (numeric | float)</code> <p>Distance in meters corresponding to the input degree</p> Source code in <code>geonate/common.py</code> <pre><code>def degree2meter(input, latitude=None):\n    \"\"\"Convert distance from degrees to meters depending on latitude\n\n    Args:\n        input (numeric): Input resolution in degrees\n        latitude (numeric, optional): Latitude of the location. If latitude is None, the location is assumed near the Equator. Defaults to None.\n\n    Returns:\n        Distance length (numeric | float): Distance in meters corresponding to the input degree\n\n    \"\"\"\n    import numpy as np\n\n    if latitude is None:\n        # Equator location\n        meters = input * (111320 * np.cos(np.radians(0.0)))\n    else:\n        meters = input * (111320 * np.cos(np.radians(latitude)))\n\n    return meters\n</code></pre>"},{"location":"common/#geonate.common.empty_dataframe","title":"<code>empty_dataframe(nrows, ncols, value='NA', name=None)</code>","text":"<p>Create an empty dataframe</p> <p>Parameters:</p> Name Type Description Default <code>nrows</code> <code>numeric</code> <p>Numbers of rows</p> required <code>ncols</code> <code>numeric</code> <p>Number of columns</p> required <code>value</code> <code>str | numeric</code> <p>Input value in all cells. Defaults to 'NA'.</p> <code>'NA'</code> <code>name</code> <code>list</code> <p>Names of columns, if not given, it will return default as number of column. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dataframe (pandas datafram)</code> <p>An empty filled with NA or user-defined number (e.g., 0)</p> Source code in <code>geonate/common.py</code> <pre><code>def empty_dataframe(nrows, ncols, value='NA', name=None):\n    \"\"\"Create an empty dataframe\n\n    Args:\n        nrows (numeric): Numbers of rows\n        ncols (numeric): Number of columns\n        value (str | numeric, optional): Input value in all cells. Defaults to 'NA'.\n        name (list, optional): Names of columns, if not given, it will return default as number of column. Defaults to None.\n\n    Returns:\n        Dataframe (pandas datafram): An empty filled with NA or user-defined number (e.g., 0)\n\n    \"\"\"\n    import pandas as pd\n    import numpy as np\n\n    # Check validity of column name\n    if name is None:\n        column_names = [f'Col_{i+1}' for i in range(ncols)]\n    elif len(name) == ncols:\n        column_names = name\n    else:\n        raise ValueError(\"Length of column names vector must match numbers of columns\")\n\n    # check input value\n    try: \n        if isinstance(value, int):\n            val = value\n        elif isinstance(value, float):\n            val = value\n        else:\n            val = np.nan\n    except ValueError:\n        val = np.nan\n\n    # Create data and parse it into dataframe \n    data = [[val] * ncols for _ in range(nrows)]\n    dataframe = pd.DataFrame(data, columns= column_names)\n\n    return dataframe\n</code></pre>"},{"location":"common/#geonate.common.get_extent_external","title":"<code>get_extent_external(input)</code>","text":"<p>Computes the spatial extent of geospatial files and returns the bounding box and a GeoDataFrame of the bounding polygon.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str or list</code> <p>A single file path or a list of file paths. Supported file types are GeoTIFF raster (tif) and shapefile (shp).</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - general_extent (tuple): The bounding box of the input files in the format (minx, miny, maxx, maxy).     - bound_poly (geopandas.GeoDataFrame): A GeoDataFrame containing the bounding polygon.</p> Source code in <code>geonate/common.py</code> <pre><code>def get_extent_external(input):\n    \"\"\"\n    Computes the spatial extent of geospatial files and returns the bounding box and a GeoDataFrame of the bounding polygon.\n\n    Args:\n        input (str or list): A single file path or a list of file paths. Supported file types are GeoTIFF raster (tif) and shapefile (shp).\n\n    Returns:\n        tuple: A tuple containing:\n            - general_extent (tuple): The bounding box of the input files in the format (minx, miny, maxx, maxy).\n            - bound_poly (geopandas.GeoDataFrame): A GeoDataFrame containing the bounding polygon.\n\n    \"\"\"\n\n    import rasterio\n    import geopandas\n    from shapely.geometry import Polygon\n    from .geonate import rast, vect\n\n    #### Single path\n    if (not isinstance(input, list)) or ((isinstance(input, list) and (len(input)==1))):\n        # Check whether single list or string\n        if len(input) == 1:\n            input = input[0]\n        else:\n            input = input\n\n        # Extract file extension\n        extension = input.split(\".\")[-1]\n\n        # Raster files\n        if extension == 'tif':\n            tmp = rast(input)\n            general_extent = tmp.bounds\n            crs = tmp.crs\n            # Create bound polygon\n            poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n            bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n            bound_poly.crs = {'init': crs}\n\n            return general_extent, bound_poly\n\n        # Vector Shapefile \n        elif extension == 'shp':\n            tmp = vect(input)\n            ext = tmp.bounds\n            crs = tmp.crs\n            no_poly = ext.shape[0]\n\n            # Determine general bound in case single polygon or multiple polygons\n            if no_poly == 1:\n                general_extent = tuple(ext.loc[0, :])\n            elif no_poly &gt;= 2:\n                general_extent = (ext.iloc[:, 0].min(), ext.iloc[:, 1].min(), ext.iloc[:, 2].max(),ext.iloc[:, 3].max())\n\n            # Create bound polygon\n            poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n            bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n            bound_poly.crs = {'init': crs}\n\n            return general_extent, bound_poly\n\n        # Other data types\n        else:\n            raise ValueError('It only supports geotif raster (tif) and shapefile (shp)')\n\n    #### List of multiple paths    \n    else:\n        consistency, extension = check_extension_consistency(input)\n\n        # Check extension consistency\n        if consistency is True:\n            # Raster files\n            if extension == 'tif':\n                files = [rast(file) for file in input]\n                general_extent = None \n\n                # read each file\n                for file in files:\n                    ext = file.bounds\n                    crs = file.crs                \n\n                    # determine general extent\n                    if general_extent is None:\n                        general_extent = ext\n                    else:\n                        general_extent =  (\n                            min(general_extent[0], ext[0]),\n                            min(general_extent[1], ext[1]),\n                            max(general_extent[2], ext[2]),\n                            max(general_extent[3], ext[3])\n                            )\n\n                    # Create bound polygon\n                    poly_geom = Polygon([\n                        (general_extent[0], general_extent[1]), \n                        (general_extent[2], general_extent[1]), \n                        (general_extent[2], general_extent[3]), \n                        (general_extent[0], general_extent[3])\n                        ])\n                    bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n                    bound_poly.crs = {'init': crs} \n\n                    return general_extent, bound_poly\n\n            # Shapefile data\n            elif extension == 'shp':\n                files = [vect(file) for file in input]\n                general_extent = None                        \n\n                # read each file\n                for file in files:\n                    ext = file.bounds\n                    crs = file.crs\n                    no_poly = ext.shape[0]\n\n                    # Determine general bound in case single polygon or multiple polygons\n                    if no_poly == 1:\n                        ext = tuple(ext.loc[0, :])\n                    elif no_poly &gt;= 2:\n                        ext = (ext.iloc[:, 0].min(), ext.iloc[:, 1].min(), ext.iloc[:, 2].max(),ext.iloc[:, 3].max())\n\n                    # determine general extent\n                    if general_extent is None:\n                        general_extent = ext\n                    else:\n                        general_extent =  (\n                            min(general_extent[0], ext[0]),\n                            min(general_extent[1], ext[1]),\n                            max(general_extent[2], ext[2]),\n                            max(general_extent[3], ext[3])\n                            )\n\n                    # Create bound polygon\n                    poly_geom = Polygon([\n                        (general_extent[0], general_extent[1]), \n                        (general_extent[2], general_extent[1]), \n                        (general_extent[2], general_extent[3]), \n                        (general_extent[0], general_extent[3])\n                        ])\n                    bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n                    bound_poly.crs = {'init': crs} \n\n                    return general_extent, bound_poly\n\n            # Other data types\n            else:\n                raise ValueError('Input only supports geotif (tif) and shapefile (shp)')\n\n        # Other cases\n        else:\n            raise ValueError('Checking file extension consistency\\nInput have different data extensions')\n</code></pre>"},{"location":"common/#geonate.common.get_extent_local","title":"<code>get_extent_local(input)</code>","text":"<p>Computes the spatial extent of a single or multiple geospatial files (GeoTIFF raster or shapefile).</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list or object</code> <p>A single rasterio.io.DatasetReader object, a single geopandas.geodataframe.GeoDataFrame object, or a list of such objects.</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing:     - general_extent (tuple): The bounding box of the input(s) in the format (min_x, min_y, max_x, max_y).     - bound_poly (geopandas.GeoDataFrame): A GeoDataFrame containing a single polygon representing the bounding box.</p> Source code in <code>geonate/common.py</code> <pre><code>def get_extent_local(input):\n    \"\"\"\n    Computes the spatial extent of a single or multiple geospatial files (GeoTIFF raster or shapefile).\n\n    Args:\n        input (list or object): A single rasterio.io.DatasetReader object, a single geopandas.geodataframe.GeoDataFrame object, or a list of such objects.\n\n    Returns:\n        tuple: A tuple containing:\n            - general_extent (tuple): The bounding box of the input(s) in the format (min_x, min_y, max_x, max_y).\n            - bound_poly (geopandas.GeoDataFrame): A GeoDataFrame containing a single polygon representing the bounding box.\n\n    \"\"\"\n    import rasterio\n    import geopandas\n    from shapely.geometry import Polygon\n\n    #### Single file\n    if (not isinstance(input, list)) or len(input)==1:\n        if (isinstance(input, rasterio.io.DatasetReader)):\n            general_extent = input.bounds\n            crs = input.crs\n\n            poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n            bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n            bound_poly.crs = {'init': crs}\n\n            return general_extent, bound_poly\n\n        elif (isinstance(input, geopandas.geodataframe.GeoDataFrame)):\n            ext = input.bounds\n            crs = input.crs\n            no_poly = ext.shape[0]\n\n            # Determine general bound in case single polygon or multiple polygons\n            if no_poly == 1:\n                general_extent = tuple(ext.loc[0, :])\n            elif no_poly &gt;= 2:\n                general_extent = (ext.iloc[:, 0].min(), ext.iloc[:, 1].min(), ext.iloc[:, 2].max(),ext.iloc[:, 3].max())\n\n            poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n            bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n            bound_poly.crs = {'init': crs}\n\n            return general_extent, bound_poly\n\n        else:\n            raise ValueError('It only supports geotif raster and shapefile')\n\n    #### Multiple files\n    elif (isinstance(input, list)) or len(input) &gt; 1:\n        consistency, datatype = check_datatype_consistency(input)\n\n        # Input are Raster files\n        if (consistency is True) and (datatype == \"&lt;class 'rasterio.io.DatasetReader'&gt;\"):\n            general_extent = None        \n            # read each file\n            for file in input:\n                ext = file.bounds\n                crs = file.crs                \n\n                # determine general extent\n                if general_extent is None:\n                    general_extent = ext\n                else:\n                    general_extent =  (\n                        min(general_extent[0], ext[0]),\n                        min(general_extent[1], ext[1]),\n                        max(general_extent[2], ext[2]),\n                        max(general_extent[3], ext[3])\n                        )\n\n                # Create bound polygon\n                poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n                bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n                bound_poly.crs = {'init': crs} \n\n                return general_extent, bound_poly\n\n        # Input are Shapefile files\n        elif (consistency is True) and (datatype == \"&lt;class 'geopandas.geodataframe.GeoDataFrame'&gt;\"):\n            general_extent = None                        \n            # read each file\n            for file in input:\n                ext = file.bounds\n                crs = file.crs\n                no_poly = ext.shape[0]\n\n                # Determine general bound in case single polygon or multiple polygons\n                if no_poly == 1:\n                    ext = tuple(ext.loc[0, :])\n                elif no_poly &gt;= 2:\n                    ext = (ext.iloc[:, 0].min(), ext.iloc[:, 1].min(), ext.iloc[:, 2].max(),ext.iloc[:, 3].max())\n\n                # determine general extent\n                if general_extent is None:\n                    general_extent = ext\n                else:\n                    general_extent =  (\n                        min(general_extent[0], ext[0]),\n                        min(general_extent[1], ext[1]),\n                        max(general_extent[2], ext[2]),\n                        max(general_extent[3], ext[3])\n                        )\n\n                # Create bound polygon\n                poly_geom = Polygon([\n                    (general_extent[0], general_extent[1]), \n                    (general_extent[2], general_extent[1]), \n                    (general_extent[2], general_extent[3]), \n                    (general_extent[0], general_extent[3])\n                    ])\n                bound_poly = geopandas.GeoDataFrame(index=[0], geometry=[poly_geom])\n                bound_poly.crs = {'init': crs} \n\n                return general_extent, bound_poly\n\n        # Other data types\n        else:\n            raise ValueError('Input have different data types') \n\n    #### Other cases\n    else:\n        raise ValueError('It only supports geotif raster and shapefile')\n</code></pre>"},{"location":"common/#geonate.common.listFiles","title":"<code>listFiles(path, pattern, search_type='pattern', full_name=True)</code>","text":"<p>List all files with specific pattern within a folder path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>AnyStr</code> <p>Folder path where files stored</p> required <code>pattern</code> <code>AnyStr</code> <p>Search pattern of files (e.g., '*.tif')</p> required <code>search_type</code> <code>AnyStr</code> <p>Search type whether by \"extension\" or name \"pattern\". Defaults to 'pattern'.</p> <code>'pattern'</code> <code>full_name</code> <code>bool</code> <p>Whether returning full name with path detail or only file name. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>A string list (list)</code> <p>A list of file paths</p> Source code in <code>geonate/common.py</code> <pre><code>def listFiles(path: AnyStr, pattern: AnyStr, search_type: AnyStr = 'pattern', full_name: bool=True):\n    \"\"\"List all files with specific pattern within a folder path\n\n    Args:\n        path (AnyStr): Folder path where files stored\n        pattern (AnyStr): Search pattern of files (e.g., '*.tif')\n        search_type (AnyStr, optional): Search type whether by \"extension\" or name \"pattern\". Defaults to 'pattern'.\n        full_name (bool, optional): Whether returning full name with path detail or only file name. Defaults to True.\n\n    Returns:\n        A string list (list): A list of file paths\n\n    \"\"\"\n    import os\n    import fnmatch\n\n    # Create empty list to store list of files\n    files_list = []\n\n    # Check search type\n    if (search_type.upper() == 'EXTENSION') or (search_type.upper() == 'E'):\n        if '*' in pattern:\n            raise ValueError(\"Do not use '*' in the pattern of extension search\")\n        else:\n            for root, dirs, files in os.walk(path):\n                for file in files:\n                    if file.lower().endswith(pattern):\n                        if full_name is True:\n                            files_list.append(os.path.join(root, file))\n                        else:\n                            files_list.append(file)    \n\n    elif (search_type.upper() == 'PATTERN') or (search_type.upper() == 'P'):\n        if '*' not in pattern:\n            raise ValueError(\"Pattern search requires '*' in pattern\")\n        else:\n            for root, dirs, files in os.walk(path):\n                for file in fnmatch.filter(files, pattern):\n                    if full_name is True:\n                        files_list.append(os.path.join(root, file))\n                    else:\n                        files_list.append(file)\n\n    else:\n        raise ValueError('Search pattern must be one of these types (pattern, p, extension, e)')\n\n    return files_list\n</code></pre>"},{"location":"common/#geonate.common.meter2degree","title":"<code>meter2degree(input, latitude=None)</code>","text":"<p>Convert image resolution from meter to acr-degree depending on location of latitude</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>numeric</code> <p>Input resolution of distance</p> required <code>latitude</code> <code>numeric</code> <p>Latitude presents location. If latitude is None, the location is assumed near Equator. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Degree (float)</code> <p>Degree corresponding to the distance length</p> Source code in <code>geonate/common.py</code> <pre><code>def meter2degree(input, latitude=None):\n    \"\"\"Convert image resolution from meter to acr-degree depending on location of latitude\n\n    Args:\n        input (numeric): Input resolution of distance\n        latitude (numeric, optional): Latitude presents location. If latitude is None, the location is assumed near Equator. Defaults to None.\n\n    Returns:\n        Degree (float): Degree corresponding to the distance length\n\n    \"\"\"\n    import numpy as np\n\n    if latitude is None:\n        # Equator location\n        degree = input / (111320 * np.cos(np.radians(0.0)))\n    else:\n        degree = input / (111320 * np.cos(np.radians(latitude)))\n\n    return degree\n</code></pre>"},{"location":"common/#geonate.common.mimax","title":"<code>mimax(input, digit=3)</code>","text":"<p>Calculate maximum and minimum values of raster or array</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | array</code> <p>Raster image or data array</p> required <code>digit</code> <code>int</code> <p>Precise digit number. Defaults to 3.</p> <code>3</code> <p>Returns:</p> Type Description <code>Min and Max values (numeric)</code> <p>Return 2 numbers of minvalue and maxvalue</p> Source code in <code>geonate/common.py</code> <pre><code>def mimax(input, digit=3):\n    \"\"\"Calculate maximum and minimum values of raster or array\n\n    Args:\n        input (raster | array): Raster image or data array\n        digit (int, optional): Precise digit number. Defaults to 3.\n\n    Returns:\n        Min and Max values (numeric): Return 2 numbers of minvalue and maxvalue\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Calculate min and max values\n    minValue = round(np.nanmin(dataset), digit)\n    maxValue = round(np.nanmax(dataset), digit)\n\n    # Convert min and max to string for print\n    min_round = str(round(minValue, digit))\n    max_round = str(round(maxValue, digit))\n\n    print(f\"[Min: {min_round}  | Max: {max_round}]\")\n\n    return minValue, maxValue\n</code></pre>"},{"location":"common/#geonate.common.reshape_raster","title":"<code>reshape_raster(inputArray, mode='image')</code>","text":"<p>Reshapes a 3-dimensional numpy array between 'image' and 'raster' formats.</p> <p>Parameters:</p> Name Type Description Default <code>inputArray</code> <code>array</code> <p>The input 3-dimensional array to be reshaped.</p> required <code>mode</code> <code>str</code> <p>The mode to reshape the array to. 'image' or 'img' reshapes to (height, width, bands), 'raster' or 'r' reshapes to (bands, height, width). Default is 'image'.</p> <code>'image'</code> <p>Returns:</p> Type Description <code>Reshape array (array)</code> <p>The reshaped array.</p> Source code in <code>geonate/common.py</code> <pre><code>def  reshape_raster(inputArray, mode:str=\"image\"):\n    \"\"\"\n    Reshapes a 3-dimensional numpy array between 'image' and 'raster' formats.\n\n    Parameters:\n        inputArray (array): The input 3-dimensional array to be reshaped.\n        mode (str): The mode to reshape the array to. 'image' or 'img' reshapes to (height, width, bands), 'raster' or 'r' reshapes to (bands, height, width). Default is 'image'.\n\n    Returns:\n        Reshape array (array): The reshaped array.\n\n    \"\"\"\n    import numpy as np\n\n    # Check whether input are 3-dim data array\n    if len(inputArray.shape) == 3:\n        # Convert to image\n        if mode.lower() == 'image' or mode.lower() == 'img':\n            output = np.transpose(inputArray, (1,2,0))\n        # Convert to raster\n        elif mode.lower() == 'raster' or mode.lower() == 'r':\n            output = np.transpose(inputArray, (2,0,1))\n\n        return output \n\n    #Other cases\n    else:\n        raise ValueError('Input data array must have 3 dimensions')\n</code></pre>"},{"location":"common/#geonate.common.unique_value","title":"<code>unique_value(input, frequency=True, sort='frequency')</code>","text":"<p>Calculate unique pixel values from a raster image or numpy array, optionally with their frequencies, and sort them.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster| array</code> <p>Input raster image or numpy array.</p> required <code>frequency</code> <code>bool</code> <p>If True, return the frequency of each unique value. Defaults to True.</p> <code>True</code> <code>sort</code> <code>str</code> <p>Sorting method for the unique values. Options are 'frequency' or 'value'. Defaults to 'frequency'.</p> <code>'frequency'</code> <p>Returns:</p> Type Description <code>array or dataframe</code> <p>Array with unique value if frequency is False, otherwise it returns DataFrame with unique values and frequencies.</p> Source code in <code>geonate/common.py</code> <pre><code>def unique_value(input, frequency=True, sort: Optional[AnyStr]='frequency'):\n    \"\"\"\n    Calculate unique pixel values from a raster image or numpy array, optionally with their frequencies, and sort them.\n\n    Args:\n        input (raster| array): Input raster image or numpy array.\n        frequency (bool, optional): If True, return the frequency of each unique value. Defaults to True.\n        sort (str, optional): Sorting method for the unique values. Options are 'frequency' or 'value'. Defaults to 'frequency'.\n\n    Returns:\n        array or dataframe: Array with unique value if frequency is False, otherwise it returns DataFrame with unique values and frequencies.\n\n    \"\"\"\n    import numpy as np\n    import pandas as pd\n    import rasterio\n    from .processor import values\n\n    # Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Extract all values from raster or array\n    pixel_values = values(dataset, na_rm=True)\n\n    # Generate frequency and return\n    if frequency is False:\n        unique_values = np.sort(np.unique(pixel_values.values.flatten()))\n    else:\n        unique_values = pd.Series(pixel_values.values.ravel()).value_counts().reset_index()\n        unique_values.columns = ['Value', 'Frequency']\n        if sort.lower() == \"frequency\" or sort.lower() == \"f\":\n            unique_values = unique_values.sort_values(by='Frequency')\n        elif sort.lower() == \"values\" or sort.lower() == \"value\" or sort.lower() == \"v\":\n            unique_values = unique_values.sort_values(by='Value')\n        else:\n            raise ValueError('Sort method is not supported [\"frequency\", \"value]')\n\n    return unique_values\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/canng/geonate/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>geonate could always use more documentation, whether as part of the official geonate docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/canng/geonate/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up geonate for local development.</p> <ol> <li> <p>Fork the geonate repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/geonate.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv geonate\n$ cd geonate/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 geonate tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/canng/geonate/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"geonate/","title":"geonate module","text":"<p>Main module.</p>"},{"location":"geonate/#geonate.geonate.rast","title":"<code>rast(input, mode='r', show_meta=False, **kwargs)</code>","text":"<p>Open a single geotif raster file using Rasterio</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AnyStr</code> <p>The file path indicates location of geotif file</p> required <code>mode</code> <code>AnyStr</code> <p>Data read mode, \u2018r\u2019 (read, the default), \u2018r+\u2019 (read/write), \u2018w\u2019 (write), or \u2018w+\u2019 (write/read). Default to mode = 'r'.</p> <code>'r'</code> <code>show_meta</code> <code>bool</code> <p>Whether to show the image metadata. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>optional</code> <p>All parameters in rasterio.open()</p> <code>{}</code> <p>Returns:</p> Type Description <code>Raster object (raster)</code> <p>Rasterio RasterReader object</p> Source code in <code>geonate/geonate.py</code> <pre><code>def rast(input: AnyStr, mode='r', show_meta: Optional[bool]=False, **kwargs):\n    \"\"\"Open a single geotif raster file using Rasterio\n\n    Args:\n        input (AnyStr): The file path indicates location of geotif file\n        mode (AnyStr): Data read mode, \u2018r\u2019 (read, the default), \u2018r+\u2019 (read/write), \u2018w\u2019 (write), or \u2018w+\u2019 (write/read). Default to mode = 'r'.\n        show_meta (bool, optional): Whether to show the image metadata. Defaults to False.\n        **kwargs (optional): All parameters in rasterio.open()\n\n    Returns:\n        Raster object (raster): Rasterio RasterReader object\n\n    \"\"\"    \n    import rasterio\n    import os\n\n    img = rasterio.open(input, mode= mode, **kwargs)\n    basename = os.path.basename(input)\n\n    # show meta \n    if show_meta is True:\n        meta = img.meta\n        print(f\"Opening: {basename}\\n{meta}\")\n\n    return img    \n</code></pre>"},{"location":"geonate/#geonate.geonate.vect","title":"<code>vect(input, show_meta=False, **kwargs)</code>","text":"<p>Read shapefile vector file using Geopandas </p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>AnyStr</code> <p>The file path indicates location of shapefile </p> required <code>show_meta</code> <code>bool</code> <p>Whether to show the image metadata. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>optional</code> <p>All parameters in gpd.read_file()</p> <code>{}</code> <p>Returns:</p> Type Description <code>Shapefile (geodataframe)</code> <p>Geodataframe of shapefile with attributes from geopandas object</p> Source code in <code>geonate/geonate.py</code> <pre><code>def vect(input: AnyStr, show_meta: Optional[bool]=False, **kwargs):\n    \"\"\"Read shapefile vector file using Geopandas \n\n    Args:\n        input (AnyStr): The file path indicates location of shapefile \n        show_meta (bool, optional): Whether to show the image metadata. Defaults to False.\n        **kwargs (optional): All parameters in gpd.read_file()\n\n    Returns:\n        Shapefile (geodataframe): Geodataframe of shapefile with attributes from geopandas object\n\n    \"\"\"\n    import geopandas as gpd\n    import os\n\n    vect = gpd.read_file(input, **kwargs)\n\n    # show meta \n    if show_meta is True:\n        basename = os.path.basename(input)\n        crs = vect.crs\n        datashape = vect.shape\n        print(f\"Opening: {basename}\\n Projection (crs): {crs}\\n Data shape: {datashape}\")\n\n    return vect\n</code></pre>"},{"location":"geonate/#geonate.geonate.writeRaster","title":"<code>writeRaster(input, output, meta=None, compress='lzw')</code>","text":"<p>Write raster Geotif from Raster or Data Array using Rasterio</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | array</code> <p>Raster or Data array in form of [band, height, width]</p> required <code>output</code> <code>AnyStr</code> <p>Output file path</p> required <code>meta</code> <code>Dict</code> <p>Rasterio profile settings needed when input is dataArray. Defaults to None.</p> <code>None</code> <code>compress</code> <code>AnyStr</code> <p>Compression algorithm ['lzw', 'deflate']. Defaults to 'lzw'.</p> <code>'lzw'</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any local variable. It writes raster file to local drive (.tif).</p> Source code in <code>geonate/geonate.py</code> <pre><code>def writeRaster(input, output, meta: Optional[Dict]=None, compress: Optional[AnyStr] = 'lzw'):\n    \"\"\"Write raster Geotif from Raster or Data Array using Rasterio\n\n    Args:\n        input (raster | array): Raster or Data array in form of [band, height, width]\n        output (AnyStr): Output file path\n        meta (Dict, optional): Rasterio profile settings needed when input is dataArray. Defaults to None.\n        compress (AnyStr, optional): Compression algorithm ['lzw', 'deflate']. Defaults to 'lzw'.\n\n    Returns:\n        None: The function does not return any local variable. It writes raster file to local drive (.tif).\n\n    \"\"\"   \n    import rasterio\n    import numpy as np\n\n    # Input is rasterio image\n    if isinstance(input, rasterio.DatasetReader):\n        meta_out = input.meta\n        data_array = input.read()\n\n        # compress data or not\n        if compress is None:\n            meta_out = meta_out\n        else:\n            if compress.lower() == 'deflate':\n                meta_out.update({'compress': 'deflate'})\n            elif compress.lower() == 'lzw':\n                meta_out.update({'compress': 'lzw'})\n            else:\n                raise ValueError('Compress method is not supported')\n\n        # output has single band\n        if len(data_array.shape) == 2:\n            meta_out['count'] = int(1)\n            with rasterio.open(output, 'w', **meta_out) as dst:\n                for band in range(0, 1):\n                    data = data_array\n                    dst.write(data, band + 1)\n        # output has multi bands\n        else:\n            meta_out['count'] = int(data_array.shape[0])\n            with rasterio.open(output, 'w', **meta_out) as dst:\n                for band in range(0, int(data_array.shape[0])):\n                    data = data_array[band, : , : ]\n                    dst.write(data, band + 1)\n\n    # input is data array\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Input is dataArray, please give metadata profile')\n        else:        \n        # compress data or not\n            if compress is None:\n                meta = meta\n            else:\n                if compress.lower() == 'deflate':\n                    meta.update({'compress': 'deflate'})\n                elif compress.lower() == 'lzw':\n                    meta.update({'compress': 'lzw'})\n                else:\n                    raise ValueError('Compress method is not supported')\n\n            # output has single band\n            if len(input.shape) == 2:\n                meta['count'] = int(1)\n                with rasterio.open(output, 'w', **meta) as dst:\n                    for band in range(0, 1):\n                        data = input\n                        dst.write(data, band + 1)\n            # output has multi bands\n            else:\n                meta['count'] = int(input.shape[0])\n                with rasterio.open(output, 'w', **meta) as dst:\n                    for band in range(0, int(input.shape[0])):\n                        data = input[band, : , : ]\n                        dst.write(data, band + 1)\n    else:\n        raise ValueError('Input data is not supported')    \n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install geonate, run this command in your terminal:</p> <pre><code>pip install geonate\n</code></pre> <p>This is the preferred method to install geonate, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install geonate from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/canng/geonate\n</code></pre>"},{"location":"plot/","title":"plot module","text":"<p>The visualization module</p>"},{"location":"plot/#geonate.plot.DiscreteColors","title":"<code>DiscreteColors(colors=None, ncolors=3, seed=None)</code>","text":"<p>Generates a discrete colormap with a specified number of colors.</p> <p>Parameters:</p> Name Type Description Default <code>ncolors</code> <code>int</code> <p>Number of colors to include in the colormap. Default is 3.</p> <code>3</code> <code>seed</code> <code>int</code> <p>Seed for the random number generator to ensure reproducibility. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ListedColormap</code> <p>A matplotlib ListedColormap object with the specified number of colors.</p> Source code in <code>geonate/plot.py</code> <pre><code>def DiscreteColors(colors=None, ncolors=3, seed=None):\n    \"\"\"\n    Generates a discrete colormap with a specified number of colors.\n\n    Args:\n        ncolors (int): Number of colors to include in the colormap. Default is 3.\n        seed (int, optional): Seed for the random number generator to ensure reproducibility. Default is None.\n\n    Returns:\n        ListedColormap: A matplotlib ListedColormap object with the specified number of colors.\n\n    \"\"\"\n    import random\n    from matplotlib.colors import ListedColormap\n\n    # initial vector colors, currently 32 colors\n    if colors is None:\n        colors = [\n                        \"#000000\",  # Black\n                        \"#FFFFFF\",  # White\n                        \"#FF0000\",  # Red\n                        \"#00FF00\",  # Green\n                        \"#0000FF\",  # Blue\n                        \"#FFFF00\",  # Yellow\n                        \"#00FFFF\",  # Cyan\n                        \"#FF00FF\",  # Magenta\n                        \"#808080\",  # Gray\n                        \"#C0C0C0\",  # Silver\n                        \"#800000\",  # Maroon\n                        \"#808000\",  # Olive\n                        \"#800080\",  # Purple\n                        \"#008080\",  # Teal\n                        \"#000080\",  # Navy\n                        \"#FFA500\",  # Orange\n                        \"#FFC0CB\",  # Pink\n                        \"#A52A2A\",  # Brown\n                        \"#00FF00\",  # Lime\n                        \"#4B0082\",  # Indigo\n                        \"#EE82EE\",  # Violet\n                        \"#F5F5DC\",  # Beige\n                        \"#FF7F50\",  # Coral\n                        \"#40E0D0\",  # Turquoise\n                        \"#E6E6FA\",  # Lavender\n                        \"#FFDAB9\",  # Peach\n                        \"#98FF98\",  # Mint\n                        \"#F5DEB3\",  # Wheat\n                        \"#F0E68C\",  # Khaki\n                        \"#DDA0DD\",  # Plum\n                        \"#D3D3D3\",  # Light Grey\n                        \"#A9A9A9\"   # Dark Grey\n                    ]\n        ncolors = ncolors\n\n        # Initialize the custom colors\n        custom_colors = None\n\n        # Randomly pick out colors by numbers of colors\n        if custom_colors is None:\n            random.seed(seed)\n            custom_colors = random.sample(colors, ncolors)\n\n    elif colors is not None:\n        ncolors = len(colors)\n        custom_colors = colors    \n\n    # Create colormap from custom colors picked\n    cmap_custom = ListedColormap(custom_colors[ : ncolors])\n\n    return cmap_custom\n</code></pre>"},{"location":"plot/#geonate.plot.colormaps","title":"<code>colormaps()</code>","text":"<p>Display all available colormaps in Matplotlib.</p> <p>This function generates a plot that shows all the colormaps available in Matplotlib. Each colormap is displayed as a horizontal gradient bar.</p> Source code in <code>geonate/plot.py</code> <pre><code>def colormaps():   \n    \"\"\"\n    Display all available colormaps in Matplotlib.\n\n    This function generates a plot that shows all the colormaps available in Matplotlib.\n    Each colormap is displayed as a horizontal gradient bar.\n\n    \"\"\" \n    import numpy as np\n    import matplotlib.pyplot as plt\n\n    # Get all colormaps available in Matplotlib\n    colormaps = plt.colormaps()\n\n    # Generate a gradient to display colormaps\n    gradient = np.linspace(0, 1, 256).reshape(1, -1)\n\n    # Set figure size\n    fig, ax = plt.subplots(figsize=(10, len(colormaps) * 0.25))\n\n    # Loop through colormaps and display them\n    for i, cmap in enumerate(colormaps):\n        ax.imshow(np.vstack([gradient] * 5), aspect='auto', cmap=cmap, extent=[0, 10, i, i + 1])\n\n    # Formatting\n    ax.set_yticks(np.arange(len(colormaps)) + 0.5)\n    ax.set_yticklabels(colormaps)\n    ax.set_xticks([])\n    ax.set_title(\"Matplotlib Colormaps\", fontsize=12, fontweight=\"bold\")\n    ax.set_ylim(0, len(colormaps))\n\n    plt.show()\n</code></pre>"},{"location":"plot/#geonate.plot.plotMap","title":"<code>plotMap(image, cmap=None, figsize=(6, 6), axis_off=False, colorbar=True, cbar_shrink=0.5, colorbar_name='Cluster', mapTitle=None, fontFamily='Arial', imgPath=None, resolution=300)</code>","text":"<p>Plots an image with discrete values</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>The data array in image  format (Height x Width x Bands).</p> required <code>cmap</code> <code>str or Colormap</code> <p>Colormap to use for the image. Default is None.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Size of the figure in inches. Default is (6, 6).</p> <code>(6, 6)</code> <code>axis_off</code> <code>bool</code> <p>Remove axis number (stick). Default is False.</p> <code>False</code> <code>colorbar</code> <code>bool</code> <p>Whether to display a colorbar. Default is True.</p> <code>True</code> <code>cbar_shrink</code> <code>float</code> <p>Fraction by which to multiply the size of the colorbar. Default is 0.5.</p> <code>0.5</code> <code>colorbar_name</code> <code>str</code> <p>Label for the colorbar. Default is 'Cluster'.</p> <code>'Cluster'</code> <code>mapTitle</code> <code>str</code> <p>Title of the map. Default is None.</p> <code>None</code> <code>fontFamily</code> <code>str</code> <p>Font family for the plot. Default is 'Arial'.</p> <code>'Arial'</code> <code>imgPath</code> <code>str</code> <p>Path to save the figure with extension (eg., *.jpg). Default is None.</p> <code>None</code> <code>resolution</code> <code>int</code> <p>Resolution of the saved figure in DPI. Default is 300.</p> <code>300</code> Source code in <code>geonate/plot.py</code> <pre><code>def plotMap(image, cmap=None, figsize=(6,6), axis_off=False, colorbar=True, cbar_shrink=0.5, colorbar_name='Cluster', mapTitle=None, fontFamily='Arial', imgPath=None, resolution=300):\n    \"\"\"\n    Plots an image with discrete values\n\n    Args:\n        image (np.ndarray): The data array in image  format (Height x Width x Bands).\n        cmap (str or Colormap, optional): Colormap to use for the image. Default is None.\n        figsize (tuple, optional): Size of the figure in inches. Default is (6, 6).\n        axis_off (bool, optional): Remove axis number (stick). Default is False.\n        colorbar (bool, optional): Whether to display a colorbar. Default is True.\n        cbar_shrink (float, optional): Fraction by which to multiply the size of the colorbar. Default is 0.5.\n        colorbar_name (str, optional): Label for the colorbar. Default is 'Cluster'.\n        mapTitle (str, optional): Title of the map. Default is None.\n        fontFamily (str, optional): Font family for the plot. Default is 'Arial'.\n        imgPath (str, optional): Path to save the figure with extension (eg., *.jpg). Default is None.\n        resolution (int, optional): Resolution of the saved figure in DPI. Default is 300.\n\n    \"\"\"\n    import numpy as np\n    import matplotlib.pyplot as plt\n    plt.rcParams[\"font.family\"] = fontFamily\n\n    # Check input data\n    if not isinstance(image, np.ndarray):\n        raise ValueError('Input image must data array in image format (Height x Width x Bands)')\n    else:\n        plt.figure(figsize= figsize)\n        plt.imshow(image, cmap= cmap)\n\n        # Add color bar\n        if colorbar is True:\n            plt.colorbar(label= colorbar_name, shrink= cbar_shrink)\n        # Add map title\n        if mapTitle is not None:\n            plt.title(mapTitle)\n        # Remove axis number\n        if axis_off is True:\n            plt.axis('off')\n        # Save plot\n        if imgPath is not None:\n            plt.savefig(imgPath, dpi= resolution)\n\n        plt.tight_layout()\n        plt.show()\n</code></pre>"},{"location":"plot/#geonate.plot.plotRGB","title":"<code>plotRGB(input, rgb=(0, 1, 2), stretch=True, str_clip=2, figsize=(10, 10), **kwargs)</code>","text":"<p>Plot a 3-band RGB image using earthpy.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>rasterio.DatasetReader | np.ndarray</code> <p>Rasterio image or data array.</p> required <code>rgb</code> <code>tuple</code> <p>Indices of the RGB bands. Defaults to (0, 1, 2).</p> <code>(0, 1, 2)</code> <code>stretch</code> <code>bool</code> <p>Apply contrast stretching. Defaults to True.    </p> <code>True</code> <code>str_clip</code> <code>int</code> <p>The percentage of clip to apply to the stretch. Default = 2 (2 and 98).  </p> <code>2</code> <code>figsize</code> <code>numeric tuple</code> <p>Width and Height. Defaults to (10, 10) inches.</p> <code>(10, 10)</code> <code>**kwargs</code> <p>Additional optional parameters for earthpy.plot.plot_rgb(), such as stretch=True for contrast stretching.</p> <code>{}</code> Source code in <code>geonate/plot.py</code> <pre><code>def plotRGB(input, rgb=(0, 1, 2), stretch=True, str_clip: int = 2, figsize=(10,10), **kwargs):\n    \"\"\"\n    Plot a 3-band RGB image using earthpy.\n\n    Args:\n        input (rasterio.DatasetReader | np.ndarray): Rasterio image or data array.\n        rgb (tuple, optional): Indices of the RGB bands. Defaults to (0, 1, 2).\n        stretch (bool, optional): Apply contrast stretching. Defaults to True.    \n        str_clip (int): The percentage of clip to apply to the stretch. Default = 2 (2 and 98).  \n        figsize (numeric tuple): Width and Height. Defaults to (10, 10) inches.\n        **kwargs: Additional optional parameters for earthpy.plot.plot_rgb(), such as stretch=True for contrast stretching.\n\n    \"\"\"    \n    import numpy as np\n    import rasterio\n    import earthpy.plot as ep\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Check data dimension to make sure it is a multiple band image\n    if len(dataset) &lt;= 2:\n        raise ValueError('Image has only one band, please provide at least 3-band image')\n\n    # Visualize the input dataset\n    ep.plot_rgb(dataset, rgb= rgb, stretch=stretch, str_clip=str_clip, figsize=figsize, **kwargs)\n</code></pre>"},{"location":"plot/#geonate.plot.plot_bands","title":"<code>plot_bands(input, cmap='Greys_r', cols=3, figsize=(10, 10), cbar=True, **kwargs)</code>","text":"<p>Plot a raster image or data array using earthpy.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array</p> required <code>cmap</code> <code>str</code> <p>Colormap for the plot. Defaults to 'Greys_r'.</p> <code>'Greys_r'</code> <code>cols</code> <code>int</code> <p>Numbers of column on the plot. Defaults to cols = 3.</p> <code>3</code> <code>figsize</code> <code>numeric tuple</code> <p>Width and Height. Defaults to (10, 10) inches.</p> <code>(10, 10)</code> <code>cbar</code> <code>bool</code> <p>Show color cbar. Defaults to True.  </p> <code>True</code> <code>**kwargs</code> <code>AnyStr</code> <p>All optional parameters taken from earthpy.plot.plot_bands(), such as cmap='Spectral' for color shade</p> <code>{}</code> Source code in <code>geonate/plot.py</code> <pre><code>def plot_bands(input, cmap='Greys_r', cols=3, figsize=(10,10), cbar=True, **kwargs):\n    \"\"\"Plot a raster image or data array using earthpy.\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array\n        cmap (str, optional): Colormap for the plot. Defaults to 'Greys_r'.\n        cols (int): Numbers of column on the plot. Defaults to cols = 3.\n        figsize (numeric tuple): Width and Height. Defaults to (10, 10) inches.\n        cbar (bool): Show color cbar. Defaults to True.  \n        **kwargs (AnyStr, optional): All optional parameters taken from earthpy.plot.plot_bands(), such as cmap='Spectral' for color shade\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    import earthpy.plot as ep\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # Visualize the input dataset\n    ep.plot_bands(dataset, cmap=cmap, cols=cols, figsize=figsize, cbar=cbar,**kwargs)\n</code></pre>"},{"location":"plot/#geonate.plot.plot_raster","title":"<code>plot_raster(input, layername=None, rgb=None, stretch='linear', brightness=None, contrast=None, opacity=1, zoom=5, basemap='OSM', output=None)</code>","text":"<p>Plots a basemap with an overlay of raster data.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader</code> <p>The input raster dataset.</p> required <code>layername</code> <code>Anstr</code> <p>Layer name of image.</p> <code>None</code> <code>rgb</code> <code>list</code> <p>List of RGB bands to visualize. Defaults to None.</p> <code>None</code> <code>stretch</code> <code>AnyStr</code> <p>Stretch method for the image ('linear', 'hist', 'custom'). Defaults to 'linear'.</p> <code>'linear'</code> <code>brightness</code> <code>float</code> <p>Brightness value for custom stretch. Defaults to None.</p> <code>None</code> <code>contrast</code> <code>float</code> <p>Contrast value for custom stretch. Defaults to None.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Opacity of the image overlay. Defaults to 1.</p> <code>1</code> <code>zoom</code> <code>float</code> <p>Initial zoom level of the map. Defaults to 5.</p> <code>5</code> <code>basemap</code> <code>AnyStr</code> <p>Basemap type ('OSM', 'CartoDB Positron', 'CartoDB Dark Matter', 'OpenTopoMap', 'Esri Satellite', 'Esri Street Map', 'Esri Topo', 'Esri Canvas'). Defaults to 'OSM'.</p> <code>'OSM'</code> <code>output</code> <code>AnyStr</code> <p>File path to write out html file to local directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>folium.Map</code> <p>A folium map object with the raster data overlay.</p> Source code in <code>geonate/plot.py</code> <pre><code>def plot_raster(input, layername: Optional[AnyStr]=None, rgb: Optional[list]=None, stretch: Optional[AnyStr]='linear', brightness: Optional[float]=None, contrast: Optional[float]=None, opacity: Optional[float]=1, zoom: Optional[float]=5, basemap: Optional[AnyStr]='OSM', output: Optional[AnyStr]= None):\n    \"\"\"\n    Plots a basemap with an overlay of raster data.\n\n    Args:\n        input (DatasetReader): The input raster dataset.\n        layername (Anstr, optional): Layer name of image.\n        rgb (list, optional): List of RGB bands to visualize. Defaults to None.\n        stretch (AnyStr, optional): Stretch method for the image ('linear', 'hist', 'custom'). Defaults to 'linear'.\n        brightness (float, optional): Brightness value for custom stretch. Defaults to None.\n        contrast (float, optional): Contrast value for custom stretch. Defaults to None.\n        opacity (float, optional): Opacity of the image overlay. Defaults to 1.\n        zoom (float, optional): Initial zoom level of the map. Defaults to 5.\n        basemap (AnyStr, optional): Basemap type ('OSM', 'CartoDB Positron', 'CartoDB Dark Matter', 'OpenTopoMap', 'Esri Satellite', 'Esri Street Map', 'Esri Topo', 'Esri Canvas'). Defaults to 'OSM'.\n        output (AnyStr, optional): File path to write out html file to local directory. Defaults to None.\n\n    Returns:\n        folium.Map: A folium map object with the raster data overlay.\n\n    \"\"\"\n    import folium\n    from folium.raster_layers import ImageOverlay\n    import rasterio\n    import numpy as np\n    from .common import meter2degree, get_extent_local\n    from .processor import reproject\n\n\n    ### Check input data is raster or not and extract information\n    if isinstance(input, rasterio.DatasetReader):\n        # Convert image to lat/long if input is not in lat/long system\n        crs = input.crs.to_string()\n        if crs == \"EPSG:4326\":\n            input_converted = input\n        else:\n            resolution_degree = meter2degree(input.res[0])\n            input_converted = reproject(input, reference='EPSG:4326', res=resolution_degree)\n\n        # Extract data from image to visualize\n        if (input.count &lt;= 2):\n            print('Input image/data has less than 2 bands, it will load the first band only')\n            dataset = input.read(1)\n            imgData = dataset[:, :, np.newaxis]\n        elif (input.count &gt;= 3):\n            if rgb is None: \n                raise ValueError('Input is multiple band image, please provide rgb bands to visualize [3,2,1]')\n            else:\n                dataset = input.read(rgb)\n                imgData = np.transpose(dataset, (1, 2, 0)) # Transpose from raster dims (bands, width, height) to image dims (width, height, bands)\n    else:\n        raise ValueError(\"Input data is not supported. It must be raster image\")\n\n    # Check stretch method\n    if stretch is None:\n        data = imgData\n\n    elif stretch.lower() == 'linear':\n        data = np.clip((imgData  - imgData.min()) / (imgData.max() - imgData.min()) * 255, 0, 255).astype(np.uint8) # linear stretching based on min max values\n\n    elif stretch.lower() == 'hist' or stretch.lower() == 'histogram':\n        from skimage import exposure\n        data = exposure.equalize_hist(imgData)  # This returns a floating point image with values between 0 and 1\n        data = (data * 255).astype(np.uint8)  # Convert back to 8-bit image for display\n\n    elif stretch.lower() == 'custom':\n        if (contrast is None) or (brightness is None):\n            raise ValueError(\"contrast and brightness must be given for custom stretching method\")\n        else:\n            data = np.clip((imgData * contrast + brightness), 0, 255).astype(np.uint8)\n\n    else: \n        raise ValueError(\"Stretch method is not supported ('linear', 'hist', 'custom')\")\n\n    # Get Bounds values\n    left, bottom, right, top = get_extent_local(input_converted)[0]\n    lat_center = (top + bottom) / 2\n    lon_center = (left + right)/ 2\n    bounds = [[bottom, left], [top, right]]\n\n    # Create overlay image\n    if layername is not None:\n        image_overlay = ImageOverlay(image= data, bounds= bounds, opacity= opacity, name=layername)\n    else:\n        image_overlay = ImageOverlay(image= data, bounds= bounds, opacity= opacity, name='Layer')\n\n    # Add the image overlay to the map\n\n    # Take basemap\n    if basemap.lower() == 'openstreetmap' or basemap.lower() == 'osm' or basemap.lower() == 'open street map':\n        basemap_name = 'OpenStreetMap'\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom, tiles=basemap_name)\n\n    elif basemap.lower() == 'cartodbpositron' or basemap.lower() == 'cartodb positron' or basemap.lower() == 'light' :\n        basemap_name = 'Cartodb Positron'\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom, tiles=basemap_name)\n\n    elif basemap.lower() == 'cartodbdarkmatter' or basemap.lower() == 'cartodb dark matter' or basemap.lower() == 'cartodb dark' or basemap.lower() == 'dark':\n        basemap_name = 'Cartodb dark_matter'\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom, tiles=basemap_name)\n\n    elif basemap.lower() == 'opentopomap' or basemap.lower() == 'opentopo' or basemap.lower() == 'topo':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles='https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',\n            attr='&amp;copy; Topo Map',\n            name='Open Topo Map'\n        ).add_to(m)\n\n    elif basemap.lower() == 'esri satellite' or basemap.lower() == 'esrisatellite' or basemap.lower() == 'satellite':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles= 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n            attr='&amp;copy; Esri',\n            name='Esri Satellite'\n        ).add_to(m)\n\n    elif basemap.lower() == 'esri street' or basemap.lower() == 'esristreet' or basemap.lower() == 'streetmap' or basemap.lower() == 'street map':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles= 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',\n            attr='&amp;copy; Esri',\n            name='Esri Street Map'\n        ).add_to(m)\n\n    elif basemap.lower() == 'esri topo' or basemap.lower() == 'esritopo':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles= 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}',\n            attr='&amp;copy; Esri',\n            name='Esri Topo Map'\n        ).add_to(m)\n\n    elif basemap.lower() == 'esri canvas' or basemap.lower() == 'esricanvas' or basemap.lower() == 'canvas':\n        m = folium.Map(location=[lat_center, lon_center], zoom_start= zoom)\n        folium.TileLayer(\n            tiles= 'https://server.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer/tile/{z}/{y}/{x}',\n            attr='&amp;copy; Esri',\n            name='Esri Canvas Gray'\n        ).add_to(m)\n\n    else:\n        raise ValueError(\"Basemap is not supported, please select one of these maps ('OSM', 'CartoDB Positron', 'CartoDB Dark Matter', 'OpenTopoMap', 'Esri Satellite', 'Esri Street Map', 'Esri Topo', 'Esri Canvas')\")\n\n    # Add image to basemap    \n    image_overlay.add_to(m)\n    folium.LayerControl().add_to(m)\n\n    # Save map\n    if output is not None:\n        m.save(output)\n    else:\n        pass\n\n    return m  \n</code></pre>"},{"location":"post_classify/","title":"post_classify module","text":"<p>The Post-processing module</p>"},{"location":"post_classify/#geonate.post_classify.raster2shapefile","title":"<code>raster2shapefile(image, band=1)</code>","text":"<p>Converts a raster image to a shapefile (GeoDataFrame). This function reads a raster image, masks out NoData values, extracts shapes (polygons) from the raster, and converts them into a GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>rasterio.io.DatasetReader</code> <p>The raster image to be converted.</p> required <code>band</code> <code>int</code> <p>The band number to read from the raster image. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>gpd.GeoDataFrame</code> <p>A GeoDataFrame containing the extracted polygons and their corresponding values.</p> Source code in <code>geonate/post_classify.py</code> <pre><code>def raster2shapefile(image, band=1):\n    \"\"\"\n    Converts a raster image to a shapefile (GeoDataFrame).\n    This function reads a raster image, masks out NoData values, extracts shapes (polygons) from the raster,\n    and converts them into a GeoDataFrame.\n\n    Args:\n        image (rasterio.io.DatasetReader): The raster image to be converted.\n        band (int, optional): The band number to read from the raster image. Defaults to 1.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame containing the extracted polygons and their corresponding values.\n\n    \"\"\"\n    import geopandas as gpd\n    import rasterio\n    from rasterio.features import shapes\n    from shapely.geometry import shape\n\n    # Check input data\n    # Other input\n    if not isinstance(input, rasterio.DatasetReader):\n        raise ValueError('Input data is not supported, it must be raster object')    \n\n    # Other input\n    else:\n        ds =image.read(band)  \n        transform = image.transform\n\n        # Mask out NoData values\n        mask = image != image.nodata\n\n        # Extract shapes (polygons) from the raster\n        shapes_gen = shapes(ds, mask=mask, transform=transform)\n\n        # Convert to GeoDataFrame\n        polygons = []\n        values = []\n        for geom, value in shapes_gen:\n            polygons.append(shape(geom))\n            values.append(value)\n\n        gdf = gpd.GeoDataFrame({'geometry': polygons, 'class': values}, crs=image.crs)\n\n        return gdf\n</code></pre>"},{"location":"post_classify/#geonate.post_classify.reclassify","title":"<code>reclassify(input, breakpoints, classes)</code>","text":"<p>Reclassify image with discrete or continuous values</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | array</code> <p>Raster or data array input</p> required <code>breakpoints</code> <code>list</code> <p>Number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]</p> required <code>classes</code> <code>list</code> <p>Number list, define classes, number of classes equal number of breakpoints minus 1</p> required <p>Returns:</p> Type Description <code>raster | dataArray</code> <p>Reclassified result in raster or data array depending on input, containing all image pixel values</p> Source code in <code>geonate/post_classify.py</code> <pre><code>def reclassify(input, breakpoints, classes):\n    \"\"\"\n    Reclassify image with discrete or continuous values\n\n    Args:\n        input (raster | array): Raster or data array input\n        breakpoints (list): Number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]\n        classes (list): Number list, define classes, number of classes equal number of breakpoints minus 1\n\n    Returns:\n        raster | dataArray: Reclassified result in raster or data array depending on input, containing all image pixel values\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    from .common import array2raster\n\n    # *****************************************\n    # Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        if len(input.shape) == 2:\n            dataset = input.read()\n            meta = input.meta\n        elif len(input.shape) == 3:\n            if  input.shape[0] &gt; 1:\n                raise ValueError('Input data has more than one band')\n            else:\n                dataset = input.read(1)\n                meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if (len(input.shape)) &gt; 2 and (input.shape[0] &gt; 1):\n            raise ValueError('Input data has more than one band')\n        else:\n            dataset = input\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    # Create unique values and empty data array to store reclassified result \n    uniques = np.unique(dataset)\n    reclassified = np.zeros_like(dataset)\n\n    # *****************************************\n    # If image has discrete values\n    if len(uniques) == len(classes): \n        if len(breakpoints) == len(classes):\n            for i in range(len(classes)):\n                reclassified[dataset == breakpoints[i]] = classes[i]\n        elif len(breakpoints) == (len(classes)-1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n\n    # If image has continuous values\n    else:\n        if len(breakpoints) == (len(classes)+1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n\n    # *****************************************\n    # Define output\n    if isinstance(input, rasterio.DatasetReader):\n        reclassified_raster = array2raster(reclassified, meta)\n    else:\n        reclassified_raster = reclassified\n\n    return reclassified_raster\n</code></pre>"},{"location":"processor/","title":"processor module","text":"<p>The processor module</p>"},{"location":"processor/#geonate.processor.cellSize","title":"<code>cellSize(input, unit='km', meta=None)</code>","text":"<p>Calculate pixel size (area), the input has to be in the projection of 'EPSG:4326'. If not, it can be reprojected by \"project\" function</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <p>rasterio image or data array</p> required <code>unit</code> <code>~AnyStr</code> <p>string, default is \"km\", the unit to calculate area</p> <code>'km'</code> <code>meta</code> <code>Optional[~AnyStr]</code> <p>optional dict, metadata in case input is data array</p> <code>None</code> <p>Examples:</p> <p>img = raster.rast('./Sample_data/temperature.tif') cellArea = processor.cellSize(img, unit='km')    </p> <p>Returns:</p> Type Description <code>raster</code> <p>a raster of area in selected unit.</p> Source code in <code>geonate/processor.py</code> <pre><code>def cellSize(input, unit: AnyStr='km', meta: Optional[AnyStr]=None):\n    '''\n    Calculate pixel size (area), the input has to be in the projection of 'EPSG:4326'. If not, it can be reprojected by \"project\" function\n\n    Parameters:\n        input: rasterio image or data array\n        unit: string, default is \"km\", the unit to calculate area\n        meta: optional dict, metadata in case input is data array\n\n    Example:\n       img = raster.rast('./Sample_data/temperature.tif')\n       cellArea = processor.cellSize(img, unit='km')    \n\n    Returns:\n        raster: a raster of area in selected unit.\n\n    '''\n    import rasterio\n    import numpy as np\n    from .common import array2raster\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        if len(input.shape) == 2:\n            dataset = input.read()\n            meta = input.meta\n        else:\n            dataset = input.read(1)\n            meta = input.meta\n    elif isinstance(input, np.ndarray):\n        if meta is None:\n            raise ValueError('Please provide input metadata')\n        else:\n            if len(input) &gt; 2:\n                dataset = input[0, :, : ]\n            else:\n                dataset = input\n            meta = meta\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Read metadata\n    transform = meta['transform']\n    pix_width = transform[0]\n    upper_X = transform[2]\n    upper_Y = transform[5]\n    rows = meta['height']\n    cols = meta['width']\n    lower_X = upper_X + transform[0] * cols\n    lower_Y = upper_Y + transform[4] * rows\n\n    lats = np.linspace(upper_Y, lower_Y, rows + 1)\n\n    a = 6378137.0  # Equatorial radius\n    b = 6356752.3142  # Polar radius\n\n    # Degrees to radians\n    lats = lats * np.pi/180\n\n    # Intermediate vars\n    e = np.sqrt(1-(b/a)**2)\n    sinlats = np.sin(lats)\n    zm = 1 - e * sinlats\n    zp = 1 + e * sinlats\n\n    # Distance between meridians\n    q = pix_width/360\n\n    # Compute areas for each latitude in square km\n    areas_to_equator = np.pi * b**2 * ((2*np.arctanh(e*sinlats) / (2*e) + sinlats / (zp*zm))) / 10**6\n    areas_between_lats = np.diff(areas_to_equator)\n    areas_cells = np.abs(areas_between_lats) * q\n\n    # Create empty array to store output\n    cellArea = np.zeros_like(dataset, dtype=np.float32)\n\n    # Assign estimated cell area to every pixel\n    if len(cellArea.shape) == 2:\n        for i in range(0, cellArea.shape[1]):\n            cellArea[:, i] = areas_cells.flatten()\n    else:\n        for i in range(0, cellArea.shape[2]):\n            cellArea[:, :, i] = areas_cells.flatten()\n\n    ### Update metadata\n    meta.update({'dtype': np.float32, 'count': 1})\n\n    ### Convert unit (if applicable)\n    if (unit.lower() == 'km') or (unit.lower() == 'kilometer'):\n        outArea = cellArea\n    elif (unit.lower() == 'm') or (unit.lower() == 'meter'):\n        outArea = cellArea * 1_000_000\n    elif (unit.lower() == 'ha') or (unit.lower() == 'hectare'):\n        outArea = cellArea * 10_000\n\n    # Output\n\n    outArea = array2raster(cellArea, meta)\n\n    return outArea, meta\n</code></pre>"},{"location":"processor/#geonate.processor.crop","title":"<code>crop(input, reference, invert=False, nodata=True)</code>","text":"<p>Crops a raster file based on a reference shapefile or raster file. Optionally inverts the crop.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster</code> <p>The input raster file.</p> required <code>reference</code> <code>shapefile | raster</code> <p>The reference shapefile (GeoDataFrame) or raster file (DatasetReader) to define the crop boundary.</p> required <code>invert</code> <code>bool</code> <p>If True, inverts the crop to mask out the area within the boundary. Defaults to False.</p> <code>False</code> <code>nodata</code> <code>bool</code> <p>If True, handles nodata values by converting the input to float32 and setting nodata to NaN. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>A clipped raster (raster)</code> <p>The cropped raster file.</p> Source code in <code>geonate/processor.py</code> <pre><code>def crop(input, reference, invert=False, nodata=True):\n    \"\"\"\n    Crops a raster file based on a reference shapefile or raster file. Optionally inverts the crop.\n\n    Args:\n        input (raster): The input raster file.\n        reference (shapefile | raster): The reference shapefile (GeoDataFrame) or raster file (DatasetReader) to define the crop boundary.\n        invert (bool, optional): If True, inverts the crop to mask out the area within the boundary. Defaults to False.\n        nodata (bool, optional): If True, handles nodata values by converting the input to float32 and setting nodata to NaN. Defaults to True.\n\n    Returns:\n        A clipped raster (raster): The cropped raster file.\n\n    \"\"\"\n    import rasterio\n    import geopandas as gpd\n    import numpy as np\n    from rasterio.transform import Affine\n    from shapely.geometry import mapping\n    from shapely.geometry import box\n    from .common import array2raster\n\n    # Condition to process nodata\n    if nodata is True:\n        # Convert datatype of input to float32 to store NA value\n        arr = input.read().astype(np.float32)\n        meta = input.meta\n        meta.update({'dtype': np.float32})\n        input_image = array2raster(arr, meta)\n    else: \n        input_image = input\n\n    ### Define boundary\n    # Reference is shapefile\n    if isinstance(reference, gpd.GeoDataFrame):\n        minx, miny, maxx, maxy = reference.total_bounds\n        # define box\n        bbox = box(minx, miny, maxx, maxy)\n        poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs=reference.crs)\n\n    # Reference is raster\n    elif isinstance(reference, rasterio.DatasetReader):\n        minx, miny, maxx, maxy = reference.bounds\n        # define box\n        bbox = box(minx, miny, maxx, maxy)\n        poly_bound = gpd.GeoDataFrame({'geometry': [bbox]}, crs=reference.crs)\n\n    # Others\n    else:\n        raise ValueError('Reference data is not supported')   \n\n    ### Invert crop\n    #### Condition for nodata\n    if nodata is True:\n        if invert is True:\n            clipped, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), invert=True, nodata= np.nan)\n        else:\n            clipped, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), crop=True, invert=False, nodata= np.nan)\n\n        # Update metadata\n        meta  = input.meta\n        meta.update({\n            'height': clipped.shape[1],\n            'width': clipped.shape[2],\n            'transform': geotranform,\n            'dtype': np.float32,\n            'nodata': np.nan\n            })\n    #\n    else:\n        if invert is True:\n            clipped, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), invert=True, nodata= 0)\n        else:\n            clipped, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly_bound.geometry.apply(mapping), crop=True, invert=False, nodata= 0)\n\n        # Update metadata\n        meta  = input.meta\n        meta.update({\n            'height': clipped.shape[1],\n            'width': clipped.shape[2],\n            'transform': geotranform,\n            'nodata': 0\n            })\n\n    # Convert array to raster\n    clipped_raster = array2raster(clipped, meta)\n\n    return clipped_raster\n</code></pre>"},{"location":"processor/#geonate.processor.extractValues","title":"<code>extractValues(input, roi, field, dataframe=True, names=None, prefix=None, tail=True)</code>","text":"<p>Extract pixel values from a raster image based on regions of interest (ROI) defined in a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster</code> <p>Rasterio image as input</p> required <code>roi</code> <code>shapefile</code> <p>Shapefile where GCP points are located, read by geopandas.</p> required <code>field</code> <code>AnyStr</code> <p>Field name in shapefile GCP to extract label values, e.g., 'class'. But this field must store number instead of string.</p> required <code>dataframe</code> <code>bool</code> <p>Whether to return a dataframe or separate X, y arrays. Defaults to True.</p> <code>True</code> <code>names</code> <code>list</code> <p>Expected names for each column in the dataframe. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>AnyStr</code> <p>Prefix for each band name. Defaults to None.</p> <code>None</code> <code>tail</code> <code>bool</code> <p>Whether to place the class value at the end or front of the dataframe. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame or Tuple</code> <p>Dataframe if dataframe=True, otherwise X and y arrays for training a model.</p> Source code in <code>geonate/processor.py</code> <pre><code>def extractValues(input, roi, field, dataframe: Optional[bool]=True, names: Optional[list]=None, prefix: Optional[AnyStr]=None, tail=True):\n    \"\"\"\n    Extract pixel values from a raster image based on regions of interest (ROI) defined in a shapefile.\n\n    Args:\n        input (raster): Rasterio image as input\n        roi (shapefile): Shapefile where GCP points are located, read by geopandas.\n        field (AnyStr): Field name in shapefile GCP to extract label values, e.g., 'class'. **But this field must store number instead of string**.\n        dataframe (bool, optional): Whether to return a dataframe or separate X, y arrays. Defaults to True.\n        names (list, optional): Expected names for each column in the dataframe. Defaults to None.\n        prefix (AnyStr, optional): Prefix for each band name. Defaults to None.\n        tail (bool, optional): Whether to place the class value at the end or front of the dataframe. Defaults to True.\n\n    Returns:\n        DataFrame or Tuple: Dataframe if dataframe=True, otherwise X and y arrays for training a model.\n\n    \"\"\"\n    import os\n    import rasterio\n    from rasterio.plot import reshape_as_image\n    import numpy as np\n    from shapely.geometry import mapping\n    import pandas as pd\n    from .common import array2raster\n\n    # *****************************************\n    # Define input image\n    # Other data type\n    if not isinstance(input, rasterio.DatasetReader):\n        raise ValueError('Input data is not supported')\n    # Input is raster\n    else:\n        # Convert datatype of input to float32 to store NA value\n        arr = input.read().astype(np.float32)\n        meta = input.meta\n        meta.update({'dtype': np.float32})\n        input_image = array2raster(arr, meta)\n\n    # *****************************************\n    # Convert shapefile to shapely geometry\n    geoms = roi.geometry.values\n\n    # Extract some metadata information\n    nbands = input_image.count\n    dtype_X = np.float32()\n    dtype_y = np.float32()\n\n    # Create empty array to contain X and y arrays\n    X = np.array([], dtype= dtype_X).reshape(0, nbands)\n    y = np.array([], dtype= dtype_y)\n\n    # Run loop over each features in shapefile to extract pixel values\n    for index, geom in enumerate(geoms):\n        poly = [mapping(geom)]\n\n        # Crop image based on feature\n        cropped, transform = rasterio.mask.mask(input_image, poly, crop=True, nodata=np.nan)\n\n        # Reshape dataset in form of (values, bands)\n        cropped_reshape = reshape_as_image(cropped)\n        reshapped = cropped_reshape.reshape(-1, nbands)\n\n        # Append 1D array y\n        y = np.append(y, [roi[field][index]] * reshapped.shape[0])\n\n        # vertical stack 2D array X\n        X = np.vstack((X, reshapped))\n\n    # Remove NA value from data\n    data = np.hstack((X, y.reshape(y.shape[0], 1))).astype(np.float32)\n    data_na = data[~np.isnan(data).any(axis=1)]\n    data_nodata = data_na[~(data_na == np.nan).any(axis=1)]\n\n    X_na = data_nodata[ :, 0:nbands]\n    y_na = data_nodata[ : , nbands]\n\n    # return dataframe\n    if dataframe is True:\n        y_na_reshape = y_na.reshape(-1,1)\n\n        # class tail\n        if tail is True:\n            arr = np.hstack([X_na, y_na_reshape])\n        else:\n            arr = np.hstack([y_na_reshape, X_na])\n\n        # Name is not given\n        if names is None:\n            if prefix is None:\n                names_band = [f'B{i}' for i in range(1, input_image.count +1)]\n                name_class = [str(field)]\n                if tail is True:\n                    names_list = names_band + name_class\n                else:\n                    names_list = name_class + names_band\n            else:\n                names_band = [f'{prefix}{i}' for i in range(1, input_image.count +1)]\n                name_class = [str(field)]\n                if tail is True:\n                    names_list = names_band + name_class\n                else:\n                    names_list = name_class + names_band\n            data = pd.DataFrame(arr, columns=names_list)            \n            return data\n\n        # Name is given\n        else:\n            if len(names) != (nbands + 1):\n                raise ValueError('Length of name should be equal to number of bands plus 1')\n            else:\n                if prefix is None:\n                    names_list = names\n                else:\n                    names_list = [f'{prefix}{name_i}' for name_i in names]\n            data = pd.DataFrame(arr, columns=names_list)            \n            return data\n\n    # Do not return dataframe\n    else:\n        return X_na, y_na\n</code></pre>"},{"location":"processor/#geonate.processor.layestack","title":"<code>layestack(input)</code>","text":"<p>Stacks multiple raster files or rasterio DatasetReader objects into a single multi-band raster.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>List of file paths to the input raster files or rasterio DatasetReader objects.</p> required <p>Returns:</p> Type Description <code>Stacked raster (raster)</code> <p>Stacked raster image.</p> Source code in <code>geonate/processor.py</code> <pre><code>def layestack(input):\n    \"\"\"\n    Stacks multiple raster files or rasterio DatasetReader objects into a single multi-band raster.\n\n    Parameters:\n        input (list): List of file paths to the input raster files or rasterio DatasetReader objects.\n\n    Returns:\n        Stacked raster (raster): Stacked raster image.\n\n    \"\"\"\n    import numpy as np\n    from .geonate import rast\n    from .common import array2raster, check_datatype_consistency, check_extension_consistency\n\n    # Initialize some parameters and variables\n    file2stack = []\n    stacked_array = []\n    nbands = len(input)\n\n    consistency, datatype = check_datatype_consistency(input)\n\n    # If input is list of file paths\n    if (consistency is True) and datatype == \"&lt;class 'str'&gt;\":\n        consistency_ext, extension = check_extension_consistency(input)\n\n        # If input is a list of tif files\n        if (consistency_ext is True) and (extension == 'tif'):\n            # Stack each band \n            for i, bandi in enumerate(input):\n                tmp = rast(input[i])\n                ds = tmp.read(1) # Read each raster and read data array\n                meta = tmp.meta \n                file2stack.append(ds) # stack each band in a list of data\n        # Other data extension\n        else:\n            raise ValueError('Data type is not supported')\n\n    # If input is local raster files \n    elif (consistency is True) and datatype == \"&lt;class 'rasterio.io.DatasetReader'&gt;\":\n        # Stack each band \n        for i, bandi in enumerate(input):\n            ds = input[i].read(1) # Read each band\n            meta = bandi.meta \n            file2stack.append(ds) # stack each band in a list of data\n    else:\n        raise ValueError('Data type is not supported')    \n\n    # convert list to array and update nbands\n    stacked_array = np.stack(file2stack, axis=0) \n    meta.update({'count': nbands})\n\n    # Convert array to raster\n    stacked_image = array2raster(stacked_array, meta)\n\n    return stacked_image\n</code></pre>"},{"location":"processor/#geonate.processor.mask","title":"<code>mask(input, reference, invert=False, nodata=True)</code>","text":"<p>Masks a raster file based on a reference shapefile or raster file. Optionally inverts the mask.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster</code> <p>The input raster file.</p> required <code>reference</code> <code>shapefile | raster</code> <p>The reference shapefile (GeoDataFrame) or raster file (DatasetReader) to define the mask boundary.</p> required <code>invert</code> <code>bool</code> <p>If True, inverts the mask to mask out the area within the boundary. Defaults to False.</p> <code>False</code> <code>nodata</code> <code>bool</code> <p>If True, handles nodata values by converting the input to float32 and setting nodata to NaN. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>A clipped and masked raster (raster)</code> <p>The cropped and masked raster file.</p> Source code in <code>geonate/processor.py</code> <pre><code>def mask(input, reference, invert=False, nodata=True):\n    \"\"\" \n    Masks a raster file based on a reference shapefile or raster file. Optionally inverts the mask.\n\n    Args:\n        input (raster): The input raster file.\n        reference (shapefile | raster): The reference shapefile (GeoDataFrame) or raster file (DatasetReader) to define the mask boundary.\n        invert (bool, optional): If True, inverts the mask to mask out the area within the boundary. Defaults to False.\n        nodata (bool, optional): If True, handles nodata values by converting the input to float32 and setting nodata to NaN. Defaults to True.\n\n    Returns:\n        A clipped and masked raster (raster): The cropped and masked raster file.\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    import shapely\n    from shapely.geometry import mapping\n    import geopandas as gpd\n    from .common import array2raster\n\n    ##########################################\n    #### Define boundary \n    if (isinstance(reference, gpd.GeoDataFrame)):\n        poly = reference\n        transform_poly = reference.transform\n        crs_poly = reference.crs\n\n    # Raster format\n    elif isinstance(reference, rasterio.DatasetReader):\n        ds_reference = reference.read(1)                                        # Extract only first band, transform, and crs\n        transform_poly = reference.meta['transform']\n        crs_poly = reference.meta['crs']\n\n        # Create mask from all value different from Nodata\n        masked = np.where(np.isnan(ds_reference), np.nan, 1)            # Replace values different than NA by 1\n        masked_convert = masked.astype(np.float32)                             # Redefine data type of float32 to store n.nan\n\n        # Create generator that yields (geometry, value) pairs for each shape found in the masked_convert\n        shp = rasterio.features.shapes(masked_convert, mask= ~np.isnan(masked_convert), transform= transform_poly)\n        poly = []\n        values = []\n\n        # Iterate over mask = 1, convert to shapely geometry and append \n        for shape, value in shp:\n            if value == 1:\n                poly.append(shapely.geometry.shape(shape))                         # convert a GeoJSON-like dictionary object into a Shapely geometry object\n                values.append(value)\n\n        # Create poly from mask\n        poly = gpd.GeoDataFrame({'geometry': poly, 'value': values})\n        poly.set_crs(crs_poly.to_string(), inplace=True)\n\n    else:\n        raise ValueError('Reference data is not supported')\n\n    ##########################################\n    ### Define nodata\n    if nodata is True:\n        # Convert datatype of input to float32 to store NA value\n        arr = input.read().astype(np.float32)\n        meta = input.meta\n        meta.update({'dtype': np.float32})\n        input_image = array2raster(arr, meta)\n\n        ### Invert mask\n        if invert is True:\n            masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, invert=True, nodata=np.nan)\n        else:\n            masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, nodata= np.nan)\n\n        meta  = input_image.meta\n        meta.update({\n            'height': masked_img.shape[1],\n            'width': masked_img.shape[2],\n            'transform': geotranform,\n            'dtype': np.float32,\n            'nodata': np.nan})\n\n    else: \n        input_image = input\n\n        ### Invert mask\n        if invert is True:\n            masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, invert=True, nodata= 0)\n        else:\n            masked_img, geotranform = rasterio.mask.mask(dataset=input_image, shapes= poly.geometry.apply(mapping), crop=True, nodata= 0)\n\n        meta  = input_image.meta\n        meta.update({\n            'height': masked_img.shape[1],\n            'width': masked_img.shape[2],\n            'transform': geotranform,\n            'nodata': 0})\n\n    ### Convert array back to raster         \n    masked_raster = array2raster(masked_img, meta)\n\n    return masked_raster\n</code></pre>"},{"location":"processor/#geonate.processor.match","title":"<code>match(input, reference, method='near', nodata=None, **kwargs)</code>","text":"<p>Match input image to the reference image in terms of projection, resolution, and bound extent.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster</code> <p>Rasterio objective needs to match the reference.</p> required <code>reference</code> <code>raster</code> <p>Rasterio object taken as reference to match the input image.</p> required <code>method</code> <code>AnyStr</code> <p>String defines resampling method (if applicable) to resample if having different resolution (Method similar to resample). Defaults to 'near'.</p> <code>'near'</code> <code>**kwargs</code> <code>optional</code> <p>All parameters that can be passed to rasterio.warp.reproject function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>raster</code> <p>Matched raster image with the same projection, resolution, and extent as the reference image.</p> Source code in <code>geonate/processor.py</code> <pre><code>def match(input, reference, method='near', nodata=None, **kwargs):\n    \"\"\"\n    Match input image to the reference image in terms of projection, resolution, and bound extent.\n\n    Args:\n        input (raster): Rasterio objective needs to match the reference.\n        reference (raster): Rasterio object taken as reference to match the input image.\n        method (AnyStr, optional): String defines resampling method (if applicable) to resample if having different resolution (Method similar to resample). Defaults to 'near'.\n        **kwargs (optional): All parameters that can be passed to rasterio.warp.reproject function.\n\n    Returns:\n        raster: Matched raster image with the same projection, resolution, and extent as the reference image.\n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    from rasterio.transform import from_bounds\n    import numpy as np\n    from .common import get_extent_local, array2raster\n\n    # *****************************************\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input.read()\n        src_meta = input.meta\n        src_crs = input.crs\n        src_count = input.count\n        src_transform = input.transform\n        src_dtype = input.dtypes[0]\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    ### Define reference image\n    if isinstance(reference, rasterio.DatasetReader):\n        reference_image = reference.read()\n        reference_meta = reference.meta\n        reference_transform = reference.transform\n        reference_width = reference.width\n        reference_height = reference.height\n        reference_crs = reference.crs\n        reference_profile = reference.profile.copy()\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    # Update profile for output\n    output_meta = src_meta.copy()\n    output_meta.update({\n        'crs': reference_crs,\n        'transform': reference_transform,\n        'width': reference_width,\n        'height': reference_height, \n        'compress': 'lzw',\n        'dtype': src_dtype\n        })\n\n    # Allocate destination array\n    dst_data = np.empty(shape=(src_count, reference_height, reference_width), dtype= input.dtypes[0])\n\n    # *****************************************\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # *****************************************\n    # Reproject each band\n    for i in range(src_count):\n        reproject(\n            source= input_image[i],\n            destination= dst_data[i],\n            src_transform= src_transform,\n            src_crs= src_crs,\n            dst_transform= reference_transform,\n            dst_crs= reference_crs,\n            resampling= resampleAlg, **kwargs\n        )\n\n        # *****************************************\n        # Mask out other values\n        if (nodata is None):\n            dst_data = dst_data\n            output_meta.update({\n                'dtype': input.dtypes[0]\n                })\n        elif (isinstance(nodata, (int, float))):\n            dst_data = np.where(dst_data == nodata, np.nan, dst_data)\n            dst_data = dst_data.astype(np.float32)\n\n            output_meta.update({\n                'dtype': np.float32,\n                'nodata': np.nan\n                })            \n        else: \n            raise ValueError('NoData is not supported (int or float)')        \n\n        # *****************************************\n        # Convert to raster        \n        match_raster = array2raster(dst_data, output_meta)\n\n        return match_raster\n</code></pre>"},{"location":"processor/#geonate.processor.match_boundary","title":"<code>match_boundary(input, reference, method='near', **kwargs)</code>","text":"<p>Match input image to the reference image to return an image within the bigger boundary.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster</code> <p>Rasterio objective needs to match the reference.</p> required <code>reference</code> <code>raster</code> <p>Rasterio object taken as reference to match the input image.</p> required <code>method</code> <code>AnyStr</code> <p>String defines resampling method (if applicable) to resample if having different resolution (Method similar to resample). Defaults to 'near'.</p> <code>'near'</code> <code>**kwargs</code> <code>optional</code> <p>All parameters that can be passed to rasterio.warp.reproject function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>raster</code> <p>Matched raster image with the same projection, resolution, and extent as the reference image.</p> Source code in <code>geonate/processor.py</code> <pre><code>def match_boundary(input, reference, method='near', **kwargs):\n    \"\"\"\n    Match input image to the reference image to return an image within the bigger boundary.\n\n    Args:\n        input (raster): Rasterio objective needs to match the reference.\n        reference (raster): Rasterio object taken as reference to match the input image.\n        method (AnyStr, optional): String defines resampling method (if applicable) to resample if having different resolution (Method similar to resample). Defaults to 'near'.\n        **kwargs (optional): All parameters that can be passed to rasterio.warp.reproject function.\n\n    Returns:\n        raster: Matched raster image with the same projection, resolution, and extent as the reference image.\n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    from rasterio.transform import from_bounds\n    import numpy as np\n    from .common import get_extent_local, array2raster\n\n    # *****************************************\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        input_image = input.read()\n        meta = input.meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    ### Define reference image\n    if isinstance(reference, rasterio.DatasetReader):\n        reference_image = reference.read()\n        meta_reference = reference.meta\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    ### Check CRS and Resolution\n    if (meta[\"crs\"] != meta_reference['crs']) or (meta['transform'][0] != meta_reference['transform'][0]):\n        raise ValueError('Input and reference images have different Projection and Resolution')\n    # If having the same CRS and Resolution\n    else:\n\n        # *****************************************\n        # Get general extent from two images\n        ext_input = get_extent_local(input)[0]\n        ext_reference = get_extent_local(reference)[0]\n\n        ext = ext_input\n        ext = (\n            min(ext[0], ext_reference[0]),\n            min(ext[1], ext_reference[1]),\n            max(ext[2], ext_reference[2]),\n            max(ext[3], ext_reference[3])\n            )\n\n        # *****************************************\n        # Calculate new height &amp; width and new transform\n        resolution = meta_reference['transform'][0]    \n        width_new = int((ext[2]  - ext[0]) / resolution)\n        height_new = int((ext[3] - ext[1]) / resolution)\n\n        transform_new = from_bounds(ext[0], ext[1], ext[2], ext[3], width_new, height_new)\n\n        # *****************************************\n        # Resampling method\n        if method.lower() == 'near' or method.lower() == 'nearest':\n            resampleAlg = warp.Resampling.nearest\n        elif method.lower() == 'mean' or method.lower() == 'average':\n            resampleAlg = warp.Resampling.average\n        elif method.lower() == 'max':\n            resampleAlg = warp.Resampling.max\n        elif method.lower() == 'min':\n            resampleAlg = warp.Resampling.min\n        elif (method.lower() == 'median') or (method.lower() == 'med'):\n            resampleAlg = warp.Resampling.med\n        elif method.lower() == 'mode':\n            resampleAlg = warp.Resampling.mode\n        elif method.lower() == 'q1':\n            resampleAlg = warp.Resampling.q1\n        elif method.lower() == 'q3':\n            resampleAlg = warp.Resampling.q3\n        elif method.lower() == 'rsm':\n            resampleAlg = warp.Resampling.rms\n        elif method.lower() == 'sum':\n            resampleAlg = warp.Resampling.sum\n        elif method.lower() == 'cubic':\n            resampleAlg = warp.Resampling.cubic\n        elif method.lower() == 'spline':\n            resampleAlg = warp.Resampling.cubic_spline\n        elif method.lower() == 'bilinear':\n            resampleAlg = warp.Resampling.bilinear\n        elif method.lower() == 'gauss':\n            resampleAlg = warp.Resampling.gauss\n        elif method.lower() == 'lanczos':\n            resampleAlg = warp.Resampling.lanczos\n        else:\n            raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n        # *****************************************\n        # Reproject to match\n        if len(input_image.shape) &gt; 2:\n            nbands = input_image.shape[0]\n        else:\n            nbands = 1\n        # Run over each band\n        matched = np.empty((nbands, height_new, width_new), dtype=np.float32)\n        for band in range(0, nbands):\n            if nbands &lt;= 1:\n                ds = input_image\n            else:\n                ds = input_image[band, : , : ]\n            warp.reproject(source=ds, destination=matched[band, :, :], src_transform= meta['transform'], dst_transform= transform_new, src_crs=meta['crs'], dst_crs=meta_reference['crs'], resampling= resampleAlg, **kwargs)\n\n        # *****************************************\n        # Mask out other values\n        match_masked = np.where(matched == 0, np.nan, matched)\n        match_masked = match_masked.astype(np.float32)\n\n        # *****************************************\n        # Update metadata and Convert to raster\n        meta_update = meta.copy()\n        meta_update.update({\n            'crs': meta_reference['crs'],\n            'transform': transform_new,\n            'width': width_new,\n            'height': height_new,\n            'dtype': np.float32\n        })\n        match_raster = array2raster(match_masked, meta_update)\n\n        return match_raster\n</code></pre>"},{"location":"processor/#geonate.processor.merge","title":"<code>merge(input)</code>","text":"<p>Merges multiple raster files into a single raster file by computing the average values at overlapped areas.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>List of input raster files.</p> required <p>Returns:</p> Type Description <code>A merged raster (raster)</code> <p>The merged raster file.</p> Source code in <code>geonate/processor.py</code> <pre><code>def merge(input: list):\n    \"\"\"\n    Merges multiple raster files into a single raster file by computing the average values at overlapped areas.\n\n    Args:\n        input (list): List of input raster files.\n\n    Returns:\n        A merged raster (raster): The merged raster file.\n\n    \"\"\"\n    from rasterio import merge \n    from .common import array2raster\n\n    # Initialize empty list to store all input files and stack input into it \n    merged_files = []\n    for tmp in input:\n        merged_files.append(tmp)\n\n    # Compute sum and count numbers of images, and average values at overlapped areas\n    mosaic_sum, out_trans = merge.merge(merged_files, method= merge.copy_sum)\n    mosaic_count, out_trans = merge.merge(merged_files, method= merge.copy_count)\n    mosaic_average = mosaic_sum / mosaic_count\n\n    # Update metadata with new transform and image dimensions\n    meta = merged_files[0].meta\n    meta.update({\"driver\": \"GTiff\",\n                            \"height\": mosaic_average.shape[1],\n                            \"width\": mosaic_average.shape[2],\n                            \"transform\": out_trans})\n\n    # Convert array to raster file\n    merged_raster = array2raster(mosaic_average, meta)\n\n    return merged_raster    \n</code></pre>"},{"location":"processor/#geonate.processor.mergeVRT","title":"<code>mergeVRT(input, output, compress=True, silent=True)</code>","text":"<p>Merge multiple geotif files using gdal VRT for better performance speed</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>list</code> <p>List of input geotif files</p> required <code>output</code> <code>AnyStr</code> <p>Path of output tif file</p> required <code>compress</code> <code>bool</code> <p>Whether compress the output data or not. Defaults to True.</p> <code>True</code> <code>silent</code> <code>bool</code> <p>Show or do not show file processing log. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any local variable. It writes raster file to local drive.</p> Source code in <code>geonate/processor.py</code> <pre><code>def mergeVRT(input: AnyStr, output: AnyStr, compress: bool=True, silent=True):\n    \"\"\"Merge multiple geotif files using gdal VRT for better performance speed\n\n    Args:\n        input (list): List of input geotif files\n        output (AnyStr): Path of output tif file\n        compress (bool, optional): Whether compress the output data or not. Defaults to True.\n        silent (bool, optional): Show or do not show file processing log. Defaults to True.\n\n    Return:\n        None: The function does not return any local variable. It writes raster file to local drive.\n\n    \"\"\"\n    import os\n    from osgeo import gdal\n    #  Create a temp vrt file\n    vrt_file = 'merged.vrt'\n\n    if compress is True:\n        vrt_options = gdal.BuildVRTOptions()\n        gdal.BuildVRT(vrt_file, input, options=vrt_options)\n        gdal.Translate(output, vrt_file, format='GTiff', creationOptions=['COMPRESS=LZW'])\n\n    else:\n        gdal.BuildVRT(vrt_file, input)\n        gdal.Translate(output, vrt_file)\n\n    os.remove(vrt_file)\n    if silent is True:\n        pass\n    else:\n        print(f\"Finished merge raster files, the output is at {output}\")\n</code></pre>"},{"location":"processor/#geonate.processor.normalized","title":"<code>normalized(input)</code>","text":"<p>Normalize raster data to rearrange raster values from 0 to 1</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader | np.ndarray</code> <p>Rasterio image or data array.</p> required <p>Returns:</p> Type Description <code>raster | data array</code> <p>Data array or raster depends on the input files.</p> Source code in <code>geonate/processor.py</code> <pre><code>def normalized(input):\n    \"\"\"\n    Normalize raster data to rearrange raster values from 0 to 1\n\n    Args:\n        input (DatasetReader | np.ndarray): Rasterio image or data array.\n\n    Returns:\n        raster | data array: Data array or raster depends on the input files.\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import pandas as pd\n    from .common import array2raster\n\n    ### Check input data\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    elif isinstance(input, np.ndarray):\n        dataset = input\n        meta = meta\n    else:\n        raise ValueError('Input data is not supported')\n\n    ### Find max min values\n    maxValue = np.nanmax(dataset)\n    minValue = np.nanmin(dataset)\n\n    ### Create empty data array to store output\n    normalized = np.zeros_like(dataset, dtype=np.float32)\n\n    ### Run normalization for each \n    for i in range(0, dataset.shape[0]):\n        band = dataset[i, : , : ]\n        band_norm = (band.astype(float)  - minValue) / (maxValue  - minValue)\n        normalized[i, : , : ] = band_norm\n        band_norm = None        # set to None after the iteration\n\n    ### Define output\n    if isinstance(input, rasterio.DatasetReader):\n        meta.update({'dtype': np.float32})\n        normalized_raster = array2raster(normalized, meta)\n    else:\n        normalized_raster = normalized\n\n    return normalized_raster\n</code></pre>"},{"location":"processor/#geonate.processor.normalizedDifference","title":"<code>normalizedDifference(input, band1, band2)</code>","text":"<p>Calculate normalized difference index</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Raster | Array</code> <p>Rasterio object or data array, input with multiple bands.</p> required <code>band1</code> <code>numeric</code> <p>Order of the first band in the input.</p> required <code>band2</code> <code>numeric</code> <p>Order of the second band in the input.</p> required <p>Returns:</p> Type Description <code>raster | dataArray</code> <p>Normalized difference result in raster or data array depending on input, containing all image pixel values</p> Source code in <code>geonate/processor.py</code> <pre><code>def normalizedDifference(input, band1, band2):\n    \"\"\"\n    Calculate normalized difference index\n\n    Args:\n        input (Raster | Array): Rasterio object or data array, input with multiple bands.\n        band1 (numeric): Order of the first band in the input.\n        band2 (numeric): Order of the second band in the input.\n\n    Returns:\n        raster | dataArray: Normalized difference result in raster or data array depending on input, containing all image pixel values\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    from .common import array2raster\n\n    # *****************************************\n    # Define data input\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        dataset = input\n        meta = None\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    # Extract band values\n    ds_band1 = dataset[band1+1, : , : ]\n    ds_band2 = dataset[band2+1, : , : ]\n\n    # *****************************************\n    # Calculate index and Remove outliers, also\n    normalized_index  = (ds_band1.astype(float) - ds_band2.astype(float)) / (ds_band1 + ds_band2)\n    normalized_index = normalized_index.astype(np.float32)\n\n    normalized_index[(normalized_index &lt; -1) | (normalized_index &gt; 1)] = np.nan\n\n    # *****************************************\n    # Define output \n    if isinstance(input, rasterio.DatasetReader):\n        meta.update({'dtype': np.float32, 'count': 1})                                                  #  update datatype in metadata \n        normalized_output = array2raster(normalized_index, meta)\n    elif isinstance(input, np.ndarray):\n        normalized_output = normalized_index\n    else:\n        normalized_output = []\n\n    return normalized_output\n</code></pre>"},{"location":"processor/#geonate.processor.pca","title":"<code>pca(input, n_component=3, **kwargs)</code>","text":"<p>Perform Principal Component Analysis (PCA) on multispectral data for data Dimension Reduction.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>rasterio.DatasetReader or np.ndarray</code> <p>Multispectral input data. Can be a raster image or a numpy array.</p> required <code>n_component</code> <code>int</code> <p>Number of principal components to compute. Default is 3.</p> <code>3</code> <code>**kwargs</code> <code>optional</code> <p>All parameters in sklearn.decomposition.PCA()</p> <code>{}</code> <p>Returns:</p> Type Description <code>np.ndarray or rasterio.DatasetReader</code> <p>PCA-transformed data in the same format as the input.</p> Source code in <code>geonate/processor.py</code> <pre><code>def pca(input, n_component: int=3, **kwargs):\n    \"\"\"\n    Perform Principal Component Analysis (PCA) on multispectral data for data Dimension Reduction.\n\n    Args:\n        input (rasterio.DatasetReader or np.ndarray): Multispectral input data. Can be a raster image or a numpy array.\n        n_component (int): Number of principal components to compute. Default is 3.\n        **kwargs (optional): All parameters in sklearn.decomposition.PCA()\n\n    Returns:\n        np.ndarray or rasterio.DatasetReader: PCA-transformed data in the same format as the input.\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    from sklearn.decomposition import PCA\n    from .common import array2raster, reshape_raster\n\n    # Identify datatype and define input data\n    # Raster image\n    if isinstance(input, rasterio.DatasetReader):\n        arr = input.read()\n        height, width = input.shape\n        nbands =  input.count\n        meta = input.meta\n    # Data Array\n    elif isinstance(input, np.ndarray):\n        if len(input.shape) &lt; 3:\n            raise ValueError('Input must be multispectral data (multi-band)')\n        else:\n            arr = input\n            nbands, height, width = input.shape\n\n    else: \n        raise ValueError('Input is not supported')\n\n    # Reshape from raster to image format, and from 3D to 2D\n    ds = reshape_raster(arr, mode='image')\n    ds_reshaped = ds.reshape((-1, nbands)) # -1 means this dim will be determined by other dims\n\n    # Define PCA model and fit the PCA model\n    pca_model = PCA(n_components= n_component, **kwargs)\n    pca_fit = pca_model.fit_transform(ds_reshaped, **kwargs)\n\n    # Reshape the result to the new shape\n    pca_img = pca_fit.reshape((height, width, n_component))\n\n    # Reshape from image to raster format \n    pca_raster = reshape_raster(pca_img, mode='raster')\n\n    # Return output based on input similar to input\n    if isinstance(input, np.ndarray):\n        return pca_raster\n\n    # Convert to rasterio object\n    elif isinstance(input, rasterio.DatasetReader):\n        meta.update({'count': n_component})\n        pca_rast = array2raster(pca_raster, meta)\n        return pca_rast\n</code></pre>"},{"location":"processor/#geonate.processor.reclassify","title":"<code>reclassify(input, breakpoints, classes)</code>","text":"<p>Reclassify image with discrete or continuous values</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | array</code> <p>Raster or data array input</p> required <code>breakpoints</code> <code>list</code> <p>Number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]</p> required <code>classes</code> <code>list</code> <p>Number list, define classes, number of classes equal number of breakpoints minus 1</p> required <p>Returns:</p> Type Description <code>raster | dataArray</code> <p>Reclassified result in raster or data array depending on input, containing all image pixel values</p> Source code in <code>geonate/processor.py</code> <pre><code>def reclassify(input, breakpoints, classes):\n    \"\"\"\n    Reclassify image with discrete or continuous values\n\n    Args:\n        input (raster | array): Raster or data array input\n        breakpoints (list): Number list, defines a breakpoint value for reclassifcation, e.g., [ -1, 0, 1]\n        classes (list): Number list, define classes, number of classes equal number of breakpoints minus 1\n\n    Returns:\n        raster | dataArray: Reclassified result in raster or data array depending on input, containing all image pixel values\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    from .common import array2raster\n\n    # *****************************************\n    # Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        if len(input.shape) == 2:\n            dataset = input.read()\n            meta = input.meta\n        elif len(input.shape) == 3:\n            if  input.shape[0] &gt; 1:\n                raise ValueError('Input data has more than one band')\n            else:\n                dataset = input.read(1)\n                meta = input.meta\n    # input is array\n    elif isinstance(input, np.ndarray):\n        if (len(input.shape)) &gt; 2 and (input.shape[0] &gt; 1):\n            raise ValueError('Input data has more than one band')\n        else:\n            dataset = input\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    # Create unique values and empty data array to store reclassified result \n    uniques = np.unique(dataset)\n    reclassified = np.zeros_like(dataset)\n\n    # *****************************************\n    # If image has discrete values\n    if len(uniques) == len(classes): \n        if len(breakpoints) == len(classes):\n            for i in range(len(classes)):\n                reclassified[dataset == breakpoints[i]] = classes[i]\n        elif len(breakpoints) == (len(classes)-1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n\n    # If image has continuous values\n    else:\n        if len(breakpoints) == (len(classes)+1):\n            for i in range(len(classes)):\n                reclassified[(dataset &gt;= breakpoints[i]) &amp; (dataset &lt; breakpoints[i+1])] = classes[i]\n        else:\n            raise ValueError('Number of classes must be equal to number of breakpoints minus 1')\n\n    # *****************************************\n    # Define output\n    if isinstance(input, rasterio.DatasetReader):\n        reclassified_raster = array2raster(reclassified, meta)\n    else:\n        reclassified_raster = reclassified\n\n    return reclassified_raster\n</code></pre>"},{"location":"processor/#geonate.processor.reproject","title":"<code>reproject(input, reference, method='near', res=None, **kwargs)</code>","text":"<p>Reprojects and resamples a given raster image to a specified coordinate reference system (CRS) and resolution.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster</code> <p>The input raster image to be reprojected.</p> required <code>reference</code> <code>raster | shapefile</code> <p>The reference CRS for reprojection. It can be a string (e.g., 'EPSG:4326') or a rasterio DatasetReader object. If None, the input CRS is used.</p> required <code>method</code> <code>AnyStr</code> <p>The resampling method to use. Default is 'near'. Supported methods include 'nearest', 'average', 'max', 'min', 'median', 'mode', 'q1', 'q3', 'rms', 'sum', 'cubic', 'cubic_spline', 'bilinear', 'gauss', 'lanczos'.</p> <code>'near'</code> <code>res</code> <code>numeric</code> <p>The output resolution. If None, the input resolution is used.</p> <code>None</code> <code>**kwargs</code> <code>optional</code> <p>All parameters that can be passed to rasterio.warp.reproject function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>raster</code> <p>The reprojected raster image</p> Source code in <code>geonate/processor.py</code> <pre><code>def reproject(input, reference, method: Optional[AnyStr]='near', res: Optional[float]=None, **kwargs):\n    \"\"\"\n    Reprojects and resamples a given raster image to a specified coordinate reference system (CRS) and resolution.\n\n    Args:\n        input (raster): The input raster image to be reprojected.\n        reference (raster | shapefile): The reference CRS for reprojection. It can be a string (e.g., 'EPSG:4326') or a rasterio DatasetReader object. If None, the input CRS is used.\n        method (AnyStr, optional): The resampling method to use. Default is 'near'. Supported methods include 'nearest', 'average', 'max', 'min', 'median', 'mode', 'q1', 'q3', 'rms', 'sum', 'cubic', 'cubic_spline', 'bilinear', 'gauss', 'lanczos'.\n        res (numeric, optional): The output resolution. If None, the input resolution is used.\n        **kwargs (optional): All parameters that can be passed to rasterio.warp.reproject function.\n\n    Returns:\n        raster: The reprojected raster image\n\n    \"\"\"\n    import numpy as np\n    import rasterio\n    from rasterio import warp\n    from .common import array2raster\n\n    # *********************************************\n    # Define input image\n    input_image = input.read()\n    meta = input.meta\n    left, bottom, right, top = input.bounds\n\n    # *********************************************\n    # Determine parameters and new transform\n    # Reference string of EPSG\n    if isinstance(reference, str):\n        dst_crs = reference\n        if res is None:\n            raise ValueError('Please provide output resolution')\n        else:\n            xsize, ysize = res, res\n        # Transform to new transform\n        transform_new, width_new, height_new = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, \\\n                                                                                                                                                height=meta['height'], width=meta['width'], \\\n                                                                                                                                                resolution=(xsize, ysize), \\\n                                                                                                                                                left=left, bottom=bottom, right=right, top=top)\n    # Take all paras from reference image\n    elif isinstance(reference, rasterio.DatasetReader):\n        dst_crs = reference.crs\n        if res is None:\n            xsize, ysize = reference.res\n        else:\n            xsize, ysize = res, res\n        # Transform to new transform\n        transform_new, width_new, height_new = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=dst_crs, \\\n                                                                                                                                                height=meta['height'], width=meta['width'], \\\n                                                                                                                                                resolution=(xsize, ysize), \\\n                                                                                                                                                left=left, bottom=bottom, right=right, top=top)\n    # Other cases\n    else:\n        raise ValueError('Please define correct reference, it is CRS string or an image reference')\n\n    # *******************************************\n    # Update metadata\n    meta_update = meta.copy()\n    meta_update.update({\n        'crs': dst_crs,\n        'transform': transform_new,\n        'width': width_new,\n        'height': height_new,\n    })\n    # *******************************************\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods rasterio.warp.Resampling')\n\n    # ***************************************\n    # Running reproject \n    projected_array = np.empty((input_image.shape[0], height_new, width_new), dtype= meta['dtype'])\n    for band in range(0, input_image.shape[0]):\n        ds = input_image[band, : , : ]\n        warp.reproject(source=ds, destination=projected_array[(band), :, :], \\\n                       src_transform= meta['transform'], dst_transform=transform_new, \\\n                        src_crs=meta['crs'], dst_crs=dst_crs, \\\n                        resampling= resampleAlg,\n                        **kwargs)\n\n    # *****************************************\n    # Convert array back to raster\n    reprojected = array2raster(projected_array, meta_update)\n\n    return reprojected\n</code></pre>"},{"location":"processor/#geonate.processor.resample","title":"<code>resample(input, factor, mode='aggregate', method='near', **kwargs)</code>","text":"<p>Resample raster image based on factor</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>DatasetReader</code> <p>Input rasterio image.</p> required <code>factor</code> <code>numeric</code> <p>Resampling factor compared to original image (e.g., 2, 4, 6).</p> required <code>mode</code> <code>str</code> <p>Resample mode [\"aggregate\", \"disaggregate\"]. Defaults to 'aggregate'.</p> <code>'aggregate'</code> <code>method</code> <code>str</code> <p>Resampling method (e.g., 'nearest', 'cubic', 'bilinear', 'average'). Defaults to 'near'.</p> <code>'near'</code> <code>**kwargs</code> <code>optional</code> <p>All parameters that can be passed to rasterio.warp.reproject function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>raster</code> <p>Resampled raster image.        </p> Source code in <code>geonate/processor.py</code> <pre><code>def resample(input, factor, mode='aggregate', method='near', **kwargs):\n    \"\"\"\n    Resample raster image based on factor\n\n    Args:\n        input (DatasetReader): Input rasterio image.\n        factor (numeric): Resampling factor compared to original image (e.g., 2, 4, 6).\n        mode (str, optional): Resample mode [\"aggregate\", \"disaggregate\"]. Defaults to 'aggregate'.\n        method (str, optional): Resampling method (e.g., 'nearest', 'cubic', 'bilinear', 'average'). Defaults to 'near'.\n        **kwargs (optional): All parameters that can be passed to rasterio.warp.reproject function.\n\n    Returns:\n        raster: Resampled raster image.        \n\n    \"\"\"\n    import rasterio\n    from rasterio import warp\n    import numpy as np\n    from .common import array2raster\n\n    # *****************************************\n    ### Define input image\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n        meta = input.meta\n        left, bottom, right, top = input.bounds\n        nbands = input.count\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    #### Calculate new rows and columns\n    if (mode.lower() == 'aggregate') or (mode.lower() == 'agg') or (mode.lower() == 'a'):\n        new_height = meta['height'] // factor\n        new_width = meta['width'] // factor\n\n    elif (mode.lower() == 'disaggregate') or (mode.lower() == 'disagg') or (mode.lower() == 'd'):\n        new_height = meta['height'] * factor\n        new_width = meta['width'] * factor\n\n    else:\n        raise ValueError('Resample method is not supported [\"aggregate\", \"disaggregate\"]')\n\n    # *****************************************\n    # Calculate new transform\n    transform_new, width, height = warp.calculate_default_transform(src_crs=meta['crs'], dst_crs=meta['crs'], width=new_width, height=new_height, left=left, bottom=bottom, right=right, top=top)\n\n    # *****************************************\n    # Resampling method\n    if method.lower() == 'near' or method.lower() == 'nearest':\n        resampleAlg = warp.Resampling.nearest\n    elif method.lower() == 'mean' or method.lower() == 'average':\n        resampleAlg = warp.Resampling.average\n    elif method.lower() == 'max':\n        resampleAlg = warp.Resampling.max\n    elif method.lower() == 'min':\n        resampleAlg = warp.Resampling.min\n    elif (method.lower() == 'median') or (method.lower() == 'med'):\n        resampleAlg = warp.Resampling.med\n    elif method.lower() == 'mode':\n        resampleAlg = warp.Resampling.mode\n    elif method.lower() == 'q1':\n        resampleAlg = warp.Resampling.q1\n    elif method.lower() == 'q3':\n        resampleAlg = warp.Resampling.q3\n    elif method.lower() == 'rsm':\n        resampleAlg = warp.Resampling.rms\n    elif method.lower() == 'sum':\n        resampleAlg = warp.Resampling.sum\n    elif method.lower() == 'cubic':\n        resampleAlg = warp.Resampling.cubic\n    elif method.lower() == 'spline':\n        resampleAlg = warp.Resampling.cubic_spline\n    elif method.lower() == 'bilinear':\n        resampleAlg = warp.Resampling.bilinear\n    elif method.lower() == 'gauss':\n        resampleAlg = warp.Resampling.gauss\n    elif method.lower() == 'lanczos':\n        resampleAlg = warp.Resampling.lanczos\n    else:\n        raise ValueError('The resampling method is not supported, available methods raster.Resampling.')\n\n    # *****************************************\n    # Define and Update the metadata for the destination raster\n    metadata = meta.copy()\n    metadata.update({\n        'transform': transform_new,\n        'width': new_width,\n        'height': new_height, \n        'dtype': np.float32\n    })\n\n    # *****************************************\n    # Run Resampling for each band\n    resampled = np.empty((nbands, new_height, new_width), dtype=np.float32)\n\n    for band in range(0, nbands):\n        if nbands &lt;= 1:\n            ds = dataset\n        else:\n            ds = dataset[band, : , : ]\n\n        warp.reproject(source=ds, destination=resampled[band, :, :], \\\n                       src_transform= meta['transform'], dst_transform= transform_new, \\\n                        src_crs=meta['crs'], dst_crs=input.crs, resampling= resampleAlg, **kwargs)\n\n    # *****************************************\n    # Convert array to raster \n    resampled_raster = array2raster(resampled, metadata)\n\n    return resampled_raster\n</code></pre>"},{"location":"processor/#geonate.processor.values","title":"<code>values(input, na_rm=True, names=None, prefix=None)</code>","text":"<p>Extract all pixel values of image and create dataframe from them, each band is a column</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>raster | array</code> <p>Rasterio raster image or data array.</p> required <code>na_rm</code> <code>bool</code> <p>Remove or do not remove NA value from output dataframe. Defaults to True.</p> <code>True</code> <code>names</code> <code>list</code> <p>Given expected names for each column in the dataframe, if not, default name will be assigned. Defaults to None.</p> <code>None</code> <code>prefix</code> <code>AnyStr</code> <p>Given character before each band name. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Dataframe stores all pixel values across all image bands.</p> Source code in <code>geonate/processor.py</code> <pre><code>def values(input, na_rm: Optional[bool]=True, names: Optional[list]=None, prefix: Optional[AnyStr]=None):\n    \"\"\"\n    Extract all pixel values of image and create dataframe from them, each band is a column\n\n    Args:\n        input (raster | array): Rasterio raster image or data array.\n        na_rm (bool, optional): Remove or do not remove NA value from output dataframe. Defaults to True.\n        names (list, optional): Given expected names for each column in the dataframe, if not, default name will be assigned. Defaults to None.\n        prefix (AnyStr, optional): Given character before each band name. Defaults to None.\n\n    Returns:\n        DataFrame: Dataframe stores all pixel values across all image bands.\n\n    \"\"\"\n    import rasterio\n    import numpy as np\n    import pandas as pd\n\n    # *****************************************\n    # Check input data\n    # input is raster\n    if isinstance(input, rasterio.DatasetReader):\n        dataset = input.read()\n    # input is array\n    elif isinstance(input, np.ndarray):\n        dataset = input\n    # Other input\n    else:\n        raise ValueError('Input data is not supported')\n\n    # *****************************************\n    # Define parameters\n    nbands = dataset.shape[0]\n    bands_array = [dataset[band, : , : ].flatten() for band in range(0, nbands)]\n\n    # *****************************************\n    # Assign column names in case name is given \n    if names is not None:\n        if len(names) != nbands:\n            raise ValueError('Length of name should be equal to number of bands')\n        else:\n            if prefix is None:\n                data = pd.DataFrame(np.array(bands_array).T, columns=names)\n            else:\n                names_new = [f'{prefix}{name}' for name in names]\n                data = pd.DataFrame(np.array(bands_array).T, columns=names_new)\n    # If name is not given\n    else:\n        if prefix is None:\n            data = pd.DataFrame(np.array(bands_array).T, columns=[f'B{i}' for i in range(1,nbands +1)])\n        else:\n            data = pd.DataFrame(np.array(bands_array).T, columns=[f'{prefix}{i}' for i in range(1, nbands +1)])\n\n    # *****************************************\n    # Remove NA values or not\n    if na_rm is True: \n        data_out = data.dropna().reset_index(drop=True)\n    else:\n        data_out = data\n\n    return data_out\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use geonate in a project:</p> <pre><code>import geonate\n</code></pre>"},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>from geonate import common, processor\n</pre> from geonate import common, processor"}]}